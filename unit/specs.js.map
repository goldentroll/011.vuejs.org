{"version":3,"sources":["webpack:///webpack/bootstrap 829408e1843685b70fc0","webpack:///./test/unit/specs/api/child_spec.js","webpack:///./src/vue.js","webpack:///./src/instance/compile.js","webpack:///./src/util/index.js","webpack:///./src/config.js","webpack:///./src/util/lang.js","webpack:///./src/util/env.js","webpack:///./src/util/dom.js","webpack:///./src/util/debug.js","webpack:///./src/directive.js","webpack:///./src/watcher.js","webpack:///./src/observer/index.js","webpack:///./src/observer/dep.js","webpack:///./src/observer/array.js","webpack:///./src/observer/object.js","webpack:///./src/parsers/expression.js","webpack:///./src/parsers/path.js","webpack:///./src/cache.js","webpack:///./src/batcher.js","webpack:///./src/parsers/text.js","webpack:///./src/parsers/directive.js","webpack:///./src/compiler/compile.js","webpack:///./src/parsers/template.js","webpack:///./src/directives/component.js","webpack:///./src/compiler/transclude.js","webpack:///./src/api/global.js","webpack:///./src/directives/index.js","webpack:///./src/directives/text.js","webpack:///./src/directives/html.js","webpack:///./src/directives/attr.js","webpack:///./src/directives/show.js","webpack:///./src/transition/index.js","webpack:///./src/directives/class.js","webpack:///./src/directives/el.js","webpack:///./src/directives/ref.js","webpack:///./src/directives/cloak.js","webpack:///./src/directives/style.js","webpack:///./src/directives/transition.js","webpack:///./src/directives/on.js","webpack:///./src/directives/model/index.js","webpack:///./src/directives/model/radio.js","webpack:///./src/directives/model/select.js","webpack:///./src/directives/model/checkbox.js","webpack:///./src/directives/repeat.js","webpack:///./src/directives/if.js","webpack:///./src/directives/events.js","webpack:///./src/filters/index.js","webpack:///./src/filters/array-filters.js","webpack:///./src/instance/init.js","webpack:///./src/instance/events.js","webpack:///./src/instance/scope.js","webpack:///./src/api/data.js","webpack:///./src/api/dom.js","webpack:///./src/api/events.js","webpack:///./src/api/child.js","webpack:///./src/api/lifecycle.js","webpack:///./test/unit/specs/api/data_spec.js","webpack:///./test/unit/specs/api/dom_spec.js","webpack:///./test/unit/specs/api/events_spec.js","webpack:///./test/unit/specs/api/global_spec.js","webpack:///./test/unit/specs/api/lifecycle_spec.js","webpack:///./test/unit/specs/batcher_spec.js","webpack:///./test/unit/specs/cache_spec.js","webpack:///./test/unit/specs/compiler/compile_spec.js","webpack:///./test/unit/specs/compiler/transclude_spec.js","webpack:///./test/unit/specs/directive_spec.js","webpack:///./test/unit/specs/directives/attr_spec.js","webpack:///./test/unit/specs/directives/class_spec.js","webpack:///./test/unit/specs/directives/cloak_spec.js","webpack:///./test/unit/specs/directives/component_spec.js","webpack:///./test/unit/specs/directives/el_spec.js","webpack:///./test/unit/specs/directives/events_spec.js","webpack:///./test/unit/specs/directives/html_spec.js","webpack:///./test/unit/specs/directives/if_spec.js","webpack:///./test/unit/specs/directives/model_spec.js","webpack:///./test/unit/specs/directives/on_spec.js","webpack:///./test/unit/specs/directives/pre_spec.js","webpack:///./test/unit/specs/directives/ref_spec.js","webpack:///./test/unit/specs/directives/repeat_spec.js","webpack:///./test/unit/specs/directives/show_spec.js","webpack:///./test/unit/specs/directives/style_spec.js","webpack:///./test/unit/specs/directives/text_spec.js","webpack:///./test/unit/specs/directives/transition_spec.js","webpack:///./test/unit/specs/filters/filters_spec.js","webpack:///./test/unit/specs/instance/events_spec.js","webpack:///./test/unit/specs/instance/init_spec.js","webpack:///./test/unit/specs/instance/scope_spec.js","webpack:///./test/unit/specs/misc_spec.js","webpack:///./test/unit/specs/observer/dep_spec.js","webpack:///./test/unit/specs/observer/observer_spec.js","webpack:///./test/unit/specs/parsers/directive_spec.js","webpack:///./test/unit/specs/parsers/expression_spec.js","webpack:///./test/unit/specs/parsers/path_spec.js","webpack:///./test/unit/specs/parsers/template_spec.js","webpack:///./test/unit/specs/parsers/text_spec.js","webpack:///./test/unit/specs/transition/transition_spec.js","webpack:///./test/unit/specs/util/debug_spec.js","webpack:///./test/unit/specs/util/dom_spec.js","webpack:///./test/unit/specs/util/env_spec.js","webpack:///./test/unit/specs/util/lang_spec.js","webpack:///./test/unit/specs/watcher_spec.js","webpack:///./src/util/merge-option.js","webpack:///./src/directives/partial.js","webpack:///./src/directives/model/default.js","webpack:///./src/directives/with.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH,EAAC,C;;;;;;AC7ED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAkB;AAClB,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6B;;;;;;ACtFA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,cAAc;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,6BAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACrKA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4K;;;;;;;ACRA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAY;AACZ;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;;AAEA,sBAAqB,MAAM;AAC3B;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,EAAC,C;;;;;;ACrFD;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,WAAW;AACtB,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,EAAE;AACb,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,aAAY,SAAS;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,EAAE;AACb;;AAEA;AACA,kCAAiC,OAAO;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;AC5QA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,G;;;;;;ACpFD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrMA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;ACrEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB,YAAW,IAAI;AACf,YAAW,OAAO;AAClB,uBAAsB,OAAO;AAC7B,uBAAsB,OAAO;AAC7B,uBAAsB,cAAc;AACpC,YAAW,OAAO;AAClB,YAAW,cAAc;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAuB,aAAa;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,YAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA,2B;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,IAAI;AACf,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,uBAAsB,MAAM;AAC5B,uBAAsB,QAAQ;AAC9B,uBAAsB,QAAQ;AAC9B,uBAAsB,QAAQ;AAC9B,uBAAsB,SAAS;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA,yB;;;;;;AClOA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,aAAa;AACxB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,aAAa;AACxB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,aAAa;AACxB,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC,OAAO;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,IAAI;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,IAAI;AACf;;AAEA;AACA;AACA;;AAEA;;;;;;;ACzOA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,UAAU;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,UAAU;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAkC,OAAO;AACzC;AACA;AACA;;AAEA,qB;;;;;;AC/CA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb,aAAY,EAAE;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8B;;;;;;ACzFA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACjFA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,OAAO;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA,uDAAsD;AACtD,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA,0DAAyD;AACzD,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACtQA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY,OAAO;AACnB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA,2BAA0B;AAC1B;AACA,IAAG,+BAA+B;AAClC;AACA,IAAG;AACH;AACA,IAAG,OAAO;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,aAAY;AACZ;;AAEA;AACA;AACA,kCAAiC,aAAa,aAAa;AAC3D;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,eAAe;AAC1B,YAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;AClUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uB;;;;;;AC/GA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;;AAEA;AACA;AACA;AACA,kBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA,SAAQ,cAAc;AACtB,SAAQ,SAAS;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,E;;;;;;AC7FA;AACA;AACA;AACA,gCAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ,qBAAoB,OAAO;AAC3B,qBAAoB,OAAO;AAC3B,qBAAoB,QAAQ;AAC5B,qBAAoB,QAAQ;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAgC,GAAG;AACnC;AACA;AACA,YAAW,MAAM;AACjB,YAAW,IAAI;AACf,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,IAAI;AACf,YAAW,QAAQ;AACnB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;AC3KA;AACA;AACA;AACA,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAQ;AACR;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA,oCAAmC;AACnC,oCAAmC;AACnC,4BAA2B;AAC3B,4BAA2B;AAC3B,6BAA4B;AAC5B,6BAA4B;AAC5B,4BAA2B;AAC3B,4BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;AClLA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,yBAAyB;AACpC,YAAW,OAAO;AAClB,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,yBAAyB;AACtC,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,aAAY,SAAS;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,oBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,aAAY,cAAc;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,cAAc;AACzB,YAAW,iBAAiB;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA,uCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,gBAAgB;AAC3B,aAAY,SAAS;AACrB;;AAEA;AACA;AACA;AACA,+CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,eAAe;AAC1B,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,aAAY,SAAS;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,OAAO;AAClB,aAAY,SAAS;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,aAAY,SAAS;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY,SAAS;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;AC3oBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,yBAAyB;AACpC,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb;AACA;AACA;AACA;AACA,wCAAuC,KAAK;AAC5C,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,aAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;ACnQA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,eAAc;AACd;AACA,eAAc,IAAI;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA,0BAAyB,MAAM;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,E;;;;;;ACrOA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,yBAAyB;AACpC,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO,OAAO;AACd;AACA;AACA,MAAK,OAAO;AACZ;AACA;AACA;AACA;AACA,kCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,cAAc;AACzB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA,uCAAsC,OAAO;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,YAAY;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACrNA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA,kBAAiB,sBAAsB;AACvC;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,EAAE;AACf;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,gBAAgB;AAC7B;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8B;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6C;;;;;;ACxBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA,E;;;;;;ACdA;AACA;;AAEA;;AAEA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,E;;;;;;ACrCA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,E;;;;;;AC/BA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH,E;;;;;;ACPA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,IAAI;AACf,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,IAAI;AACf,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,IAAI;AACf,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,YAAW,IAAI;AACf,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,YAAW,iBAAiB;AAC5B,YAAW,KAAK;AAChB,YAAW,IAAI;AACf;;AAEA;AACA;AACA,oCAAmC,OAAO;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,OAAO;AAClB;AACA;AACA,YAAW,SAAS;AACpB,YAAW,IAAI;AACf,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;AC/HA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACjBA;;AAEA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA,E;;;;;;ACZA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,E;;;;;;ACtBA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA,E;;;;;;ACXA;AACA;AACA;AACA,+BAA8B;AAC9B;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACnGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,E;;;;;;;;ACvBA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,E;;;;;;AC1DA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,E;;;;;;;ACvDA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA,E;;;;;;ACzBA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,QAAQ;AACnB,YAAW,MAAM;AACjB;;AAEA;AACA;AACA,sCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,cAAc;AACzB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,MAAM;AACjB,YAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACnLA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA,E;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA,mDAAkD;AAClD;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,cAAa,oBAAoB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB,cAAa,MAAM;AACnB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,QAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB;;AAEA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,IAAI;AACf,YAAW,YAAY;AACvB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACxhBA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,E;;;;;;ACjIA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,E;;;;;;ACnCA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA,qBAAoB,EAAE;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACvIA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK,8CAA8C;AACnD;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,YAAW,EAAE;AACb,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,E;;;;;;ACtFA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,0BAAyB;AACzB,0BAAyB;AACzB;AACA,0BAAyB;AACzB,0BAAyB;AACzB;;AAEA;AACA;;AAEA;AACA,4BAA2B;AAC3B,4BAA2B;AAC3B;;AAEA;AACA;AACA,0CAAyC;AACzC,0CAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,E;;;;;;AChGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,IAAI;AACf,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,OAAO;AAC7C;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,IAAI;AACf,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA,yCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA,E;;;;;;ACzIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,E;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,EAAE;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB,YAAW,QAAQ;AACnB,aAAY,SAAS;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACrKA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,IAAI;AACf,YAAW,QAAQ;AACnB,YAAW,SAAS;AACpB,YAAW,QAAQ;AACnB,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,IAAI;AACf,YAAW,KAAK;AAChB,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,eAAe;AAC1B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,IAAI;AACf,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,KAAK;AAChB,YAAW,IAAI;AACf,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,KAAK;AAChB,YAAW,IAAI;AACf,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA,E;;;;;;AClNA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,IAAI;AACf,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;AC7KA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,SAAS;AACpB,aAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAsD;AACtD,+CAA8C;AAC9C,+BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;AC7CA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,gCAAgC;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,yBAAyB;AACpC,aAAY;AACZ;;AAEA;AACA;AACA,E;;;;;;ACvEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,+BAA8B,GAAG,OAAO,kBAAkB;AAC1D,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,E;;;;;;AC5KA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP,MAAK;;AAEL,IAAG;AACH,E;;;;;;ACrLA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,6CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH,EAAC,C;;;;;;ACrID;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;;AAEH,EAAC,C;;;;;;ACjGD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,6BAA4B,MAAM;AAClC;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,wBAAuB,GAAG;AAC1B;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,kBAAiB;AACjB,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,kBAAiB,cAAc;AAC/B,6BAA4B,MAAM;AAClC,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,kBAAiB;AACjB,UAAS;AACT;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,kBAAiB,cAAc;AAC/B,6BAA4B,MAAM,aAAa,YAAY;AAC3D,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;;AAEP,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,2BAA0B,SAAS;AACnC;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,wBAAuB,GAAG;AAC1B,kBAAiB;AACjB,UAAS;AACT,sCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,6BAA4B,MAAM;AAClC,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT,QAAO;;AAEP,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,wBAAuB,GAAG;AAC1B;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,kCAAiC,GAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;;AAEP,MAAK;;AAEL,IAAG;AACH,E;;;;;;;AChTA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH,EAAC,C;;;;;;ACrGD;;AAEA;AACA;AACA;AACA,YAAW,MAAM;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,EAAC,C;;;;;;ACrDD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,mBAAkB;AAClB,mBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,yBAAwB,GAAG,OAAO,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,GAAG;AACd,qCAAoC,IAAI;AACxC;AACA,MAAK;;AAEL;AACA;AACA,0BAAyB,OAAO,IAAI,QAAQ,GAAG,UAAU;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,eAAc,IAAI;AAClB,iCAAgC,GAAG,OAAO,IAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,4CAA2C,GAAG;AAC9C;AACA,uCAAsC,GAAG;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,yBAAwB,IAAI;AAC5B,0BAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,gDAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,mDAAkD,MAAM;AACxD;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,eAAc,kCAAkC;AAChD,eAAc;AACd;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL,IAAG;AACH,E;;;;;;AClPA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA,6BAA4B,IAAI;AAChC;AACA;AACA,qCAAoC,IAAI;AACxC,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,kCAAiC,IAAI;AACrC;AACA;AACA;AACA;AACA;AACA,qCAAoC,IAAI;AACxC,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;AACH,E;;;;;;AC1HA;AACA;AACA;;AAEA;;AAEA,cAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAY,KAAK;AACjB,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,sBAAqB,GAAG;AACxB,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,sBAAqB,GAAG;AACxB,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,YAAY;AAC7B,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH,EAAC,C;;;;;;AChMD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;AACH,E;;;;;;AC/CA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;AACH,E;;;;;;ACvCA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL,IAAG;AACH,E;;;;;;ACxBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB,cAAa;AACb,0BAAyB,GAAG;AAC5B;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB,cAAa;AACb,6BAA4B,GAAG;AAC/B;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA,8DAA6D,GAAG;AAChE;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,uBAAsB;AACtB,cAAa;AACb;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB,cAAa;AACb,6BAA4B,GAAG,SAAS,GAAG;AAC3C;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA,wCAAuC,MAAM;AAC7C;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA,YAAW;AACX;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,wCAAuC,MAAM;AAC7C;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,0DAAyD,SAAS;AAClE;AACA;AACA,mDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,wDAAuD,SAAS;AAChE;AACA;AACA,8CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA,mBAAkB,IAAI,GAAG,IAAI;AAC7B,UAAS;AACT,yDAAwD,MAAM;AAC9D;AACA;AACA,oDAAmD,GAAG;AACtD;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,wCAAuC,MAAM;AAC7C;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,wCAAuC,MAAM;AAC7C;AACA,eAAc,kBAAkB;AAChC,eAAc;AACd,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,wCAAuC,MAAM;AAC7C;AACA,eAAc,kBAAkB;AAChC,eAAc;AACd,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,wCAAuC,MAAM;AAC7C;AACA;AACA,UAAS;AACT;AACA,mBAAkB;AAClB;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL,IAAG;AACH,E;;;;;;ACjYA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,qBAAqB;AACpC,wDAAuD,QAAQ;AAC/D,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL,IAAG;AACH,E;;;;;;ACzCA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;;AAEL,IAAG;AACH,E;;;;;;AC/HA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;AACH,E;;;;;;AC1CA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA,0BAAyB,GAAG;AAC5B;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,8BAA8B;AAC7C,+CAA8C,GAAG,SAAS,GAAG;AAC7D,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA,uBAAsB;AACtB,cAAa;AACb,0BAAyB,GAAG;AAC5B;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,wCAAuC,MAAM;AAC7C;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,YAAW;AACX,UAAS;AACT,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,oCAAmC,GAAG;AACtC,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,oDAAmD,MAAM,IAAI,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,IAAI;AACtB,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA,0BAAyB,GAAG;AAC5B;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB,IAAI;AAC1B;AACA;AACA;AACA;AACA,yBAAwB,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;AACH,E;;;;;;AC7TA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB;AAChB;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB;AAChB;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,wBAAwB;AACrC,cAAa;AACb;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,iCAAiC;AAC9C,cAAa;AACb;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,iDAAgD,GAAG;AACnD,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,SAAS;AACxB;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL,IAAG;AACH,E;;;;;;ACroBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAe,IAAI;AACnB;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,0CAAyC,GAAG;AAC5C,gBAAe;AACf,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,uDAAsD,GAAG;AACzD,gBAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,YAAY;AAC3B;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL,IAAG;AACH,E;;;;;;ACrIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iCAAgC,GAAG;AACnC;AACA;AACA;AACA,QAAO;AACP,qDAAoD,GAAG;AACvD,MAAK;;AAEL,IAAG;AACH,E;;;;;;;AClBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,eAAe;AAC9B,wCAAuC,MAAM;AAC7C,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,gBAAgB;AAC/B,wCAAuC,MAAM;AAC7C;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,qBAAqB;AACpC;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL,IAAG;AACH,E;;;;;;ACzHA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,oBAAmB,IAAI,GAAG,IAAI;AAC9B,UAAS;AACT,4CAA2C,QAAQ,GAAG,GAAG;AACzD,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,4CAA2C,QAAQ,GAAG,QAAQ;AAC9D,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,oBAAmB,IAAI,GAAG,IAAI;AAC9B,UAAS;AACT,iDAAgD,QAAQ,GAAG,QAAQ;AACnE,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,iDAAgD,QAAQ,GAAG,MAAM;AACjE,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iBAAgB,IAAI;AACpB,iBAAgB;AAChB;AACA,UAAS;AACT,4CAA2C,QAAQ,GAAG,MAAM,GAAG,GAAG;AAClE,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,4CAA2C,QAAQ,GAAG,MAAM,GAAG,QAAQ;AACvE,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iBAAgB,IAAI;AACpB,iBAAgB;AAChB;AACA,UAAS;AACT,iDAAgD,QAAQ,GAAG,MAAM,GAAG,QAAQ;AAC5E,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,iDAAgD,QAAQ,GAAG,MAAM,GAAG,MAAM;AAC1E,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,4CAA2C,QAAQ,GAAG,QAAQ;AAC9D,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iBAAgB,aAAa;AAC7B,iBAAgB;AAChB;AACA,UAAS;AACT,+DAA8D,KAAK;AACnE,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,oBAAmB,IAAI,GAAG,IAAI;AAC9B,UAAS;AACT;AACA;AACA;AACA,+BAA8B,QAAQ,GAAG,GAAG;AAC5C;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,oBAAmB,IAAI,GAAG,IAAI;AAC9B,UAAS;AACT;AACA;AACA,gBAAe,QAAQ,GAAG,GAAG;AAC7B;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,+BAA8B,QAAQ,GAAG,QAAQ;AACjD;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,iBAAgB,IAAI;AACpB,iBAAgB;AAChB;AACA,UAAS;AACT;AACA;AACA;AACA,+BAA8B,QAAQ,GAAG,MAAM,GAAG,GAAG;AACrD;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,oBAAmB,IAAI,GAAG,IAAI,GAAG,IAAI;AACrC,UAAS;AACT;AACA;AACA;AACA,0BAAyB,QAAQ,GAAG,GAAG;AACvC;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,oBAAmB,IAAI,GAAG,IAAI,GAAG,IAAI;AACrC,UAAS;AACT;AACA;AACA;AACA,6BAA4B,QAAQ,GAAG,GAAG;AAC1C;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,cAAa,UAAU,IAAI,GAAG,IAAI,SAAS;AAC3C,cAAa,UAAU,IAAI,GAAG,IAAI;AAClC;AACA,UAAS;AACT;AACA,oCAAmC,QAAQ,GAAG,GAAG,GAAG,gBAAgB,GAAG,WAAW;AAClF;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,sBAAqB,KAAK,EAAE,KAAK;AACjC,sBAAqB,KAAK,EAAE,KAAK;AACjC;AACA,UAAS;AACT,+CAA8C,MAAM;AACpD,qCAAoC,GAAG;AACvC;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,6DAA4D,MAAM;AAClE;AACA;AACA,cAAa,YAAY;AACzB,cAAa,YAAY;AACzB,cAAa;AACb;AACA,UAAS;AACT;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,6DAA4D,QAAQ;AACpE;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA,mDAAkD,GAAG,SAAS,OAAO;AACrE;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa;AACb;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa;AACb;AACA,UAAS;AACT;AACA;AACA,6BAA4B,GAAG,SAAS,OAAO;AAC/C;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,4EAA2E,KAAK;AAChF;AACA;AACA;AACA,mBAAkB,IAAI,EAAE,IAAI,EAAE,IAAI;AAClC,UAAS;AACT;AACA;AACA;AACA,6CAA4C,GAAG;AAC/C;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,qFAAoF,IAAI;AACxF;AACA;AACA;AACA;AACA,cAAa,4BAA4B;AACzC,cAAa,2BAA2B;AACxC,cAAa,4BAA4B;AACzC,cAAa;AACb;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,yBAAwB,2BAA2B;AACnD,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa,6BAA6B;AAC1C,cAAa;AACb;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA,YAAW;AACX;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,4DAA2D,QAAQ;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA,gEAA+D,QAAQ;AACvE;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;;AAEA,wFAAuF,KAAK;AAC5F,+FAA8F,UAAU;AACxG,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,mBAAmB;AAClC,gBAAe,mBAAmB;AAClC,gBAAe;AACf;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAW,mBAAmB;AAC9B,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,oBAAmB,KAAK,GAAG,KAAK;AAChC,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA,wCAAuC,QAAQ,GAAG,QAAQ;AAC1D,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA,8CAA6C,QAAQ,GAAG,QAAQ;AAChE,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,oBAAmB,IAAI,GAAG,IAAI;AAC9B,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gEAA+D,GAAG;AAClE;AACA,oBAAmB,IAAI,GAAG,IAAI,GAAG,IAAI;AACrC,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,8BAA6B,IAAI;AACjC;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA,oCAAmC,QAAQ;AAC3C,kCAAiC,QAAQ;AACzC;AACA;AACA,iBAAgB;AAChB;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA,2DAA0D,KAAK,qCAAqC,KAAK;AACzG,0EAAyE,KAAK,kDAAkD,KAAK;AACrI,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf,kBAAiB;AACjB,kBAAiB;AACjB,gBAAe,6BAA6B;AAC5C,gBAAe;AACf;AACA,YAAW;AACX;AACA,UAAS;AACT;;AAEA;;AAEA;AACA,YAAW;AACX,cAAa,uBAAuB;AACpC,cAAa;AACb,cAAa;AACb,YAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,YAAW;AACX;AACA;AACA;AACA,MAAK;;AAEL,IAAG;AACH;;AAEA;AACA;AACA;AACA,YAAW,SAAS;AACpB,YAAW,SAAS;AACpB;;AAEA;AACA;AACA,cAAa,aAAa;AAC1B;AACA,wBAAuB,aAAa;AACpC;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAqB,IAAI;AACzB,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA,8BAA6B,IAAI;AACjC,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAmB,IAAI,GAAG,IAAI,GAAG,IAAI;AACrC,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB;AACpB,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAY,IAAI;AAChB,aAAY;AACZ;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,2BAA0B,IAAI;AAC9B,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,E;;;;;;ACv9BA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;AACH,E;;;;;;AC5BA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,M;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,6BAA4B;AAC5B,mEAAkE;AAClE,MAAK;;AAEL;AACA;AACA,kCAAiC;AACjC;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,mBAAkB,kCAAkC;AACpD;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,mBAAkB,eAAe;AACjC;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,aAAa;AAC5B,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL,IAAG;AACH,E;;;;;;ACrGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;AACH,E;;;;;;AC/BA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,aAAY,qBAAqB;AACjC,aAAY;AACZ;AACA;AACA;AACA,uDAAsD,OAAO;AAC7D;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,YAAW;AACX,UAAS;AACT,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAK;;AAEL,IAAG;AACH,E;;;;;;ACjGA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAe,GAAG;AAClB;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,iBAAgB,KAAK,OAAO;AAC5B;AACA;AACA,yBAAwB,KAAK;AAC7B;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,cAAa,aAAa;AAC1B;AACA,cAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA,cAAa,aAAa;AAC1B;AACA,cAAa,cAAc;AAC3B;AACA,IAAG;;AAEH;AACA;AACA;AACA,QAAO,WAAW,cAAc;AAChC,QAAO,kBAAkB;AACzB,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,QAAO,KAAK,OAAO,SAAS;AAC5B,QAAO,KAAK,OAAO,SAAS;AAC5B,QAAO,KAAK,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;AChMA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,iBAAgB;AAChB,YAAW;AACX;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;;AAEA;AACA;AACA,wBAAuB,GAAG;AAC1B,kBAAiB,OAAO;AACxB;AACA;AACA;AACA,kDAAiD,GAAG;AACpD;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,wBAAuB,GAAG;AAC1B,kBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,UAAS;;AAET,QAAO;;AAEP;;AAEA,IAAG;;AAEH,EAAC,C;;;;;;ACnRD;;AAEA;;AAEA;AACA;AACA,iBAAgB;AAChB,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH,EAAC,C;;;;;;;ACpDD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;;AAEH,EAAC,C;;;;;;AC1JD;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gCAA+B,MAAM;AACrC;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH,EAAC,C;;;;;;ACjDD;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,EAAC,C;;;;;;ACjCD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,kBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,gBAAe,KAAK,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,IAAI,IAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,kBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH,EAAC,C;;;;;;ACnND;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,+EAA8E,QAAQ;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,QAAQ;AAC7C,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH,EAAC,C;;;;;;AC/HD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS,GAAG;AACZ,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,UAAS,GAAG;AACZ,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA,YAAW,mBAAmB;AAC9B,YAAW,KAAK;AAChB,gBAAe;AACf,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA,qBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,WAAU,KAAK,SAAS;AACxB;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,WAAU,eAAe;AACzB,WAAU;AACV,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,WAAU;AACV,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB;AAClB;AACA,QAAO;AACP,WAAU,SAAS,MAAM;AACzB;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,aAAY,cAAc;AAC1B;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,aAAY,OAAO;AACnB;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,aAAY,qBAAqB;AACjC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,WAAU,OAAO;AACjB;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,gBAAe,GAAG;AAClB;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,EAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,E;;;;;;ACpTA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,mBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,0BAAyB;AACzB;AACA,IAAG;;AAEH,EAAC,C;;;;;;ACxHD;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,8BAA6B;AAC7B;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,E;;;;;;AClJA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,gBAAe,KAAK;AACpB;AACA,QAAO,cAAc;AACrB,QAAO,qDAAqD;AAC5D,QAAO;AACP;AACA,IAAG;AACH;AACA;AACA,cAAa,QAAQ,QAAQ,SAAS;AACtC;AACA,QAAO,wDAAwD;AAC/D,QAAO,iBAAiB;AACxB,QAAO,uDAAuD;AAC9D;AACA,IAAG;AACH;AACA;AACA,cAAa,SAAS,QAAQ,UAAU;AACxC;AACA,QAAO,uDAAuD;AAC9D,QAAO,iBAAiB;AACxB,QAAO,sDAAsD;AAC7D;AACA,IAAG;AACH;AACA;AACA,cAAa,UAAU,OAAO,QAAQ;AACtC;AACA,QAAO,wEAAwE;AAC/E,QAAO,iBAAiB;AACxB,QAAO;AACP;AACA,IAAG;AACH;AACA,eAAc,KAAK;AACnB;AACA,QAAO,aAAa;AACpB,QAAO,uDAAuD;AAC9D,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA,oCAAmC,GAAG;AACtC,oCAAmC,GAAG;AACtC;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,UAAS,uDAAuD;AAChE,UAAS,iBAAiB;AAC1B,UAAS,uDAAuD;AAChE;AACA,MAAK;AACL,6BAA4B,MAAM;AAClC,IAAG;;AAEH;AACA,2CAA0C,UAAU,QAAQ,UAAU;AACtE;AACA;AACA,IAAG;;AAEH;AACA;AACA,cAAa;AACb,MAAK;AACL,2CAA0C,OAAO,QAAQ,IAAI;AAC7D;AACA;AACA,IAAG;;AAEH;AACA,sCAAqC,YAAY;AACjD;AACA;AACA,IAAG;;AAEH;AACA,wCAAuC,SAAS;AAChD;AACA;AACA,IAAG;;AAEH,EAAC,C;;;;;;AC5HD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA,yBAAwB;AACxB;AACA;AACA;AACA,QAAO;;AAEP;AACA,yBAAwB;AACxB;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP,MAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAgB;AAChB,qDAAoD;AACpD,8DAA6D;AAC7D;AACA,4CAA2C,YAAY,EAAE;AACzD;AACA,4BAA2B;AAC3B,kDAAiD;AACjD,2DAA0D;AAC1D,2BAA0B;AAC1B,kDAAiD;AACjD,2DAA0D;AAC1D,gCAA+B;AAC/B,iBAAgB,aAAa;AAC7B,eAAc,cAAc;AAC5B,wCAAuC;AACvC,iBAAgB,aAAa;AAC7B,eAAc,cAAc;AAC5B,gCAA+B;AAC/B,iBAAgB,aAAa;AAC7B,eAAc,cAAc;AAC5B,wCAAuC;AACvC,iBAAgB,aAAa;AAC7B,eAAc,cAAc;AAC5B;;AAEA;AACA;AACA;AACA;AACA,uBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;;AAEP,MAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA,uBAAsB,SAAS;AAC/B,QAAO;;AAEP;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT,QAAO;;AAEP,MAAK;;AAEL,IAAG;AACH,E;;;;;;ACvZA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL,IAAG;AACH,E;;;;;;AC3CA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,E;;;;;;AClIA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP,MAAK;;AAEL,IAAG;;AAEH,EAAC,C;;;;;;ACnBD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA,iBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAkC;AAClC,IAAG;;AAEH;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAuC;AACvC;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,wBAAuB;AACvB;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH,EAAC,C;;;;;;;;ACtID;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc,OAAO;AACrB;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,KAAK,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA,mBAAkB,KAAK;AACvB;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO,0BAA0B;AACjC,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA,MAAK;AACL,eAAc;AACd;AACA;AACA;AACA,eAAc,MAAM,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL,iCAAgC;AAChC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH,EAAC,C;;;;;;AC/YD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW,EAAE;AACb,YAAW,EAAE;AACb,YAAW,IAAI;AACf;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW,OAAO;AAClB,YAAW,OAAO;AAClB,YAAW,IAAI;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACjQA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,E;;;;;;ACjDA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,E;;;;;;ACnJA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA,E","file":"specs.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 829408e1843685b70fc0\n **/","var Vue = require('../../../../src/vue')\n\ndescribe('Child API', function () {\n\n  var vm\n  beforeEach(function () {\n    vm = new Vue({\n      data: {\n        a: 1,\n        b: 1\n      },\n      directives: {\n        test: function () {}\n      }\n    })\n  })\n\n  it('default', function () {\n    var child = vm.$addChild()\n    expect(child instanceof Vue).toBe(true)\n    expect(child.a).toBeUndefined()\n    expect(child.$parent).toBe(vm)\n    expect(child.$root).toBe(vm)\n    expect(vm._children.indexOf(child)).toBe(0)\n    expect(child.$options.directives.test).toBeTruthy()\n  })\n\n  it('inherit scope', function () {\n    var child = vm.$addChild({\n      inherit: true,\n      data: {\n        b: 2\n      }\n    })\n    expect(child.a).toBe(1)\n    expect(child.b).toBe(2)\n    expect(child.constructor.prototype).toBe(vm)\n  })\n\n  it('with constructor', function () {\n    var Ctor = Vue.extend({\n      inherit: true,\n      data: function () {\n        return {\n          c: 3\n        }\n      }\n    })\n    var child = vm.$addChild({\n      data: {\n        b: 2\n      }\n    }, Ctor)\n    expect(child.a).toBe(1)\n    expect(child.b).toBe(2)\n    expect(child.c).toBe(3)\n    expect(child.constructor.options).toBe(Ctor.options)\n  })\n\n  it('cache constructor', function () {\n    var Ctor = Vue.extend({\n      inherit: true\n    })\n    var child1 = vm.$addChild(null, Ctor)\n    var child2 = vm.$addChild(null, Ctor)\n    expect(child1.constructor).toBe(child2.constructor)\n  })\n\n  it('Use proper constructor name with inherit', function () {\n    var Ctor = Vue.extend({\n      name: 'vue-test',\n      inherit: true\n    })\n    var child = vm.$addChild(null, Ctor)\n    expect(child.constructor.toString().match(/^function VueTest\\s?\\(/)).toBeTruthy()\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/api/child_spec.js\n ** module id = 1\n ** module chunks = 0\n **/","var _ = require('./util')\nvar extend = _.extend\n\n/**\n * The exposed Vue constructor.\n *\n * API conventions:\n * - public API methods/properties are prefiexed with `$`\n * - internal methods/properties are prefixed with `_`\n * - non-prefixed properties are assumed to be proxied user\n *   data.\n *\n * @constructor\n * @param {Object} [options]\n * @public\n */\n\nfunction Vue (options) {\n  this._init(options)\n}\n\n/**\n * Mixin global API\n */\n\nextend(Vue, require('./api/global'))\n\n/**\n * Vue and every constructor that extends Vue has an\n * associated options object, which can be accessed during\n * compilation steps as `this.constructor.options`.\n *\n * These can be seen as the default options of every\n * Vue instance.\n */\n\nVue.options = {\n  directives  : require('./directives'),\n  filters     : require('./filters'),\n  transitions : {},\n  components  : {},\n  elementDirectives: {}\n}\n\n/**\n * Build up the prototype\n */\n\nvar p = Vue.prototype\n\n/**\n * $data has a setter which does a bunch of\n * teardown/setup work\n */\n\nObject.defineProperty(p, '$data', {\n  get: function () {\n    return this._data\n  },\n  set: function (newData) {\n    if (newData !== this._data) {\n      this._setData(newData)\n    }\n  }\n})\n\n/**\n * Mixin internal instance methods\n */\n\nextend(p, require('./instance/init'))\nextend(p, require('./instance/events'))\nextend(p, require('./instance/scope'))\nextend(p, require('./instance/compile'))\nextend(p, require('./instance/misc'))\n\n/**\n * Mixin public API methods\n */\n\nextend(p, require('./api/data'))\nextend(p, require('./api/dom'))\nextend(p, require('./api/events'))\nextend(p, require('./api/child'))\nextend(p, require('./api/lifecycle'))\n\nmodule.exports = _.Vue = Vue\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/vue.js\n ** module id = 2\n ** module chunks = 0\n **/","var _ = require('../util')\nvar Directive = require('../directive')\nvar compile = require('../compiler/compile')\nvar transclude = require('../compiler/transclude')\n\n/**\n * Transclude, compile and link element.\n *\n * If a pre-compiled linker is available, that means the\n * passed in element will be pre-transcluded and compiled\n * as well - all we need to do is to call the linker.\n *\n * Otherwise we need to call transclude/compile/link here.\n *\n * @param {Element} el\n * @return {Element}\n */\n\nexports._compile = function (el) {\n  var options = this.$options\n  if (options._linkFn) {\n    // pre-transcluded with linker, just use it\n    this._initElement(el)\n    options._linkFn(this, el)\n  } else {\n    // transclude and init element\n    // transclude can potentially replace original\n    // so we need to keep reference\n    var original = el\n    el = transclude(el, options)\n    this._initElement(el)\n    // compile and link the rest\n    compile(el, options)(this, el)\n    // finally replace original\n    if (options.replace) {\n      _.replace(original, el)\n    }\n  }\n  return el\n}\n\n/**\n * Initialize instance element. Called in the public\n * $mount() method.\n *\n * @param {Element} el\n */\n\nexports._initElement = function (el) {\n  if (el instanceof DocumentFragment) {\n    this._isBlock = true\n    this.$el = this._blockStart = el.firstChild\n    this._blockEnd = el.lastChild\n    this._blockFragment = el\n  } else {\n    this.$el = el\n  }\n  this.$el.__vue__ = this\n  this._callHook('beforeCompile')\n}\n\n/**\n * Create and bind a directive to an element.\n *\n * @param {String} name - directive name\n * @param {Node} node   - target node\n * @param {Object} desc - parsed directive descriptor\n * @param {Object} def  - directive definition object\n * @param {Vue|undefined} host - transclusion host component\n */\n\nexports._bindDir = function (name, node, desc, def, host) {\n  this._directives.push(\n    new Directive(name, node, this, desc, def, host)\n  )\n}\n\n/**\n * Teardown an instance, unobserves the data, unbind all the\n * directives, turn off all the event listeners, etc.\n *\n * @param {Boolean} remove - whether to remove the DOM node.\n * @param {Boolean} deferCleanup - if true, defer cleanup to\n *                                 be called later\n */\n\nexports._destroy = function (remove, deferCleanup) {\n  if (this._isBeingDestroyed) {\n    return\n  }\n  this._callHook('beforeDestroy')\n  this._isBeingDestroyed = true\n  var i\n  // remove self from parent. only necessary\n  // if parent is not being destroyed as well.\n  var parent = this.$parent\n  if (parent && !parent._isBeingDestroyed) {\n    i = parent._children.indexOf(this)\n    parent._children.splice(i, 1)\n  }\n  // same for transclusion host.\n  var host = this._host\n  if (host && !host._isBeingDestroyed) {\n    i = host._transCpnts.indexOf(this)\n    host._transCpnts.splice(i, 1)\n  }\n  // destroy all children.\n  i = this._children.length\n  while (i--) {\n    this._children[i].$destroy()\n  }\n  // teardown all directives. this also tearsdown all\n  // directive-owned watchers. intentionally check for\n  // directives array length on every loop since directives\n  // that manages partial compilation can splice ones out\n  for (i = 0; i < this._directives.length; i++) {\n    this._directives[i]._teardown()\n  }\n  // teardown all user watchers.\n  var watcher\n  for (i in this._userWatchers) {\n    watcher = this._userWatchers[i]\n    if (watcher) {\n      watcher.teardown()\n    }\n  }\n  // remove reference to self on $el\n  if (this.$el) {\n    this.$el.__vue__ = null\n  }\n  // remove DOM element\n  var self = this\n  if (remove && this.$el) {\n    this.$remove(function () {\n      self._cleanup()\n    })\n  } else if (!deferCleanup) {\n    this._cleanup()\n  }\n}\n\n/**\n * Clean up to ensure garbage collection.\n * This is called after the leave transition if there\n * is any.\n */\n\nexports._cleanup = function () {\n  // remove reference from data ob\n  this._data.__ob__.removeVm(this)\n  this._data =\n  this._watchers =\n  this._userWatchers =\n  this._watcherList =\n  this.$el =\n  this.$parent =\n  this.$root =\n  this._children =\n  this._transCpnts =\n  this._directives = null\n  // call the last hook...\n  this._isDestroyed = true\n  this._callHook('destroyed')\n  // turn off all instance listeners.\n  this.$off()\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/instance/compile.js\n ** module id = 3\n ** module chunks = 0\n **/","var lang   = require('./lang')\nvar extend = lang.extend\n\nextend(exports, lang)\nextend(exports, require('./env'))\nextend(exports, require('./dom'))\nextend(exports, require('./misc'))\nextend(exports, require('./debug'))\nextend(exports, require('./options'))\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util/index.js\n ** module id = 4\n ** module chunks = 0\n **/","module.exports = {\n\n  /**\n   * The prefix to look for when parsing directives.\n   *\n   * @type {String}\n   */\n\n  prefix: 'v-',\n\n  /**\n   * Whether to print debug messages.\n   * Also enables stack trace for warnings.\n   *\n   * @type {Boolean}\n   */\n\n  debug: false,\n\n  /**\n   * Whether to suppress warnings.\n   *\n   * @type {Boolean}\n   */\n\n  silent: false,\n\n  /**\n   * Whether allow observer to alter data objects'\n   * __proto__.\n   *\n   * @type {Boolean}\n   */\n\n  proto: true,\n\n  /**\n   * Whether to parse mustache tags in templates.\n   *\n   * @type {Boolean}\n   */\n\n  interpolate: true,\n\n  /**\n   * Whether to use async rendering.\n   */\n\n  async: true,\n\n  /**\n   * Whether to warn against errors caught when evaluating\n   * expressions.\n   */\n\n  warnExpressionErrors: true,\n\n  /**\n   * Internal flag to indicate the delimiters have been\n   * changed.\n   *\n   * @type {Boolean}\n   */\n\n  _delimitersChanged: true\n\n}\n\n/**\n * Interpolation delimiters.\n * We need to mark the changed flag so that the text parser\n * knows it needs to recompile the regex.\n *\n * @type {Array<String>}\n */\n\nvar delimiters = ['{{', '}}']\nObject.defineProperty(module.exports, 'delimiters', {\n  get: function () {\n    return delimiters\n  },\n  set: function (val) {\n    delimiters = val\n    this._delimitersChanged = true\n  }\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/config.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * Check is a string starts with $ or _\n *\n * @param {String} str\n * @return {Boolean}\n */\n\nexports.isReserved = function (str) {\n  var c = (str + '').charCodeAt(0)\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Guard text output, make sure undefined outputs\n * empty string\n *\n * @param {*} value\n * @return {String}\n */\n\nexports.toString = function (value) {\n  return value == null\n    ? ''\n    : value.toString()\n}\n\n/**\n * Check and convert possible numeric numbers before\n * setting back to data\n *\n * @param {*} value\n * @return {*|Number}\n */\n\nexports.toNumber = function (value) {\n  return (\n    isNaN(value) ||\n    value === null ||\n    typeof value === 'boolean'\n  ) ? value\n    : Number(value)\n}\n\n/**\n * Strip quotes from a string\n *\n * @param {String} str\n * @return {String | false}\n */\n\nexports.stripQuotes = function (str) {\n  var a = str.charCodeAt(0)\n  var b = str.charCodeAt(str.length - 1)\n  return a === b && (a === 0x22 || a === 0x27)\n    ? str.slice(1, -1)\n    : false\n}\n\n/**\n * Replace helper\n *\n * @param {String} _ - matched delimiter\n * @param {String} c - matched char\n * @return {String}\n */\nfunction toUpper (_, c) {\n  return c ? c.toUpperCase () : ''\n}\n\n/**\n * Camelize a hyphen-delmited string.\n *\n * @param {String} str\n * @return {String}\n */\n\nvar camelRE = /-(\\w)/g\nexports.camelize = function (str) {\n  return str.replace(camelRE, toUpper)\n}\n\n/**\n * Converts hyphen/underscore/slash delimitered names into\n * camelized classNames.\n *\n * e.g. my-component => MyComponent\n *      some_else    => SomeElse\n *      some/comp    => SomeComp\n *\n * @param {String} str\n * @return {String}\n */\n\nvar classifyRE = /(?:^|[-_\\/])(\\w)/g\nexports.classify = function (str) {\n  return str.replace(classifyRE, toUpper)\n}\n\n/**\n * Simple bind, faster than native\n *\n * @param {Function} fn\n * @param {Object} ctx\n * @return {Function}\n */\n\nexports.bind = function (fn, ctx) {\n  return function (a) {\n    var l = arguments.length\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n}\n\n/**\n * Convert an Array-like object to a real Array.\n *\n * @param {Array-like} list\n * @param {Number} [start] - start index\n * @return {Array}\n */\n\nexports.toArray = function (list, start) {\n  start = start || 0\n  var i = list.length - start\n  var ret = new Array(i)\n  while (i--) {\n    ret[i] = list[i + start]\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n *\n * @param {Object} to\n * @param {Object} from\n */\n\nexports.extend = function (to, from) {\n  for (var key in from) {\n    to[key] = from[key]\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexports.isObject = function (obj) {\n  return obj && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nvar toString = Object.prototype.toString\nexports.isPlainObject = function (obj) {\n  return toString.call(obj) === '[object Object]'\n}\n\n/**\n * Array type check.\n *\n * @param {*} obj\n * @return {Boolean}\n */\n\nexports.isArray = function (obj) {\n  return Array.isArray(obj)\n}\n\n/**\n * Define a non-enumerable property\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n * @param {Boolean} [enumerable]\n */\n\nexports.define = function (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value        : val,\n    enumerable   : !!enumerable,\n    writable     : true,\n    configurable : true\n  })\n}\n\n/**\n * Debounce a function so it only gets called after the\n * input stops arriving after the given wait period.\n *\n * @param {Function} func\n * @param {Number} wait\n * @return {Function} - the debounced function\n */\n\nexports.debounce = function(func, wait) {\n  var timeout, args, context, timestamp, result\n  var later = function() {\n    var last = Date.now() - timestamp\n    if (last < wait && last >= 0) {\n      timeout = setTimeout(later, wait - last)\n    } else {\n      timeout = null\n      result = func.apply(context, args)\n      if (!timeout) context = args = null\n    }\n  }\n  return function() {\n    context = this\n    args = arguments\n    timestamp = Date.now()\n    if (!timeout) {\n      timeout = setTimeout(later, wait)\n    }\n    return result\n  }\n}\n\n/**\n * Manual indexOf because it's slightly faster than\n * native.\n *\n * @param {Array} arr\n * @param {*} obj\n */\n\nexports.indexOf = function (arr, obj) {\n  for (var i = 0, l = arr.length; i < l; i++) {\n    if (arr[i] === obj) return i\n  }\n  return -1\n}\n\n/**\n * Make a cancellable version of an async callback.\n *\n * @param {Function} fn\n * @return {Function}\n */\n\nexports.cancellable = function (fn) {\n  var cb = function () {\n    if (!cb.cancelled) {\n      return fn.apply(this, arguments)\n    }\n  }\n  cb.cancel = function () {\n    cb.cancelled = true\n  }\n  return cb\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util/lang.js\n ** module id = 7\n ** module chunks = 0\n **/","// can we use __proto__?\nexports.hasProto = '__proto__' in {}\n\n// Browser environment sniffing\nvar inBrowser = exports.inBrowser =\n  typeof window !== 'undefined' &&\n  Object.prototype.toString.call(window) !== '[object Object]'\n\nexports.isIE9 =\n  inBrowser &&\n  navigator.userAgent.toLowerCase().indexOf('msie 9.0') > 0\n\nexports.isAndroid =\n  inBrowser &&\n  navigator.userAgent.toLowerCase().indexOf('android') > 0\n\n// Transition property/event sniffing\nif (inBrowser && !exports.isIE9) {\n  var isWebkitTrans =\n    window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  var isWebkitAnim =\n    window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  exports.transitionProp = isWebkitTrans\n    ? 'WebkitTransition'\n    : 'transition'\n  exports.transitionEndEvent = isWebkitTrans\n    ? 'webkitTransitionEnd'\n    : 'transitionend'\n  exports.animationProp = isWebkitAnim\n    ? 'WebkitAnimation'\n    : 'animation'\n  exports.animationEndEvent = isWebkitAnim\n    ? 'webkitAnimationEnd'\n    : 'animationend'\n}\n\n/**\n * Defer a task to execute it asynchronously. Ideally this\n * should be executed as a microtask, so we leverage\n * MutationObserver if it's available, and fallback to\n * setTimeout(0).\n *\n * @param {Function} cb\n * @param {Object} ctx\n */\n\nexports.nextTick = (function () {\n  var callbacks = []\n  var pending = false\n  var timerFunc\n  function handle () {\n    pending = false\n    var copies = callbacks.slice(0)\n    callbacks = []\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]()\n    }\n  }\n  /* istanbul ignore if */\n  if (typeof MutationObserver !== 'undefined') {\n    var counter = 1\n    var observer = new MutationObserver(handle)\n    var textNode = document.createTextNode(counter)\n    observer.observe(textNode, {\n      characterData: true\n    })\n    timerFunc = function () {\n      counter = (counter + 1) % 2\n      textNode.data = counter\n    }\n  } else {\n    timerFunc = setTimeout\n  }\n  return function (cb, ctx) {\n    var func = ctx\n      ? function () { cb.call(ctx) }\n      : cb\n    callbacks.push(func)\n    if (pending) return\n    pending = true\n    timerFunc(handle, 0)\n  }\n})()\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util/env.js\n ** module id = 8\n ** module chunks = 0\n **/","var config = require('../config')\n\n/**\n * Check if a node is in the document.\n * Note: document.documentElement.contains should work here\n * but always returns false for comment nodes in phantomjs,\n * making unit tests difficult. This is fixed byy doing the\n * contains() check on the node's parentNode instead of\n * the node itself.\n *\n * @param {Node} node\n * @return {Boolean}\n */\n\nvar doc =\n  typeof document !== 'undefined' &&\n  document.documentElement\n\nexports.inDoc = function (node) {\n  var parent = node && node.parentNode\n  return doc === node ||\n    doc === parent ||\n    !!(parent && parent.nodeType === 1 && (doc.contains(parent)))\n}\n\n/**\n * Extract an attribute from a node.\n *\n * @param {Node} node\n * @param {String} attr\n */\n\nexports.attr = function (node, attr) {\n  attr = config.prefix + attr\n  var val = node.getAttribute(attr)\n  if (val !== null) {\n    node.removeAttribute(attr)\n  }\n  return val\n}\n\n/**\n * Insert el before target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nexports.before = function (el, target) {\n  target.parentNode.insertBefore(el, target)\n}\n\n/**\n * Insert el after target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nexports.after = function (el, target) {\n  if (target.nextSibling) {\n    exports.before(el, target.nextSibling)\n  } else {\n    target.parentNode.appendChild(el)\n  }\n}\n\n/**\n * Remove el from DOM\n *\n * @param {Element} el\n */\n\nexports.remove = function (el) {\n  el.parentNode.removeChild(el)\n}\n\n/**\n * Prepend el to target\n *\n * @param {Element} el\n * @param {Element} target\n */\n\nexports.prepend = function (el, target) {\n  if (target.firstChild) {\n    exports.before(el, target.firstChild)\n  } else {\n    target.appendChild(el)\n  }\n}\n\n/**\n * Replace target with el\n *\n * @param {Element} target\n * @param {Element} el\n */\n\nexports.replace = function (target, el) {\n  var parent = target.parentNode\n  if (parent) {\n    parent.replaceChild(el, target)\n  }\n}\n\n/**\n * Add event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n */\n\nexports.on = function (el, event, cb) {\n  el.addEventListener(event, cb)\n}\n\n/**\n * Remove event listener shorthand.\n *\n * @param {Element} el\n * @param {String} event\n * @param {Function} cb\n */\n\nexports.off = function (el, event, cb) {\n  el.removeEventListener(event, cb)\n}\n\n/**\n * Add class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {Strong} cls\n */\n\nexports.addClass = function (el, cls) {\n  if (el.classList) {\n    el.classList.add(cls)\n  } else {\n    var cur = ' ' + (el.getAttribute('class') || '') + ' '\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim())\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for IE & SVG\n *\n * @param {Element} el\n * @param {Strong} cls\n */\n\nexports.removeClass = function (el, cls) {\n  if (el.classList) {\n    el.classList.remove(cls)\n  } else {\n    var cur = ' ' + (el.getAttribute('class') || '') + ' '\n    var tar = ' ' + cls + ' '\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ')\n    }\n    el.setAttribute('class', cur.trim())\n  }\n}\n\n/**\n * Extract raw content inside an element into a temporary\n * container div\n *\n * @param {Element} el\n * @param {Boolean} asFragment\n * @return {Element}\n */\n\nexports.extractContent = function (el, asFragment) {\n  var child\n  var rawContent\n  /* istanbul ignore if */\n  if (\n    el.tagName === 'TEMPLATE' &&\n    el.content instanceof DocumentFragment\n  ) {\n    el = el.content\n  }\n  if (el.hasChildNodes()) {\n    rawContent = asFragment\n      ? document.createDocumentFragment()\n      : document.createElement('div')\n    /* jshint boss:true */\n    while (child = el.firstChild) {\n      rawContent.appendChild(child)\n    }\n  }\n  return rawContent\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util/dom.js\n ** module id = 9\n ** module chunks = 0\n **/","var config = require('../config')\n\n/**\n * Enable debug utilities. The enableDebug() function and\n * all _.log() & _.warn() calls will be dropped in the\n * minified production build.\n */\n\nenableDebug()\n\nfunction enableDebug () {\n\n  var hasConsole = typeof console !== 'undefined'\n  \n  /**\n   * Log a message.\n   *\n   * @param {String} msg\n   */\n\n  exports.log = function (msg) {\n    if (hasConsole && config.debug) {\n      console.log('[Vue info]: ' + msg)\n    }\n  }\n\n  /**\n   * We've got a problem here.\n   *\n   * @param {String} msg\n   */\n\n  exports.warn = function (msg) {\n    if (hasConsole && (!config.silent || config.debug)) {\n      console.warn('[Vue warn]: ' + msg)\n      /* istanbul ignore if */\n      if (config.debug) {\n        /* jshint debug: true */\n        debugger\n      }\n    }\n  }\n\n  /**\n   * Assert asset exists\n   */\n\n  exports.assertAsset = function (val, type, id) {\n    /* istanbul ignore if */\n    if (type === 'directive') {\n      if (id === 'component') {\n        exports.warn(\n          'v-component has been deprecated in 0.12. ' +\n          'Use custom element syntax instead.'\n        )\n        return\n      }\n      if (id === 'with') {\n        exports.warn(\n          'v-with has been deprecated in 0.12. ' +\n          'Use props instead.'\n        )\n        return\n      }\n    }\n    if (!val) {\n      exports.warn('Failed to resolve ' + type + ': ' + id)\n    }\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util/debug.js\n ** module id = 10\n ** module chunks = 0\n **/","var _ = require('./util')\nvar config = require('./config')\nvar Watcher = require('./watcher')\nvar textParser = require('./parsers/text')\nvar expParser = require('./parsers/expression')\n\n/**\n * A directive links a DOM element with a piece of data,\n * which is the result of evaluating an expression.\n * It registers a watcher with the expression and calls\n * the DOM update function when a change is triggered.\n *\n * @param {String} name\n * @param {Node} el\n * @param {Vue} vm\n * @param {Object} descriptor\n *                 - {String} expression\n *                 - {String} [arg]\n *                 - {Array<Object>} [filters]\n * @param {Object} def - directive definition object\n * @param {Vue|undefined} host - transclusion host target\n * @constructor\n */\n\nfunction Directive (name, el, vm, descriptor, def, host) {\n  // public\n  this.name = name\n  this.el = el\n  this.vm = vm\n  // copy descriptor props\n  this.raw = descriptor.raw\n  this.expression = descriptor.expression\n  this.arg = descriptor.arg\n  this.filters = _.resolveFilters(vm, descriptor.filters)\n  // private\n  this._host = host\n  this._locked = false\n  this._bound = false\n  // init\n  this._bind(def)\n}\n\nvar p = Directive.prototype\n\n/**\n * Initialize the directive, mixin definition properties,\n * setup the watcher, call definition bind() and update()\n * if present.\n *\n * @param {Object} def\n */\n\np._bind = function (def) {\n  if (this.name !== 'cloak' && this.el && this.el.removeAttribute) {\n    this.el.removeAttribute(config.prefix + this.name)\n  }\n  if (typeof def === 'function') {\n    this.update = def\n  } else {\n    _.extend(this, def)\n  }\n  this._watcherExp = this.expression\n  this._checkDynamicLiteral()\n  if (this.bind) {\n    this.bind()\n  }\n  if (this._watcherExp &&\n      (this.update || this.twoWay) &&\n      (!this.isLiteral || this._isDynamicLiteral) &&\n      !this._checkStatement()) {\n    // wrapped updater for context\n    var dir = this\n    var update = this._update = this.update\n      ? function (val, oldVal) {\n          if (!dir._locked) {\n            dir.update(val, oldVal)\n          }\n        }\n      : function () {} // noop if no update is provided\n    // use raw expression as identifier because filters\n    // make them different watchers\n    var watcher = this.vm._watchers[this.raw]\n    // v-repeat always creates a new watcher because it has\n    // a special filter that's bound to its directive\n    // instance.\n    if (!watcher || this.name === 'repeat') {\n      watcher = this.vm._watchers[this.raw] = new Watcher(\n        this.vm,\n        this._watcherExp,\n        update, // callback\n        {\n          filters: this.filters,\n          twoWay: this.twoWay,\n          deep: this.deep\n        }\n      )\n    } else {\n      watcher.addCb(update)\n    }\n    this._watcher = watcher\n    if (this._initValue != null) {\n      watcher.set(this._initValue)\n    } else if (this.update) {\n      this.update(watcher.value)\n    }\n  }\n  this._bound = true\n}\n\n/**\n * check if this is a dynamic literal binding.\n *\n * e.g. v-component=\"{{currentView}}\"\n */\n\np._checkDynamicLiteral = function () {\n  var expression = this.expression\n  if (expression && this.isLiteral) {\n    var tokens = textParser.parse(expression)\n    if (tokens) {\n      var exp = textParser.tokensToExp(tokens)\n      this.expression = this.vm.$get(exp)\n      this._watcherExp = exp\n      this._isDynamicLiteral = true\n    }\n  }\n}\n\n/**\n * Check if the directive is a function caller\n * and if the expression is a callable one. If both true,\n * we wrap up the expression and use it as the event\n * handler.\n *\n * e.g. v-on=\"click: a++\"\n *\n * @return {Boolean}\n */\n\np._checkStatement = function () {\n  var expression = this.expression\n  if (\n    expression && this.acceptStatement &&\n    !expParser.pathTestRE.test(expression)\n  ) {\n    var fn = expParser.parse(expression).get\n    var vm = this.vm\n    var handler = function () {\n      fn.call(vm, vm)\n    }\n    if (this.filters) {\n      handler = _.applyFilters(\n        handler,\n        this.filters.read,\n        vm\n      )\n    }\n    this.update(handler)\n    return true\n  }\n}\n\n/**\n * Check for an attribute directive param, e.g. lazy\n *\n * @param {String} name\n * @return {String}\n */\n\np._checkParam = function (name) {\n  var param = this.el.getAttribute(name)\n  if (param !== null) {\n    this.el.removeAttribute(name)\n  }\n  return param\n}\n\n/**\n * Teardown the watcher and call unbind.\n */\n\np._teardown = function () {\n  if (this._bound) {\n    if (this.unbind) {\n      this.unbind()\n    }\n    var watcher = this._watcher\n    if (watcher && watcher.active) {\n      watcher.removeCb(this._update)\n      if (!watcher.active) {\n        this.vm._watchers[this.raw] = null\n      }\n    }\n    this._bound = false\n    this.vm = this.el = this._watcher = null\n  }\n}\n\n/**\n * Set the corresponding value with the setter.\n * This should only be used in two-way directives\n * e.g. v-model.\n *\n * @param {*} value\n * @param {Boolean} lock - prevent wrtie triggering update.\n * @public\n */\n\np.set = function (value, lock) {\n  if (this.twoWay) {\n    if (lock) {\n      this._locked = true\n    }\n    this._watcher.set(value)\n    if (lock) {\n      var self = this\n      _.nextTick(function () {\n        self._locked = false\n      })\n    }\n  }\n}\n\nmodule.exports = Directive\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directive.js\n ** module id = 12\n ** module chunks = 0\n **/","var _ = require('./util')\nvar config = require('./config')\nvar Observer = require('./observer')\nvar expParser = require('./parsers/expression')\nvar batcher = require('./batcher')\nvar uid = 0\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n *\n * @param {Vue} vm\n * @param {String} expression\n * @param {Function} cb\n * @param {Object} options\n *                 - {Array} filters\n *                 - {Boolean} twoWay\n *                 - {Boolean} deep\n *                 - {Boolean} user\n *                 - {Function} [preProcess]\n * @constructor\n */\n\nfunction Watcher (vm, expression, cb, options) {\n  this.vm = vm\n  vm._watchers.push(this)\n  this.expression = expression\n  this.cb = cb\n  this.id = ++uid // uid for batching\n  this.active = true\n  options = options || {}\n  this.deep = !!options.deep\n  this.user = !!options.user\n  this.twoWay = !!options.twoWay\n  this.filters = options.filters\n  this.preProcess = options.preProcess\n  this.deps = []\n  this.newDeps = []\n  // parse expression for getter/setter\n  var res = expParser.parse(expression, options.twoWay)\n  this.getter = res.get\n  this.setter = res.set\n  this.value = this.get()\n}\n\nvar p = Watcher.prototype\n\n/**\n * Add a dependency to this directive.\n *\n * @param {Dep} dep\n */\n\np.addDep = function (dep) {\n  var newDeps = this.newDeps\n  var old = this.deps\n  if (_.indexOf(newDeps, dep) < 0) {\n    newDeps.push(dep)\n    var i = _.indexOf(old, dep)\n    if (i < 0) {\n      dep.addSub(this)\n    } else {\n      old[i] = null\n    }\n  }\n}\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\n\np.get = function () {\n  this.beforeGet()\n  var vm = this.vm\n  var value\n  try {\n    value = this.getter.call(vm, vm)\n  } catch (e) {\n    if (config.warnExpressionErrors) {\n      _.warn(\n        'Error when evaluating expression \"' +\n        this.expression + '\":\\n   ' + e\n      )\n    }\n  }\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value)\n  }\n  if (this.preProcess) {\n    value = this.preProcess(value)\n  }\n  if (this.filters) {\n    value = vm._applyFilters(value, null, this.filters, false)\n  }\n  this.afterGet()\n  return value\n}\n\n/**\n * Set the corresponding value with the setter.\n *\n * @param {*} value\n */\n\np.set = function (value) {\n  var vm = this.vm\n  if (this.filters) {\n    value = vm._applyFilters(\n      value, this.value, this.filters, true)\n  }\n  try {\n    this.setter.call(vm, vm, value)\n  } catch (e) {\n    if (config.warnExpressionErrors) {\n      _.warn(\n        'Error when evaluating setter \"' +\n        this.expression + '\":\\n   ' + e\n      )\n    }\n  }\n}\n\n/**\n * Prepare for dependency collection.\n */\n\np.beforeGet = function () {\n  Observer.target = this\n}\n\n/**\n * Clean up for dependency collection.\n */\n\np.afterGet = function () {\n  Observer.target = null\n  var i = this.deps.length\n  while (i--) {\n    var dep = this.deps[i]\n    if (dep) {\n      dep.removeSub(this)\n    }\n  }\n  this.deps = this.newDeps\n  this.newDeps = []\n}\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\n\np.update = function () {\n  if (!config.async || config.debug) {\n    this.run()\n  } else {\n    batcher.push(this)\n  }\n}\n\n/**\n * Batcher job interface.\n * Will be called by the batcher.\n */\n\np.run = function () {\n  if (this.active) {\n    var value = this.get()\n    if (\n      value !== this.value ||\n      Array.isArray(value) ||\n      this.deep\n    ) {\n      var oldValue = this.value\n      this.value = value\n      this.cb(value, oldValue)\n    }\n  }\n}\n\n/**\n * Remove self from all dependencies' subcriber list.\n */\n\np.teardown = function () {\n  if (this.active) {\n    // remove self from vm's watcher list\n    // we can skip this if the vm if being destroyed\n    // which can improve teardown performance.\n    if (!this.vm._isBeingDestroyed) {\n      this.vm._watchers.$remove(this)\n    }\n    var i = this.deps.length\n    while (i--) {\n      this.deps[i].removeSub(this)\n    }\n    this.active = false\n    this.vm = this.cb = this.value = null\n  }\n}\n\n\n/**\n * Recrusively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n *\n * @param {Object} obj\n */\n\nfunction traverse (obj) {\n  var key, val, i\n  for (key in obj) {\n    val = obj[key]\n    if (_.isArray(val)) {\n      i = val.length\n      while (i--) traverse(val[i])\n    } else if (_.isObject(val)) {\n      traverse(val)\n    }\n  }\n}\n\nmodule.exports = Watcher\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/watcher.js\n ** module id = 13\n ** module chunks = 0\n **/","var _ = require('../util')\nvar config = require('../config')\nvar Dep = require('./dep')\nvar arrayMethods = require('./array')\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods)\nrequire('./object')\n\nvar uid = 0\n\n/**\n * Type enums\n */\n\nvar ARRAY  = 0\nvar OBJECT = 1\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction protoAugment (target, src) {\n  target.__proto__ = src\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\n * @param {Object|Array} target\n * @param {Object} proto\n */\n\nfunction copyAugment (target, src, keys) {\n  var i = keys.length\n  var key\n  while (i--) {\n    key = keys[i]\n    _.define(target, key, src[key])\n  }\n}\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n *\n * @param {Array|Object} value\n * @param {Number} type\n * @constructor\n */\n\nfunction Observer (value, type) {\n  this.id = ++uid\n  this.value = value\n  this.active = true\n  this.deps = []\n  _.define(value, '__ob__', this)\n  if (type === ARRAY) {\n    var augment = config.proto && _.hasProto\n      ? protoAugment\n      : copyAugment\n    augment(value, arrayMethods, arrayKeys)\n    this.observeArray(value)\n  } else if (type === OBJECT) {\n    this.walk(value)\n  }\n}\n\nObserver.target = null\n\nvar p = Observer.prototype\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n *\n * @param {*} value\n * @return {Observer|undefined}\n * @static\n */\n\nObserver.create = function (value) {\n  if (\n    value &&\n    value.hasOwnProperty('__ob__') &&\n    value.__ob__ instanceof Observer\n  ) {\n    return value.__ob__\n  } else if (_.isArray(value)) {\n    return new Observer(value, ARRAY)\n  } else if (\n    _.isPlainObject(value) &&\n    !value._isVue // avoid Vue instance\n  ) {\n    return new Observer(value, OBJECT)\n  }\n}\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object. Properties prefixed with `$` or `_`\n * and accessor properties are ignored.\n *\n * @param {Object} obj\n */\n\np.walk = function (obj) {\n  var keys = Object.keys(obj)\n  var i = keys.length\n  var key, prefix\n  while (i--) {\n    key = keys[i]\n    prefix = key.charCodeAt(0)\n    if (prefix !== 0x24 && prefix !== 0x5F) { // skip $ or _\n      this.convert(key, obj[key])\n    }\n  }\n}\n\n/**\n * Try to carete an observer for a child value,\n * and if value is array, link dep to the array.\n *\n * @param {*} val\n * @return {Dep|undefined}\n */\n\np.observe = function (val) {\n  return Observer.create(val)\n}\n\n/**\n * Observe a list of Array items.\n *\n * @param {Array} items\n */\n\np.observeArray = function (items) {\n  var i = items.length\n  while (i--) {\n    this.observe(items[i])\n  }\n}\n\n/**\n * Convert a property into getter/setter so we can emit\n * the events when the property is accessed/changed.\n *\n * @param {String} key\n * @param {*} val\n */\n\np.convert = function (key, val) {\n  var ob = this\n  var childOb = ob.observe(val)\n  var dep = new Dep()\n  if (childOb) {\n    childOb.deps.push(dep)\n  }\n  Object.defineProperty(ob.value, key, {\n    enumerable: true,\n    configurable: true,\n    get: function () {\n      // Observer.target is a watcher whose getter is\n      // currently being evaluated.\n      if (ob.active && Observer.target) {\n        Observer.target.addDep(dep)\n      }\n      return val\n    },\n    set: function (newVal) {\n      if (newVal === val) return\n      // remove dep from old value\n      var oldChildOb = val && val.__ob__\n      if (oldChildOb) {\n        oldChildOb.deps.$remove(dep)\n      }\n      val = newVal\n      // add dep to new value\n      var newChildOb = ob.observe(newVal)\n      if (newChildOb) {\n        newChildOb.deps.push(dep)\n      }\n      dep.notify()\n    }\n  })\n}\n\n/**\n * Notify change on all self deps on an observer.\n * This is called when a mutable value mutates. e.g.\n * when an Array's mutating methods are called, or an\n * Object's $add/$delete are called.\n */\n\np.notify = function () {\n  var deps = this.deps\n  for (var i = 0, l = deps.length; i < l; i++) {\n    deps[i].notify()\n  }\n}\n\n/**\n * Add an owner vm, so that when $add/$delete mutations\n * happen we can notify owner vms to proxy the keys and\n * digest the watchers. This is only called when the object\n * is observed as an instance's root $data.\n *\n * @param {Vue} vm\n */\n\np.addVm = function (vm) {\n  (this.vms = this.vms || []).push(vm)\n}\n\n/**\n * Remove an owner vm. This is called when the object is\n * swapped out as an instance's $data object.\n *\n * @param {Vue} vm\n */\n\np.removeVm = function (vm) {\n  this.vms.$remove(vm)\n}\n\nmodule.exports = Observer\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/observer/index.js\n ** module id = 14\n ** module chunks = 0\n **/","var _ = require('../util')\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n *\n * @constructor\n */\n\nfunction Dep () {\n  this.subs = []\n}\n\nvar p = Dep.prototype\n\n/**\n * Add a directive subscriber.\n *\n * @param {Directive} sub\n */\n\np.addSub = function (sub) {\n  this.subs.push(sub)\n}\n\n/**\n * Remove a directive subscriber.\n *\n * @param {Directive} sub\n */\n\np.removeSub = function (sub) {\n  this.subs.$remove(sub)\n}\n\n/**\n * Notify all subscribers of a new value.\n */\n\np.notify = function () {\n  // stablize the subscriber list first\n  var subs = _.toArray(this.subs)\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update()\n  }\n}\n\nmodule.exports = Dep\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/observer/dep.js\n ** module id = 15\n ** module chunks = 0\n **/","var _ = require('../util')\nvar arrayProto = Array.prototype\nvar arrayMethods = Object.create(arrayProto)\n\n/**\n * Intercept mutating methods and emit events\n */\n\n;[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method]\n  _.define(arrayMethods, method, function mutator () {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length\n    var args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i]\n    }\n    var result = original.apply(this, args)\n    var ob = this.__ob__\n    var inserted\n    switch (method) {\n      case 'push':\n        inserted = args\n        break\n      case 'unshift':\n        inserted = args\n        break\n      case 'splice':\n        inserted = args.slice(2)\n        break\n    }\n    if (inserted) ob.observeArray(inserted)\n    // notify change\n    ob.notify()\n    return result\n  })\n})\n\n/**\n * Swap the element at the given index with a new value\n * and emits corresponding event.\n *\n * @param {Number} index\n * @param {*} val\n * @return {*} - replaced element\n */\n\n_.define(\n  arrayProto,\n  '$set',\n  function $set (index, val) {\n    if (index >= this.length) {\n      this.length = index + 1\n    }\n    return this.splice(index, 1, val)[0]\n  }\n)\n\n/**\n * Convenience method to remove the element at given index.\n *\n * @param {Number} index\n * @param {*} val\n */\n\n_.define(\n  arrayProto,\n  '$remove',\n  function $remove (index) {\n    if (typeof index !== 'number') {\n      index = this.indexOf(index)\n    }\n    if (index > -1) {\n      return this.splice(index, 1)[0]\n    }\n  }\n)\n\nmodule.exports = arrayMethods\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/observer/array.js\n ** module id = 16\n ** module chunks = 0\n **/","var _ = require('../util')\nvar objProto = Object.prototype\n\n/**\n * Add a new property to an observed object\n * and emits corresponding event\n *\n * @param {String} key\n * @param {*} val\n * @public\n */\n\n_.define(\n  objProto,\n  '$add',\n  function $add (key, val) {\n    if (this.hasOwnProperty(key)) return\n    var ob = this.__ob__\n    if (!ob || _.isReserved(key)) {\n      this[key] = val\n      return\n    }\n    ob.convert(key, val)\n    ob.notify()\n    if (ob.vms) {\n      var i = ob.vms.length\n      while (i--) {\n        var vm = ob.vms[i]\n        vm._proxy(key)\n        vm._digest()\n      }\n    }\n  }\n)\n\n/**\n * Set a property on an observed object, calling add to\n * ensure the property is observed.\n *\n * @param {String} key\n * @param {*} val\n * @public\n */\n\n_.define(\n  objProto,\n  '$set',\n  function $set (key, val) {\n    this.$add(key, val)\n    this[key] = val\n  }\n)\n\n/**\n * Deletes a property from an observed object\n * and emits corresponding event\n *\n * @param {String} key\n * @public\n */\n\n_.define(\n  objProto,\n  '$delete',\n  function $delete (key) {\n    if (!this.hasOwnProperty(key)) return\n    delete this[key]\n    var ob = this.__ob__\n    if (!ob || _.isReserved(key)) {\n      return\n    }\n    ob.notify()\n    if (ob.vms) {\n      var i = ob.vms.length\n      while (i--) {\n        var vm = ob.vms[i]\n        vm._unproxy(key)\n        vm._digest()\n      }\n    }\n  }\n)\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/observer/object.js\n ** module id = 17\n ** module chunks = 0\n **/","var _ = require('../util')\nvar Path = require('./path')\nvar Cache = require('../cache')\nvar expressionCache = new Cache(1000)\n\nvar allowedKeywords =\n  'Math,Date,this,true,false,null,undefined,Infinity,NaN,' +\n  'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' +\n  'encodeURIComponent,parseInt,parseFloat'\nvar allowedKeywordsRE =\n  new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)')\n\n// keywords that don't make sense inside expressions\nvar improperKeywords =\n  'break,case,class,catch,const,continue,debugger,default,' +\n  'delete,do,else,export,extends,finally,for,function,if,' +\n  'import,in,instanceof,let,return,super,switch,throw,try,' +\n  'var,while,with,yield,enum,await,implements,package,' +\n  'proctected,static,interface,private,public'\nvar improperKeywordsRE =\n  new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)')\n\nvar wsRE = /\\s/g\nvar newlineRE = /\\n/g\nvar saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('[^']*'|\"[^\"]*\")|new |typeof |void /g\nvar restoreRE = /\"(\\d+)\"/g\nvar pathTestRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/\nvar pathReplaceRE = /[^\\w$\\.]([A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\])*)/g\nvar booleanLiteralRE = /^(true|false)$/\n\n/**\n * Save / Rewrite / Restore\n *\n * When rewriting paths found in an expression, it is\n * possible for the same letter sequences to be found in\n * strings and Object literal property keys. Therefore we\n * remove and store these parts in a temporary array, and\n * restore them after the path rewrite.\n */\n\nvar saved = []\n\n/**\n * Save replacer\n *\n * The save regex can match two possible cases:\n * 1. An opening object literal\n * 2. A string\n * If matched as a plain string, we need to escape its\n * newlines, since the string needs to be preserved when\n * generating the function body.\n *\n * @param {String} str\n * @param {String} isString - str if matched as a string\n * @return {String} - placeholder with index\n */\n\nfunction save (str, isString) {\n  var i = saved.length\n  saved[i] = isString\n    ? str.replace(newlineRE, '\\\\n')\n    : str\n  return '\"' + i + '\"'\n}\n\n/**\n * Path rewrite replacer\n *\n * @param {String} raw\n * @return {String}\n */\n\nfunction rewrite (raw) {\n  var c = raw.charAt(0)\n  var path = raw.slice(1)\n  if (allowedKeywordsRE.test(path)) {\n    return raw\n  } else {\n    path = path.indexOf('\"') > -1\n      ? path.replace(restoreRE, restore)\n      : path\n    return c + 'scope.' + path\n  }\n}\n\n/**\n * Restore replacer\n *\n * @param {String} str\n * @param {String} i - matched save index\n * @return {String}\n */\n\nfunction restore (str, i) {\n  return saved[i]\n}\n\n/**\n * Rewrite an expression, prefixing all path accessors with\n * `scope.` and generate getter/setter functions.\n *\n * @param {String} exp\n * @param {Boolean} needSet\n * @return {Function}\n */\n\nfunction compileExpFns (exp, needSet) {\n  if (improperKeywordsRE.test(exp)) {\n    _.warn(\n      'Avoid using reserved keywords in expression: '\n      + exp\n    )\n  }\n  // reset state\n  saved.length = 0\n  // save strings and object literal keys\n  var body = exp\n    .replace(saveRE, save)\n    .replace(wsRE, '')\n  // rewrite all paths\n  // pad 1 space here becaue the regex matches 1 extra char\n  body = (' ' + body)\n    .replace(pathReplaceRE, rewrite)\n    .replace(restoreRE, restore)\n  var getter = makeGetter(body)\n  if (getter) {\n    return {\n      get: getter,\n      body: body,\n      set: needSet\n        ? makeSetter(body)\n        : null\n    }\n  }\n}\n\n/**\n * Compile getter setters for a simple path.\n *\n * @param {String} exp\n * @return {Function}\n */\n\nfunction compilePathFns (exp) {\n  var getter, path\n  if (exp.indexOf('[') < 0) {\n    // really simple path\n    path = exp.split('.')\n    path.raw = exp\n    getter = Path.compileGetter(path)\n  } else {\n    // do the real parsing\n    path = Path.parse(exp)\n    getter = path.get\n  }\n  return {\n    get: getter,\n    // always generate setter for simple paths\n    set: function (obj, val) {\n      Path.set(obj, path, val)\n    }\n  }\n}\n\n/**\n * Build a getter function. Requires eval.\n *\n * We isolate the try/catch so it doesn't affect the\n * optimization of the parse function when it is not called.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeGetter (body) {\n  try {\n    return new Function('scope', 'return ' + body + ';')\n  } catch (e) {\n    _.warn(\n      'Invalid expression. ' +\n      'Generated function body: ' + body\n    )\n  }\n}\n\n/**\n * Build a setter function.\n *\n * This is only needed in rare situations like \"a[b]\" where\n * a settable path requires dynamic evaluation.\n *\n * This setter function may throw error when called if the\n * expression body is not a valid left-hand expression in\n * assignment.\n *\n * @param {String} body\n * @return {Function|undefined}\n */\n\nfunction makeSetter (body) {\n  try {\n    return new Function('scope', 'value', body + '=value;')\n  } catch (e) {\n    _.warn('Invalid setter function body: ' + body)\n  }\n}\n\n/**\n * Check for setter existence on a cache hit.\n *\n * @param {Function} hit\n */\n\nfunction checkSetter (hit) {\n  if (!hit.set) {\n    hit.set = makeSetter(hit.body)\n  }\n}\n\n/**\n * Parse an expression into re-written getter/setters.\n *\n * @param {String} exp\n * @param {Boolean} needSet\n * @return {Function}\n */\n\nexports.parse = function (exp, needSet) {\n  exp = exp.trim()\n  // try cache\n  var hit = expressionCache.get(exp)\n  if (hit) {\n    if (needSet) {\n      checkSetter(hit)\n    }\n    return hit\n  }\n  // we do a simple path check to optimize for them.\n  // the check fails valid paths with unusal whitespaces,\n  // but that's too rare and we don't care.\n  // also skip boolean literals and paths that start with\n  // global \"Math\"\n  var res = exports.isSimplePath(exp)\n    ? compilePathFns(exp)\n    : compileExpFns(exp, needSet)\n  expressionCache.put(exp, res)\n  return res\n}\n\n/**\n * Check if an expression is a simple path.\n *\n * @param {String} exp\n * @return {Boolean}\n */\n\nexports.isSimplePath = function (exp) {\n  return pathTestRE.test(exp) &&\n    // don't treat true/false as paths\n    !booleanLiteralRE.test(exp) &&\n    // Math constants e.g. Math.PI, Math.E etc.\n    exp.slice(0, 5) !== 'Math.'\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/parsers/expression.js\n ** module id = 18\n ** module chunks = 0\n **/","var _ = require('../util')\nvar Cache = require('../cache')\nvar pathCache = new Cache(1000)\nvar identRE = exports.identRE = /^[$_a-zA-Z]+[\\w$]*$/\n\n/**\n * Path-parsing algorithm scooped from Polymer/observe-js\n */\n\nvar pathStateMachine = {\n  'beforePath': {\n    'ws': ['beforePath'],\n    'ident': ['inIdent', 'append'],\n    '[': ['beforeElement'],\n    'eof': ['afterPath']\n  },\n\n  'inPath': {\n    'ws': ['inPath'],\n    '.': ['beforeIdent'],\n    '[': ['beforeElement'],\n    'eof': ['afterPath']\n  },\n\n  'beforeIdent': {\n    'ws': ['beforeIdent'],\n    'ident': ['inIdent', 'append']\n  },\n\n  'inIdent': {\n    'ident': ['inIdent', 'append'],\n    '0': ['inIdent', 'append'],\n    'number': ['inIdent', 'append'],\n    'ws': ['inPath', 'push'],\n    '.': ['beforeIdent', 'push'],\n    '[': ['beforeElement', 'push'],\n    'eof': ['afterPath', 'push'],\n    ']': ['inPath', 'push']\n  },\n\n  'beforeElement': {\n    'ws': ['beforeElement'],\n    '0': ['afterZero', 'append'],\n    'number': ['inIndex', 'append'],\n    \"'\": ['inSingleQuote', 'append', ''],\n    '\"': ['inDoubleQuote', 'append', ''],\n    \"ident\": ['inIdent', 'append', '*']\n  },\n\n  'afterZero': {\n    'ws': ['afterElement', 'push'],\n    ']': ['inPath', 'push']\n  },\n\n  'inIndex': {\n    '0': ['inIndex', 'append'],\n    'number': ['inIndex', 'append'],\n    'ws': ['afterElement'],\n    ']': ['inPath', 'push']\n  },\n\n  'inSingleQuote': {\n    \"'\": ['afterElement'],\n    'eof': 'error',\n    'else': ['inSingleQuote', 'append']\n  },\n\n  'inDoubleQuote': {\n    '\"': ['afterElement'],\n    'eof': 'error',\n    'else': ['inDoubleQuote', 'append']\n  },\n\n  'afterElement': {\n    'ws': ['afterElement'],\n    ']': ['inPath', 'push']\n  }\n}\n\nfunction noop () {}\n\n/**\n * Determine the type of a character in a keypath.\n *\n * @param {Char} char\n * @return {String} type\n */\n\nfunction getPathCharType (char) {\n  if (char === undefined) {\n    return 'eof'\n  }\n\n  var code = char.charCodeAt(0)\n\n  switch(code) {\n    case 0x5B: // [\n    case 0x5D: // ]\n    case 0x2E: // .\n    case 0x22: // \"\n    case 0x27: // '\n    case 0x30: // 0\n      return char\n\n    case 0x5F: // _\n    case 0x24: // $\n      return 'ident'\n\n    case 0x20: // Space\n    case 0x09: // Tab\n    case 0x0A: // Newline\n    case 0x0D: // Return\n    case 0xA0:  // No-break space\n    case 0xFEFF:  // Byte Order Mark\n    case 0x2028:  // Line Separator\n    case 0x2029:  // Paragraph Separator\n      return 'ws'\n  }\n\n  // a-z, A-Z\n  if ((0x61 <= code && code <= 0x7A) ||\n      (0x41 <= code && code <= 0x5A)) {\n    return 'ident'\n  }\n\n  // 1-9\n  if (0x31 <= code && code <= 0x39) {\n    return 'number'\n  }\n\n  return 'else'\n}\n\n/**\n * Parse a string path into an array of segments\n * Todo implement cache\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nfunction parsePath (path) {\n  var keys = []\n  var index = -1\n  var mode = 'beforePath'\n  var c, newChar, key, type, transition, action, typeMap\n\n  var actions = {\n    push: function() {\n      if (key === undefined) {\n        return\n      }\n      keys.push(key)\n      key = undefined\n    },\n    append: function() {\n      if (key === undefined) {\n        key = newChar\n      } else {\n        key += newChar\n      }\n    }\n  }\n\n  function maybeUnescapeQuote () {\n    var nextChar = path[index + 1]\n    if ((mode === 'inSingleQuote' && nextChar === \"'\") ||\n        (mode === 'inDoubleQuote' && nextChar === '\"')) {\n      index++\n      newChar = nextChar\n      actions.append()\n      return true\n    }\n  }\n\n  while (mode) {\n    index++\n    c = path[index]\n\n    if (c === '\\\\' && maybeUnescapeQuote()) {\n      continue\n    }\n\n    type = getPathCharType(c)\n    typeMap = pathStateMachine[mode]\n    transition = typeMap[type] || typeMap['else'] || 'error'\n\n    if (transition === 'error') {\n      return // parse error\n    }\n\n    mode = transition[0]\n    action = actions[transition[1]] || noop\n    newChar = transition[2]\n    newChar = newChar === undefined\n      ? c\n      : newChar === '*'\n        ? newChar + c\n        : newChar\n    action()\n\n    if (mode === 'afterPath') {\n      keys.raw = path\n      return keys\n    }\n  }\n}\n\n/**\n * Format a accessor segment based on its type.\n *\n * @param {String} key\n * @return {Boolean}\n */\n\nfunction formatAccessor (key) {\n  if (identRE.test(key)) { // identifier\n    return '.' + key\n  } else if (+key === key >>> 0) { // bracket index\n    return '[' + key + ']'\n  } else if (key.charAt(0) === '*') {\n    return '[o' + formatAccessor(key.slice(1)) + ']'\n  } else { // bracket string\n    return '[\"' + key.replace(/\"/g, '\\\\\"') + '\"]'\n  }\n}\n\n/**\n * Compiles a getter function with a fixed path.\n * The fixed path getter supresses errors.\n *\n * @param {Array} path\n * @return {Function}\n */\n\nexports.compileGetter = function (path) {\n  var body = 'return o' + path.map(formatAccessor).join('')\n  return new Function('o', 'try {' + body + '} catch (e) {}')\n}\n\n/**\n * External parse that check for a cache hit first\n *\n * @param {String} path\n * @return {Array|undefined}\n */\n\nexports.parse = function (path) {\n  var hit = pathCache.get(path)\n  if (!hit) {\n    hit = parsePath(path)\n    if (hit) {\n      hit.get = exports.compileGetter(hit)\n      pathCache.put(path, hit)\n    }\n  }\n  return hit\n}\n\n/**\n * Get from an object from a path string\n *\n * @param {Object} obj\n * @param {String} path\n */\n\nexports.get = function (obj, path) {\n  path = exports.parse(path)\n  if (path) {\n    return path.get(obj)\n  }\n}\n\n/**\n * Set on an object from a path\n *\n * @param {Object} obj\n * @param {String | Array} path\n * @param {*} val\n */\n\nexports.set = function (obj, path, val) {\n  var original = obj\n  if (typeof path === 'string') {\n    path = exports.parse(path)\n  }\n  if (!path || !_.isObject(obj)) {\n    return false\n  }\n  var last, key\n  for (var i = 0, l = path.length; i < l; i++) {\n    last = obj\n    key = path[i]\n    if (key.charAt(0) === '*') {\n      key = original[key.slice(1)]\n    }\n    if (i < l - 1) {\n      obj = obj[key]\n      if (!_.isObject(obj)) {\n        obj = {}\n        last.$add(key, obj)\n        warnNonExistent(path)\n      }\n    } else {\n      if (key in obj) {\n        obj[key] = val\n      } else {\n        obj.$add(key, val)\n        warnNonExistent(path)\n      }\n    }\n  }\n  return true\n}\n\nfunction warnNonExistent (path) {\n  _.warn(\n    'You are setting a non-existent path \"' + path.raw + '\" ' +\n    'on a vm instance. Consider pre-initializing the property ' +\n    'with the \"data\" option for more reliable reactivity ' +\n    'and better performance.'\n  )\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/parsers/path.js\n ** module id = 19\n ** module chunks = 0\n **/","/**\n * A doubly linked list-based Least Recently Used (LRU)\n * cache. Will keep most recently used items while\n * discarding least recently used items when its limit is\n * reached. This is a bare-bone version of\n * Rasmus Andersson's js-lru:\n *\n *   https://github.com/rsms/js-lru\n *\n * @param {Number} limit\n * @constructor\n */\n\nfunction Cache (limit) {\n  this.size = 0\n  this.limit = limit\n  this.head = this.tail = undefined\n  this._keymap = {}\n}\n\nvar p = Cache.prototype\n\n/**\n * Put <value> into the cache associated with <key>.\n * Returns the entry which was removed to make room for\n * the new entry. Otherwise undefined is returned.\n * (i.e. if there was enough room already).\n *\n * @param {String} key\n * @param {*} value\n * @return {Entry|undefined}\n */\n\np.put = function (key, value) {\n  var entry = {\n    key:key,\n    value:value\n  }\n  this._keymap[key] = entry\n  if (this.tail) {\n    this.tail.newer = entry\n    entry.older = this.tail\n  } else {\n    this.head = entry\n  }\n  this.tail = entry\n  if (this.size === this.limit) {\n    return this.shift()\n  } else {\n    this.size++\n  }\n}\n\n/**\n * Purge the least recently used (oldest) entry from the\n * cache. Returns the removed entry or undefined if the\n * cache was empty.\n */\n\np.shift = function () {\n  var entry = this.head\n  if (entry) {\n    this.head = this.head.newer\n    this.head.older = undefined\n    entry.newer = entry.older = undefined\n    this._keymap[entry.key] = undefined\n  }\n  return entry\n}\n\n/**\n * Get and register recent use of <key>. Returns the value\n * associated with <key> or undefined if not in cache.\n *\n * @param {String} key\n * @param {Boolean} returnEntry\n * @return {Entry|*}\n */\n\np.get = function (key, returnEntry) {\n  var entry = this._keymap[key]\n  if (entry === undefined) return\n  if (entry === this.tail) {\n    return returnEntry\n      ? entry\n      : entry.value\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry.newer) {\n    if (entry === this.head) {\n      this.head = entry.newer\n    }\n    entry.newer.older = entry.older // C <-- E.\n  }\n  if (entry.older) {\n    entry.older.newer = entry.newer // C. --> E\n  }\n  entry.newer = undefined // D --x\n  entry.older = this.tail // D. --> E\n  if (this.tail) {\n    this.tail.newer = entry // E. <-- D\n  }\n  this.tail = entry\n  return returnEntry\n    ? entry\n    : entry.value\n}\n\nmodule.exports = Cache\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/cache.js\n ** module id = 20\n ** module chunks = 0\n **/","var _ = require('./util')\nvar MAX_UPDATE_COUNT = 10\n\n// we have two separate queues: one for directive updates\n// and one for user watcher registered via $watch().\n// we want to guarantee directive updates to be called\n// before user watchers so that when user watchers are\n// triggered, the DOM would have already been in updated\n// state.\nvar queue = []\nvar userQueue = []\nvar has = {}\nvar waiting = false\nvar flushing = false\n\n/**\n * Reset the batcher's state.\n */\n\nfunction reset () {\n  queue = []\n  userQueue = []\n  has = {}\n  waiting = false\n  flushing = false\n}\n\n/**\n * Flush both queues and run the jobs.\n */\n\nfunction flush () {\n  flushing = true\n  run(queue)\n  run(userQueue)\n  reset()\n}\n\n/**\n * Run the jobs in a single queue.\n *\n * @param {Array} queue\n */\n\nfunction run (queue) {\n  // do not cache length because more jobs might be pushed\n  // as we run existing jobs\n  for (var i = 0; i < queue.length; i++) {\n    queue[i].run()\n  }\n}\n\n/**\n * Push a job into the job queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n *\n * @param {Object} job\n *   properties:\n *   - {String|Number} id\n *   - {Function}      run\n */\n\nexports.push = function (job) {\n  var id = job.id\n  if (!id || !has[id] || flushing) {\n    if (!has[id]) {\n      has[id] = 1\n    } else {\n      has[id]++\n      // detect possible infinite update loops\n      if (has[id] > MAX_UPDATE_COUNT) {\n        _.warn(\n          'You may have an infinite update loop for the ' +\n          'watcher with expression: \"' + job.expression + '\".'\n        )\n        return\n      }\n    }\n    // A user watcher callback could trigger another\n    // directive update during the flushing; at that time\n    // the directive queue would already have been run, so\n    // we call that update immediately as it is pushed.\n    if (flushing && !job.user) {\n      job.run()\n      return\n    }\n    ;(job.user ? userQueue : queue).push(job)\n    if (!waiting) {\n      waiting = true\n      _.nextTick(flush)\n    }\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/batcher.js\n ** module id = 21\n ** module chunks = 0\n **/","var Cache = require('../cache')\nvar config = require('../config')\nvar dirParser = require('./directive')\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g\nvar cache, tagRE, htmlRE, firstChar, lastChar\n\n/**\n * Escape a string so it can be used in a RegExp\n * constructor.\n *\n * @param {String} str\n */\n\nfunction escapeRegex (str) {\n  return str.replace(regexEscapeRE, '\\\\$&')\n}\n\n/**\n * Compile the interpolation tag regex.\n *\n * @return {RegExp}\n */\n\nfunction compileRegex () {\n  config._delimitersChanged = false\n  var open = config.delimiters[0]\n  var close = config.delimiters[1]\n  firstChar = open.charAt(0)\n  lastChar = close.charAt(close.length - 1)\n  var firstCharRE = escapeRegex(firstChar)\n  var lastCharRE = escapeRegex(lastChar)\n  var openRE = escapeRegex(open)\n  var closeRE = escapeRegex(close)\n  tagRE = new RegExp(\n    firstCharRE + '?' + openRE +\n    '(.+?)' +\n    closeRE + lastCharRE + '?',\n    'g'\n  )\n  htmlRE = new RegExp(\n    '^' + firstCharRE + openRE +\n    '.*' +\n    closeRE + lastCharRE + '$'\n  )\n  // reset cache\n  cache = new Cache(1000)\n}\n\n/**\n * Parse a template text string into an array of tokens.\n *\n * @param {String} text\n * @return {Array<Object> | null}\n *               - {String} type\n *               - {String} value\n *               - {Boolean} [html]\n *               - {Boolean} [oneTime]\n */\n\nexports.parse = function (text) {\n  if (config._delimitersChanged) {\n    compileRegex()\n  }\n  var hit = cache.get(text)\n  if (hit) {\n    return hit\n  }\n  if (!tagRE.test(text)) {\n    return null\n  }\n  var tokens = []\n  var lastIndex = tagRE.lastIndex = 0\n  var match, index, value, first, oneTime\n  /* jshint boss:true */\n  while (match = tagRE.exec(text)) {\n    index = match.index\n    // push text token\n    if (index > lastIndex) {\n      tokens.push({\n        value: text.slice(lastIndex, index)\n      })\n    }\n    // tag token\n    first = match[1].charCodeAt(0)\n    oneTime = first === 0x2A // *\n    value = oneTime\n      ? match[1].slice(1)\n      : match[1]\n    tokens.push({\n      tag: true,\n      value: value.trim(),\n      html: htmlRE.test(match[0]),\n      oneTime: oneTime\n    })\n    lastIndex = index + match[0].length\n  }\n  if (lastIndex < text.length) {\n    tokens.push({\n      value: text.slice(lastIndex)\n    })\n  }\n  cache.put(text, tokens)\n  return tokens\n}\n\n/**\n * Format a list of tokens into an expression.\n * e.g. tokens parsed from 'a {{b}} c' can be serialized\n * into one single expression as '\"a \" + b + \" c\"'.\n *\n * @param {Array} tokens\n * @param {Vue} [vm]\n * @return {String}\n */\n\nexports.tokensToExp = function (tokens, vm) {\n  return tokens.length > 1\n    ? tokens.map(function (token) {\n        return formatToken(token, vm)\n      }).join('+')\n    : formatToken(tokens[0], vm, true)\n}\n\n/**\n * Format a single token.\n *\n * @param {Object} token\n * @param {Vue} [vm]\n * @param {Boolean} single\n * @return {String}\n */\n\nfunction formatToken (token, vm, single) {\n  return token.tag\n    ? vm && token.oneTime\n      ? '\"' + vm.$eval(token.value) + '\"'\n      : inlineFilters(token.value, single)\n    : '\"' + token.value + '\"'\n}\n\n/**\n * For an attribute with multiple interpolation tags,\n * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n * the whole thing into a single watchable expression, we\n * have to inline those filters. This function does exactly\n * that. This is a bit hacky but it avoids heavy changes\n * to directive parser and watcher mechanism.\n *\n * @param {String} exp\n * @param {Boolean} single\n * @return {String}\n */\n\nvar filterRE = /[^|]\\|[^|]/\nfunction inlineFilters (exp, single) {\n  if (!filterRE.test(exp)) {\n    return single\n      ? exp\n      : '(' + exp + ')'\n  } else {\n    var dir = dirParser.parse(exp)[0]\n    if (!dir.filters) {\n      return '(' + exp + ')'\n    } else {\n      return 'this._applyFilters(' +\n        dir.expression + // value\n        ',null,' +       // oldValue (null for read)\n        JSON.stringify(dir.filters) + // filter descriptors\n        ',false)'        // write?\n    }\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/parsers/text.js\n ** module id = 22\n ** module chunks = 0\n **/","var _ = require('../util')\nvar Cache = require('../cache')\nvar cache = new Cache(1000)\nvar argRE = /^[^\\{\\?]+$|^'[^']*'$|^\"[^\"]*\"$/\nvar filterTokenRE = /[^\\s'\"]+|'[^']+'|\"[^\"]+\"/g\nvar reservedArgRE = /^in$|^-?\\d+/\n\n/**\n * Parser state\n */\n\nvar str\nvar c, i, l\nvar inSingle\nvar inDouble\nvar curly\nvar square\nvar paren\nvar begin\nvar argIndex\nvar dirs\nvar dir\nvar lastFilterIndex\nvar arg\n\n/**\n * Push a directive object into the result Array\n */\n\nfunction pushDir () {\n  dir.raw = str.slice(begin, i).trim()\n  if (dir.expression === undefined) {\n    dir.expression = str.slice(argIndex, i).trim()\n  } else if (lastFilterIndex !== begin) {\n    pushFilter()\n  }\n  if (i === 0 || dir.expression) {\n    dirs.push(dir)\n  }\n}\n\n/**\n * Push a filter to the current directive object\n */\n\nfunction pushFilter () {\n  var exp = str.slice(lastFilterIndex, i).trim()\n  var filter\n  if (exp) {\n    filter = {}\n    var tokens = exp.match(filterTokenRE)\n    filter.name = tokens[0]\n    if (tokens.length > 1) {\n      filter.args = tokens.slice(1).map(processFilterArg)\n    }\n  }\n  if (filter) {\n    (dir.filters = dir.filters || []).push(filter)\n  }\n  lastFilterIndex = i + 1\n}\n\n/**\n * Check if an argument is dynamic and strip quotes.\n *\n * @param {String} arg\n * @return {Object}\n */\n\nfunction processFilterArg (arg) {\n  var stripped = reservedArgRE.test(arg)\n    ? arg\n    : _.stripQuotes(arg)\n  return {\n    value: stripped || arg,\n    dynamic: !stripped\n  }\n}\n\n/**\n * Parse a directive string into an Array of AST-like\n * objects representing directives.\n *\n * Example:\n *\n * \"click: a = a + 1 | uppercase\" will yield:\n * {\n *   arg: 'click',\n *   expression: 'a = a + 1',\n *   filters: [\n *     { name: 'uppercase', args: null }\n *   ]\n * }\n *\n * @param {String} str\n * @return {Array<Object>}\n */\n\nexports.parse = function (s) {\n\n  var hit = cache.get(s)\n  if (hit) {\n    return hit\n  }\n\n  // reset parser state\n  str = s\n  inSingle = inDouble = false\n  curly = square = paren = begin = argIndex = 0\n  lastFilterIndex = 0\n  dirs = []\n  dir = {}\n  arg = null\n\n  for (i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i)\n    if (inSingle) {\n      // check single quote\n      if (c === 0x27) inSingle = !inSingle\n    } else if (inDouble) {\n      // check double quote\n      if (c === 0x22) inDouble = !inDouble\n    } else if (\n      c === 0x2C && // comma\n      !paren && !curly && !square\n    ) {\n      // reached the end of a directive\n      pushDir()\n      // reset & skip the comma\n      dir = {}\n      begin = argIndex = lastFilterIndex = i + 1\n    } else if (\n      c === 0x3A && // colon\n      !dir.expression &&\n      !dir.arg\n    ) {\n      // argument\n      arg = str.slice(begin, i).trim()\n      // test for valid argument here\n      // since we may have caught stuff like first half of\n      // an object literal or a ternary expression.\n      if (argRE.test(arg)) {\n        argIndex = i + 1\n        dir.arg = _.stripQuotes(arg) || arg\n      }\n    } else if (\n      c === 0x7C && // pipe\n      str.charCodeAt(i + 1) !== 0x7C &&\n      str.charCodeAt(i - 1) !== 0x7C\n    ) {\n      if (dir.expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1\n        dir.expression = str.slice(argIndex, i).trim()\n      } else {\n        // already has filter\n        pushFilter()\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break // \"\n        case 0x27: inSingle = true; break // '\n        case 0x28: paren++; break         // (\n        case 0x29: paren--; break         // )\n        case 0x5B: square++; break        // [\n        case 0x5D: square--; break        // ]\n        case 0x7B: curly++; break         // {\n        case 0x7D: curly--; break         // }\n      }\n    }\n  }\n\n  if (i === 0 || begin !== i) {\n    pushDir()\n  }\n\n  cache.put(s, dirs)\n  return dirs\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/parsers/directive.js\n ** module id = 23\n ** module chunks = 0\n **/","var _ = require('../util')\nvar config = require('../config')\nvar textParser = require('../parsers/text')\nvar dirParser = require('../parsers/directive')\nvar templateParser = require('../parsers/template')\n\nmodule.exports = compile\n\n/**\n * Compile a template and return a reusable composite link\n * function, which recursively contains more link functions\n * inside. This top level compile function should only be\n * called on instance root nodes.\n *\n * @param {Element|DocumentFragment} el\n * @param {Object} options\n * @param {Boolean} partial\n * @param {Boolean} transcluded\n * @return {Function}\n */\n\nfunction compile (el, options, partial, transcluded) {\n  var isBlock = el.nodeType === 11\n  // link function for param attributes.\n  var params = options.paramAttributes\n  var paramsLinkFn = params && !partial && !transcluded && !isBlock\n    ? compileParamAttributes(el, params, options)\n    : null\n  // link function for the node itself.\n  // if this is a block instance, we return a link function\n  // for the attributes found on the container, if any.\n  // options._containerAttrs are collected during transclusion.\n  var nodeLinkFn = isBlock\n    ? compileBlockContainer(options._containerAttrs, params, options)\n    : compileNode(el, options)\n  // link function for the childNodes\n  var childLinkFn =\n    !(nodeLinkFn && nodeLinkFn.terminal) &&\n    el.tagName !== 'SCRIPT' &&\n    el.hasChildNodes()\n      ? compileNodeList(el.childNodes, options)\n      : null\n\n  /**\n   * A composite linker function to be called on a already\n   * compiled piece of DOM, which instantiates all directive\n   * instances.\n   *\n   * @param {Vue} vm\n   * @param {Element|DocumentFragment} el\n   * @return {Function|undefined}\n   */\n\n  function compositeLinkFn (vm, el) {\n    var originalDirCount = vm._directives.length\n    var parentOriginalDirCount =\n      vm.$parent && vm.$parent._directives.length\n    if (paramsLinkFn) {\n      paramsLinkFn(vm, el)\n    }\n    // cache childNodes before linking parent, fix #657\n    var childNodes = _.toArray(el.childNodes)\n    // if this is a transcluded compile, linkers need to be\n    // called in source scope, and the host needs to be\n    // passed down.\n    var source = transcluded ? vm.$parent : vm\n    var host = transcluded ? vm : undefined\n    // link\n    if (nodeLinkFn) nodeLinkFn(source, el, host)\n    if (childLinkFn) childLinkFn(source, childNodes, host)\n\n    /**\n     * If this is a partial compile, the linker function\n     * returns an unlink function that tearsdown all\n     * directives instances generated during the partial\n     * linking.\n     */\n\n    if (partial && !transcluded) {\n      var selfDirs = vm._directives.slice(originalDirCount)\n      var parentDirs = vm.$parent &&\n        vm.$parent._directives.slice(parentOriginalDirCount)\n\n      var teardownDirs = function (vm, dirs) {\n        var i = dirs.length\n        while (i--) {\n          dirs[i]._teardown()\n        }\n        i = vm._directives.indexOf(dirs[0])\n        vm._directives.splice(i, dirs.length)\n      }\n\n      return function unlink () {\n        teardownDirs(vm, selfDirs)\n        if (parentDirs) {\n          teardownDirs(vm.$parent, parentDirs)\n        }\n      }\n    }\n  }\n\n  // transcluded linkFns are terminal, because it takes\n  // over the entire sub-tree.\n  if (transcluded) {\n    compositeLinkFn.terminal = true\n  }\n\n  return compositeLinkFn\n}\n\n/**\n * Compile the attributes found on a \"block container\" -\n * i.e. the container node in the parent tempate of a block\n * instance. We are only concerned with v-with and\n * paramAttributes here.\n *\n * @param {Object} attrs - a map of attr name/value pairs\n * @param {Array} params - param attributes list\n * @param {Object} options\n * @return {Function}\n */\n\nfunction compileBlockContainer (attrs, params, options) {\n  if (!attrs) return null\n  var paramsLinkFn = params\n    ? compileParamAttributes(attrs, params, options)\n    : null\n  var withVal = attrs[config.prefix + 'with']\n  var withLinkFn = null\n  if (withVal) {\n    var descriptor = dirParser.parse(withVal)[0]\n    var def = options.directives['with']\n    withLinkFn = function (vm, el) {\n      vm._bindDir('with', el, descriptor, def)   \n    }\n  }\n  return function blockContainerLinkFn (vm) {\n    // explicitly passing null to the linkers\n    // since v-with doesn't need a real element\n    if (paramsLinkFn) paramsLinkFn(vm, null)\n    if (withLinkFn) withLinkFn(vm, null)\n  }\n}\n\n/**\n * Compile a node and return a nodeLinkFn based on the\n * node type.\n *\n * @param {Node} node\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileNode (node, options) {\n  var type = node.nodeType\n  if (type === 1 && node.tagName !== 'SCRIPT') {\n    return compileElement(node, options)\n  } else if (type === 3 && config.interpolate && node.data.trim()) {\n    return compileTextNode(node, options)\n  } else {\n    return null\n  }\n}\n\n/**\n * Compile an element and return a nodeLinkFn.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function|null}\n */\n\nfunction compileElement (el, options) {\n  if (checkTransclusion(el)) {\n    // unwrap textNode\n    if (el.hasAttribute('__vue__wrap')) {\n      el = el.firstChild\n    }\n    return compile(el, options._parent.$options, true, true)\n  }\n  var linkFn, tag, component\n  // check custom element component, but only on non-root\n  if (!el.__vue__) {\n    tag = el.tagName.toLowerCase()\n    component =\n      tag.indexOf('-') > 0 &&\n      options.components[tag]\n    if (component) {\n      el.setAttribute(config.prefix + 'component', tag)\n    }\n  }\n  if (component || el.hasAttributes()) {\n    // check terminal direcitves\n    linkFn = checkTerminalDirectives(el, options)\n    // if not terminal, build normal link function\n    if (!linkFn) {\n      var dirs = collectDirectives(el, options)\n      linkFn = dirs.length\n        ? makeNodeLinkFn(dirs)\n        : null\n    }\n  }\n  // if the element is a textarea, we need to interpolate\n  // its content on initial render.\n  if (el.tagName === 'TEXTAREA') {\n    var realLinkFn = linkFn\n    linkFn = function (vm, el) {\n      el.value = vm.$interpolate(el.value)\n      if (realLinkFn) realLinkFn(vm, el)\n    }\n    linkFn.terminal = true\n  }\n  return linkFn\n}\n\n/**\n * Build a link function for all directives on a single node.\n *\n * @param {Array} directives\n * @return {Function} directivesLinkFn\n */\n\nfunction makeNodeLinkFn (directives) {\n  return function nodeLinkFn (vm, el, host) {\n    // reverse apply because it's sorted low to high\n    var i = directives.length\n    var dir, j, k, target\n    while (i--) {\n      dir = directives[i]\n      // a directive can be transcluded if it's written\n      // on a component's container in its parent tempalte.\n      target = dir.transcluded\n        ? vm.$parent\n        : vm\n      if (dir._link) {\n        // custom link fn\n        dir._link(target, el)\n      } else {\n        k = dir.descriptors.length\n        for (j = 0; j < k; j++) {\n          target._bindDir(dir.name, el,\n            dir.descriptors[j], dir.def, host)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Compile a textNode and return a nodeLinkFn.\n *\n * @param {TextNode} node\n * @param {Object} options\n * @return {Function|null} textNodeLinkFn\n */\n\nfunction compileTextNode (node, options) {\n  var tokens = textParser.parse(node.data)\n  if (!tokens) {\n    return null\n  }\n  var frag = document.createDocumentFragment()\n  var el, token\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i]\n    el = token.tag\n      ? processTextToken(token, options)\n      : document.createTextNode(token.value)\n    frag.appendChild(el)\n  }\n  return makeTextNodeLinkFn(tokens, frag, options)\n}\n\n/**\n * Process a single text token.\n *\n * @param {Object} token\n * @param {Object} options\n * @return {Node}\n */\n\nfunction processTextToken (token, options) {\n  var el\n  if (token.oneTime) {\n    el = document.createTextNode(token.value)\n  } else {\n    if (token.html) {\n      el = document.createComment('v-html')\n      setTokenType('html')\n    } else if (token.partial) {\n      el = document.createComment('v-partial')\n      setTokenType('partial')\n    } else {\n      // IE will clean up empty textNodes during\n      // frag.cloneNode(true), so we have to give it\n      // something here...\n      el = document.createTextNode(' ')\n      setTokenType('text')\n    }\n  }\n  function setTokenType (type) {\n    token.type = type\n    token.def = options.directives[type]\n    token.descriptor = dirParser.parse(token.value)[0]\n  }\n  return el\n}\n\n/**\n * Build a function that processes a textNode.\n *\n * @param {Array<Object>} tokens\n * @param {DocumentFragment} frag\n */\n\nfunction makeTextNodeLinkFn (tokens, frag) {\n  return function textNodeLinkFn (vm, el) {\n    var fragClone = frag.cloneNode(true)\n    var childNodes = _.toArray(fragClone.childNodes)\n    var token, value, node\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      token = tokens[i]\n      value = token.value\n      if (token.tag) {\n        node = childNodes[i]\n        if (token.oneTime) {\n          value = vm.$eval(value)\n          if (token.html) {\n            _.replace(node, templateParser.parse(value, true))\n          } else {\n            node.data = value\n          }\n        } else {\n          vm._bindDir(token.type, node,\n                      token.descriptor, token.def)\n        }\n      }\n    }\n    _.replace(el, fragClone)\n  }\n}\n\n/**\n * Compile a node list and return a childLinkFn.\n *\n * @param {NodeList} nodeList\n * @param {Object} options\n * @return {Function|undefined}\n */\n\nfunction compileNodeList (nodeList, options) {\n  var linkFns = []\n  var nodeLinkFn, childLinkFn, node\n  for (var i = 0, l = nodeList.length; i < l; i++) {\n    node = nodeList[i]\n    nodeLinkFn = compileNode(node, options)\n    childLinkFn =\n      !(nodeLinkFn && nodeLinkFn.terminal) &&\n      node.tagName !== 'SCRIPT' &&\n      node.hasChildNodes()\n        ? compileNodeList(node.childNodes, options)\n        : null\n    linkFns.push(nodeLinkFn, childLinkFn)\n  }\n  return linkFns.length\n    ? makeChildLinkFn(linkFns)\n    : null\n}\n\n/**\n * Make a child link function for a node's childNodes.\n *\n * @param {Array<Function>} linkFns\n * @return {Function} childLinkFn\n */\n\nfunction makeChildLinkFn (linkFns) {\n  return function childLinkFn (vm, nodes, host) {\n    var node, nodeLinkFn, childrenLinkFn\n    for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n      node = nodes[n]\n      nodeLinkFn = linkFns[i++]\n      childrenLinkFn = linkFns[i++]\n      // cache childNodes before linking parent, fix #657\n      var childNodes = _.toArray(node.childNodes)\n      if (nodeLinkFn) {\n        nodeLinkFn(vm, node, host)\n      }\n      if (childrenLinkFn) {\n        childrenLinkFn(vm, childNodes, host)\n      }\n    }\n  }\n}\n\n/**\n * Compile param attributes on a root element and return\n * a paramAttributes link function.\n *\n * @param {Element|Object} el\n * @param {Array} attrs\n * @param {Object} options\n * @return {Function} paramsLinkFn\n */\n\nfunction compileParamAttributes (el, attrs, options) {\n  var params = []\n  var isEl = el.nodeType\n  var i = attrs.length\n  var name, value, param\n  while (i--) {\n    name = attrs[i]\n    if (/[A-Z]/.test(name)) {\n      _.warn(\n        'You seem to be using camelCase for a paramAttribute, ' +\n        'but HTML doesn\\'t differentiate between upper and ' +\n        'lower case. You should use hyphen-delimited ' +\n        'attribute names. For more info see ' +\n        'http://vuejs.org/api/options.html#paramAttributes'\n      )\n    }\n    value = isEl ? el.getAttribute(name) : el[name]\n    if (value !== null) {\n      param = {\n        name: name,\n        value: value\n      }\n      var tokens = textParser.parse(value)\n      if (tokens) {\n        if (isEl) el.removeAttribute(name)\n        if (tokens.length > 1) {\n          _.warn(\n            'Invalid param attribute binding: \"' +\n            name + '=\"' + value + '\"' +\n            '\\nDon\\'t mix binding tags with plain text ' +\n            'in param attribute bindings.'\n          )\n          continue\n        } else {\n          param.dynamic = true\n          param.value = tokens[0].value\n        }\n      }\n      params.push(param)\n    }\n  }\n  return makeParamsLinkFn(params, options)\n}\n\n/**\n * Build a function that applies param attributes to a vm.\n *\n * @param {Array} params\n * @param {Object} options\n * @return {Function} paramsLinkFn\n */\n\nvar dataAttrRE = /^data-/\n\nfunction makeParamsLinkFn (params, options) {\n  var def = options.directives['with']\n  return function paramsLinkFn (vm, el) {\n    var i = params.length\n    var param, path\n    while (i--) {\n      param = params[i]\n      // params could contain dashes, which will be\n      // interpreted as minus calculations by the parser\n      // so we need to wrap the path here\n      path = _.camelize(param.name.replace(dataAttrRE, ''))\n      if (param.dynamic) {\n        // dynamic param attribtues are bound as v-with.\n        // we can directly duck the descriptor here beacuse\n        // param attributes cannot use expressions or\n        // filters.\n        vm._bindDir('with', el, {\n          arg: path,\n          expression: param.value\n        }, def)\n      } else {\n        // just set once\n        vm.$set(path, param.value)\n      }\n    }\n  }\n}\n\n/**\n * Check an element for terminal directives in fixed order.\n * If it finds one, return a terminal link function.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Function} terminalLinkFn\n */\n\nvar terminalDirectives = [\n  'repeat',\n  'if',\n  'component'\n]\n\nfunction skip () {}\nskip.terminal = true\n\nfunction checkTerminalDirectives (el, options) {\n  if (_.attr(el, 'pre') !== null) {\n    return skip\n  }\n  var value, dirName\n  /* jshint boss: true */\n  for (var i = 0; i < 3; i++) {\n    dirName = terminalDirectives[i]\n    if (value = _.attr(el, dirName)) {\n      return makeTerminalNodeLinkFn(el, dirName, value, options)\n    }\n  }\n}\n\n/**\n * Build a node link function for a terminal directive.\n * A terminal link function terminates the current\n * compilation recursion and handles compilation of the\n * subtree in the directive.\n *\n * @param {Element} el\n * @param {String} dirName\n * @param {String} value\n * @param {Object} options\n * @return {Function} terminalLinkFn\n */\n\nfunction makeTerminalNodeLinkFn (el, dirName, value, options) {\n  var descriptor = dirParser.parse(value)[0]\n  var def = options.directives[dirName]\n  var fn = function terminalNodeLinkFn (vm, el, host) {\n    vm._bindDir(dirName, el, descriptor, def, host)\n  }\n  fn.terminal = true\n  return fn\n}\n\n/**\n * Collect the directives on an element.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Array}\n */\n\nfunction collectDirectives (el, options) {\n  var attrs = _.toArray(el.attributes)\n  var i = attrs.length\n  var dirs = []\n  var attr, attrName, dir, dirName, dirDef, transcluded\n  while (i--) {\n    attr = attrs[i]\n    attrName = attr.name\n    transcluded =\n      options._transcludedAttrs &&\n      options._transcludedAttrs[attrName]\n    if (attrName.indexOf(config.prefix) === 0) {\n      dirName = attrName.slice(config.prefix.length)\n      dirDef = options.directives[dirName]\n      _.assertAsset(dirDef, 'directive', dirName)\n      if (dirDef) {\n        dirs.push({\n          name: dirName,\n          descriptors: dirParser.parse(attr.value),\n          def: dirDef,\n          transcluded: transcluded\n        })\n      }\n    } else if (config.interpolate) {\n      dir = collectAttrDirective(el, attrName, attr.value,\n                                 options)\n      if (dir) {\n        dir.transcluded = transcluded\n        dirs.push(dir)\n      }\n    }\n  }\n  // sort by priority, LOW to HIGH\n  dirs.sort(directiveComparator)\n  return dirs\n}\n\n/**\n * Check an attribute for potential dynamic bindings,\n * and return a directive object.\n *\n * @param {Element} el\n * @param {String} name\n * @param {String} value\n * @param {Object} options\n * @return {Object}\n */\n\nfunction collectAttrDirective (el, name, value, options) {\n  var tokens = textParser.parse(value)\n  if (tokens) {\n    var def = options.directives.attr\n    var i = tokens.length\n    var allOneTime = true\n    while (i--) {\n      var token = tokens[i]\n      if (token.tag && !token.oneTime) {\n        allOneTime = false\n      }\n    }\n    return {\n      def: def,\n      _link: allOneTime\n        ? function (vm, el) {\n            el.setAttribute(name, vm.$interpolate(value))\n          }\n        : function (vm, el) {\n            var value = textParser.tokensToExp(tokens, vm)\n            var desc = dirParser.parse(name + ':' + value)[0]\n            vm._bindDir('attr', el, desc, def)\n          }\n    }\n  }\n}\n\n/**\n * Directive priority sort comparator\n *\n * @param {Object} a\n * @param {Object} b\n */\n\nfunction directiveComparator (a, b) {\n  a = a.def.priority || 0\n  b = b.def.priority || 0\n  return a > b ? 1 : -1\n}\n\n/**\n * Check whether an element is transcluded\n *\n * @param {Element} el\n * @return {Boolean}\n */\n\nvar transcludedFlagAttr = '__vue__transcluded'\nfunction checkTransclusion (el) {\n  if (el.nodeType === 1 && el.hasAttribute(transcludedFlagAttr)) {\n    el.removeAttribute(transcludedFlagAttr)\n    return true\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/compiler/compile.js\n ** module id = 24\n ** module chunks = 0\n **/","var _ = require('../util')\nvar Cache = require('../cache')\nvar templateCache = new Cache(1000)\nvar idSelectorCache = new Cache(1000)\n\nvar map = {\n  _default : [0, '', ''],\n  legend   : [1, '<fieldset>', '</fieldset>'],\n  tr       : [2, '<table><tbody>', '</tbody></table>'],\n  col      : [\n    2,\n    '<table><tbody></tbody><colgroup>',\n    '</colgroup></table>'\n  ]\n}\n\nmap.td =\nmap.th = [\n  3,\n  '<table><tbody><tr>',\n  '</tr></tbody></table>'\n]\n\nmap.option =\nmap.optgroup = [\n  1,\n  '<select multiple=\"multiple\">',\n  '</select>'\n]\n\nmap.thead =\nmap.tbody =\nmap.colgroup =\nmap.caption =\nmap.tfoot = [1, '<table>', '</table>']\n\nmap.g =\nmap.defs =\nmap.symbol =\nmap.use =\nmap.image =\nmap.text =\nmap.circle =\nmap.ellipse =\nmap.line =\nmap.path =\nmap.polygon =\nmap.polyline =\nmap.rect = [\n  1,\n  '<svg ' +\n    'xmlns=\"http://www.w3.org/2000/svg\" ' +\n    'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' +\n    'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' +\n    'version=\"1.1\">',\n  '</svg>'\n]\n\nvar tagRE = /<([\\w:]+)/\nvar entityRE = /&\\w+;/\n\n/**\n * Convert a string template to a DocumentFragment.\n * Determines correct wrapping by tag types. Wrapping\n * strategy found in jQuery & component/domify.\n *\n * @param {String} templateString\n * @return {DocumentFragment}\n */\n\nfunction stringToFragment (templateString) {\n  // try a cache hit first\n  var hit = templateCache.get(templateString)\n  if (hit) {\n    return hit\n  }\n\n  var frag = document.createDocumentFragment()\n  var tagMatch = templateString.match(tagRE)\n  var entityMatch = entityRE.test(templateString)\n\n  if (!tagMatch && !entityMatch) {\n    // text only, return a single text node.\n    frag.appendChild(\n      document.createTextNode(templateString)\n    )\n  } else {\n\n    var tag    = tagMatch && tagMatch[1]\n    var wrap   = map[tag] || map._default\n    var depth  = wrap[0]\n    var prefix = wrap[1]\n    var suffix = wrap[2]\n    var node   = document.createElement('div')\n\n    node.innerHTML = prefix + templateString.trim() + suffix\n    while (depth--) {\n      node = node.lastChild\n    }\n\n    var child\n    /* jshint boss:true */\n    while (child = node.firstChild) {\n      frag.appendChild(child)\n    }\n  }\n\n  templateCache.put(templateString, frag)\n  return frag\n}\n\n/**\n * Convert a template node to a DocumentFragment.\n *\n * @param {Node} node\n * @return {DocumentFragment}\n */\n\nfunction nodeToFragment (node) {\n  var tag = node.tagName\n  // if its a template tag and the browser supports it,\n  // its content is already a document fragment.\n  if (\n    tag === 'TEMPLATE' &&\n    node.content instanceof DocumentFragment\n  ) {\n    return node.content\n  }\n  // script template\n  if (tag === 'SCRIPT') {\n    return stringToFragment(node.textContent)\n  }\n  // normal node, clone it to avoid mutating the original\n  var clone = exports.clone(node)\n  var frag = document.createDocumentFragment()\n  var child\n  /* jshint boss:true */\n  while (child = clone.firstChild) {\n    frag.appendChild(child)\n  }\n  return frag\n}\n\n// Test for the presence of the Safari template cloning bug\n// https://bugs.webkit.org/show_bug.cgi?id=137755\nvar hasBrokenTemplate = _.inBrowser\n  ? (function () {\n      var a = document.createElement('div')\n      a.innerHTML = '<template>1</template>'\n      return !a.cloneNode(true).firstChild.innerHTML\n    })()\n  : false\n\n// Test for IE10/11 textarea placeholder clone bug\nvar hasTextareaCloneBug = _.inBrowser\n  ? (function () {\n      var t = document.createElement('textarea')\n      t.placeholder = 't'\n      return t.cloneNode(true).value === 't'\n    })()\n  : false\n\n/**\n * 1. Deal with Safari cloning nested <template> bug by\n *    manually cloning all template instances.\n * 2. Deal with IE10/11 textarea placeholder bug by setting\n *    the correct value after cloning.\n *\n * @param {Element|DocumentFragment} node\n * @return {Element|DocumentFragment}\n */\n\nexports.clone = function (node) {\n  var res = node.cloneNode(true)\n  var i, original, cloned\n  /* istanbul ignore if */\n  if (hasBrokenTemplate) {\n    original = node.querySelectorAll('template')\n    if (original.length) {\n      cloned = res.querySelectorAll('template')\n      i = cloned.length\n      while (i--) {\n        cloned[i].parentNode.replaceChild(\n          original[i].cloneNode(true),\n          cloned[i]\n        )\n      }\n    }\n  }\n  /* istanbul ignore if */\n  if (hasTextareaCloneBug) {\n    if (node.tagName === 'TEXTAREA') {\n      res.value = node.value\n    } else {\n      original = node.querySelectorAll('textarea')\n      if (original.length) {\n        cloned = res.querySelectorAll('textarea')\n        i = cloned.length\n        while (i--) {\n          cloned[i].value = original[i].value\n        }\n      }\n    }\n  }\n  return res\n}\n\n/**\n * Process the template option and normalizes it into a\n * a DocumentFragment that can be used as a partial or a\n * instance template.\n *\n * @param {*} template\n *    Possible values include:\n *    - DocumentFragment object\n *    - Node object of type Template\n *    - id selector: '#some-template-id'\n *    - template string: '<div><span>{{msg}}</span></div>'\n * @param {Boolean} clone\n * @param {Boolean} noSelector\n * @return {DocumentFragment|undefined}\n */\n\nexports.parse = function (template, clone, noSelector) {\n  var node, frag\n\n  // if the template is already a document fragment,\n  // do nothing\n  if (template instanceof DocumentFragment) {\n    return clone\n      ? template.cloneNode(true)\n      : template\n  }\n\n  if (typeof template === 'string') {\n    // id selector\n    if (!noSelector && template.charAt(0) === '#') {\n      // id selector can be cached too\n      frag = idSelectorCache.get(template)\n      if (!frag) {\n        node = document.getElementById(template.slice(1))\n        if (node) {\n          frag = nodeToFragment(node)\n          // save selector to cache\n          idSelectorCache.put(template, frag)\n        }\n      }\n    } else {\n      // normal string template\n      frag = stringToFragment(template)\n    }\n  } else if (template.nodeType) {\n    // a direct node\n    frag = nodeToFragment(template)\n  }\n\n  return frag && clone\n    ? exports.clone(frag)\n    : frag\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/parsers/template.js\n ** module id = 25\n ** module chunks = 0\n **/","var _ = require('../util')\nvar templateParser = require('../parsers/template')\n\nmodule.exports = {\n\n  isLiteral: true,\n\n  /**\n   * Setup. Two possible usages:\n   *\n   * - static:\n   *   v-component=\"comp\"\n   *\n   * - dynamic:\n   *   v-component=\"{{currentView}}\"\n   */\n\n  bind: function () {\n    if (!this.el.__vue__) {\n      // create a ref anchor\n      this.ref = document.createComment('v-component')\n      _.replace(this.el, this.ref)\n      // check keep-alive options.\n      // If yes, instead of destroying the active vm when\n      // hiding (v-if) or switching (dynamic literal) it,\n      // we simply remove it from the DOM and save it in a\n      // cache object, with its constructor id as the key.\n      this.keepAlive = this._checkParam('keep-alive') != null\n      // check ref\n      this.refID = _.attr(this.el, 'ref')\n      if (this.keepAlive) {\n        this.cache = {}\n      }\n      // check inline-template\n      if (this._checkParam('inline-template') !== null) {\n        // extract inline template as a DocumentFragment\n        this.template = _.extractContent(this.el, true)\n      }\n      // if static, build right now.\n      if (!this._isDynamicLiteral) {\n        this.resolveCtor(this.expression)\n        var child = this.build()\n        child.$before(this.ref)\n        this.setCurrent(child)\n      } else {\n        // check dynamic component params\n        this.readyEvent = this._checkParam('wait-for')\n        this.transMode = this._checkParam('transition-mode')\n      }\n    } else {\n      _.warn(\n        'v-component=\"' + this.expression + '\" cannot be ' +\n        'used on an already mounted instance.'\n      )\n    }\n  },\n\n  /**\n   * Resolve the component constructor to use when creating\n   * the child vm.\n   */\n\n  resolveCtor: function (id) {\n    this.ctorId = id\n    this.Ctor = this.vm.$options.components[id]\n    _.assertAsset(this.Ctor, 'component', id)\n  },\n\n  /**\n   * Instantiate/insert a new child vm.\n   * If keep alive and has cached instance, insert that\n   * instance; otherwise build a new one and cache it.\n   *\n   * @return {Vue} - the created instance\n   */\n\n  build: function () {\n    if (this.keepAlive) {\n      var cached = this.cache[this.ctorId]\n      if (cached) {\n        return cached\n      }\n    }\n    var vm = this.vm\n    var el = templateParser.clone(this.el)\n    if (this.Ctor) {\n      var child = vm.$addChild({\n        el: el,\n        template: this.template,\n        _asComponent: true,\n        _host: this._host\n      }, this.Ctor)\n      if (this.keepAlive) {\n        this.cache[this.ctorId] = child\n      }\n      return child\n    }\n  },\n\n  /**\n   * Teardown the current child, but defers cleanup so\n   * that we can separate the destroy and removal steps.\n   */\n\n  unbuild: function () {\n    var child = this.childVM\n    if (!child || this.keepAlive) {\n      return\n    }\n    // the sole purpose of `deferCleanup` is so that we can\n    // \"deactivate\" the vm right now and perform DOM removal\n    // later.\n    child.$destroy(false, true)\n  },\n\n  /**\n   * Remove current destroyed child and manually do\n   * the cleanup after removal.\n   *\n   * @param {Function} cb\n   */\n\n  remove: function (child, cb) {\n    var keepAlive = this.keepAlive\n    if (child) {\n      child.$remove(function () {\n        if (!keepAlive) child._cleanup()\n        if (cb) cb()\n      })\n    } else if (cb) {\n      cb()\n    }\n  },\n\n  /**\n   * Update callback for the dynamic literal scenario,\n   * e.g. v-component=\"{{view}}\"\n   */\n\n  update: function (value) {\n    if (!value) {\n      // just destroy and remove current\n      this.unbuild()\n      this.remove(this.childVM)\n      this.unsetCurrent()\n    } else {\n      this.resolveCtor(value)\n      this.unbuild()\n      var newComponent = this.build()\n      var self = this\n      if (this.readyEvent) {\n        newComponent.$once(this.readyEvent, function () {\n          self.swapTo(newComponent)\n        })\n      } else {\n        this.swapTo(newComponent)\n      }\n    }\n  },\n\n  /**\n   * Actually swap the components, depending on the\n   * transition mode. Defaults to simultaneous.\n   *\n   * @param {Vue} target\n   */\n\n  swapTo: function (target) {\n    var self = this\n    var current = this.childVM\n    this.unsetCurrent()\n    this.setCurrent(target)\n    switch (self.transMode) {\n      case 'in-out':\n        target.$before(self.ref, function () {\n          self.remove(current)\n        })\n        break\n      case 'out-in':\n        self.remove(current, function () {\n          target.$before(self.ref)\n        })\n        break\n      default:\n        self.remove(current)\n        target.$before(self.ref)\n    }\n  },\n\n  /**\n   * Set childVM and parent ref\n   */\n  \n  setCurrent: function (child) {\n    this.childVM = child\n    var refID = child._refID || this.refID\n    if (refID) {\n      this.vm.$[refID] = child\n    }\n  },\n\n  /**\n   * Unset childVM and parent ref\n   */\n\n  unsetCurrent: function () {\n    var child = this.childVM\n    this.childVM = null\n    var refID = (child && child._refID) || this.refID\n    if (refID) {\n      this.vm.$[refID] = null\n    }\n  },\n\n  /**\n   * Unbind.\n   */\n\n  unbind: function () {\n    this.unbuild()\n    // destroy all keep-alive cached instances\n    if (this.cache) {\n      for (var key in this.cache) {\n        this.cache[key].$destroy()\n      }\n      this.cache = null\n    }\n  }\n\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/component.js\n ** module id = 27\n ** module chunks = 0\n **/","var _ = require('../util')\nvar config = require('../config')\nvar templateParser = require('../parsers/template')\nvar transcludedFlagAttr = '__vue__transcluded'\n\n/**\n * Process an element or a DocumentFragment based on a\n * instance option object. This allows us to transclude\n * a template node/fragment before the instance is created,\n * so the processed fragment can then be cloned and reused\n * in v-repeat.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nmodule.exports = function transclude (el, options) {\n  if (options && options._asComponent) {\n    // mutating the options object here assuming the same\n    // object will be used for compile right after this\n    options._transcludedAttrs = extractAttrs(el.attributes)\n    // Mark content nodes and attrs so that the compiler\n    // knows they should be compiled in parent scope.\n    var i = el.childNodes.length\n    while (i--) {\n      var node = el.childNodes[i]\n      if (node.nodeType === 1) {\n        node.setAttribute(transcludedFlagAttr, '')\n      } else if (node.nodeType === 3 && node.data.trim()) {\n        // wrap transcluded textNodes in spans, because\n        // raw textNodes can't be persisted through clones\n        // by attaching attributes.\n        var wrapper = document.createElement('span')\n        wrapper.textContent = node.data\n        wrapper.setAttribute('__vue__wrap', '')\n        wrapper.setAttribute(transcludedFlagAttr, '')\n        el.replaceChild(wrapper, node)\n      }\n    }\n  }\n  // for template tags, what we want is its content as\n  // a documentFragment (for block instances)\n  if (el.tagName === 'TEMPLATE') {\n    el = templateParser.parse(el)\n  }\n  if (options && options.template) {\n    el = transcludeTemplate(el, options)\n  }\n  if (el instanceof DocumentFragment) {\n    _.prepend(document.createComment('v-start'), el)\n    el.appendChild(document.createComment('v-end'))\n  }\n  return el\n}\n\n/**\n * Process the template option.\n * If the replace option is true this will swap the $el.\n *\n * @param {Element} el\n * @param {Object} options\n * @return {Element|DocumentFragment}\n */\n\nfunction transcludeTemplate (el, options) {\n  var template = options.template\n  var frag = templateParser.parse(template, true)\n  if (!frag) {\n    _.warn('Invalid template option: ' + template)\n  } else {\n    var rawContent = options._content || _.extractContent(el)\n    if (options.replace) {\n      if (frag.childNodes.length > 1) {\n        // this is a block instance which has no root node.\n        // however, the container in the parent template\n        // (which is replaced here) may contain v-with and\n        // paramAttributes that still need to be compiled\n        // for the child. we store all the container\n        // attributes on the options object and pass it down\n        // to the compiler.\n        var containerAttrs = options._containerAttrs = {}\n        var i = el.attributes.length\n        while (i--) {\n          var attr = el.attributes[i]\n          containerAttrs[attr.name] = attr.value\n        }\n        transcludeContent(frag, rawContent)\n        return frag\n      } else {\n        var replacer = frag.firstChild\n        _.copyAttributes(el, replacer)\n        transcludeContent(replacer, rawContent)\n        return replacer\n      }\n    } else {\n      el.appendChild(frag)\n      transcludeContent(el, rawContent)\n      return el\n    }\n  }\n}\n\n/**\n * Resolve <content> insertion points mimicking the behavior\n * of the Shadow DOM spec:\n *\n *   http://w3c.github.io/webcomponents/spec/shadow/#insertion-points\n *\n * @param {Element|DocumentFragment} el\n * @param {Element} raw\n */\n\nfunction transcludeContent (el, raw) {\n  var outlets = getOutlets(el)\n  var i = outlets.length\n  if (!i) return\n  var outlet, select, selected, j, main\n\n  function isDirectChild (node) {\n    return node.parentNode === raw\n  }\n\n  // first pass, collect corresponding content\n  // for each outlet.\n  while (i--) {\n    outlet = outlets[i]\n    if (raw) {\n      select = outlet.getAttribute('select')\n      if (select) {  // select content\n        selected = raw.querySelectorAll(select)\n        if (selected.length) {\n          // according to Shadow DOM spec, `select` can\n          // only select direct children of the host node.\n          // enforcing this also fixes #786.\n          selected = [].filter.call(selected, isDirectChild)\n        }\n        outlet.content = selected.length\n          ? selected\n          : _.toArray(outlet.childNodes)\n      } else { // default content\n        main = outlet\n      }\n    } else { // fallback content\n      outlet.content = _.toArray(outlet.childNodes)\n    }\n  }\n  // second pass, actually insert the contents\n  for (i = 0, j = outlets.length; i < j; i++) {\n    outlet = outlets[i]\n    if (outlet !== main) {\n      insertContentAt(outlet, outlet.content)\n    }\n  }\n  // finally insert the main content\n  if (main) {\n    insertContentAt(main, _.toArray(raw.childNodes))\n  }\n}\n\n/**\n * Get <content> outlets from the element/list\n *\n * @param {Element|Array} el\n * @return {Array}\n */\n\nvar concat = [].concat\nfunction getOutlets (el) {\n  return _.isArray(el)\n    ? concat.apply([], el.map(getOutlets))\n    : el.querySelectorAll\n      ? _.toArray(el.querySelectorAll('content'))\n      : []\n}\n\n/**\n * Insert an array of nodes at outlet,\n * then remove the outlet.\n *\n * @param {Element} outlet\n * @param {Array} contents\n */\n\nfunction insertContentAt (outlet, contents) {\n  // not using util DOM methods here because\n  // parentNode can be cached\n  var parent = outlet.parentNode\n  for (var i = 0, j = contents.length; i < j; i++) {\n    parent.insertBefore(contents[i], outlet)\n  }\n  parent.removeChild(outlet)\n}\n\n/**\n * Helper to extract a component container's attribute names\n * into a map, and filtering out `v-with` in the process.\n * The resulting map will be used in compiler/compile to\n * determine whether an attribute is transcluded.\n *\n * @param {NameNodeMap} attrs\n */\n\nfunction extractAttrs (attrs) {\n  if (!attrs) return null\n  var res = {}\n  var vwith = config.prefix + 'with'\n  var i = attrs.length\n  while (i--) {\n    var name = attrs[i].name\n    if (name !== vwith) res[name] = true\n  }\n  return res\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/compiler/transclude.js\n ** module id = 28\n ** module chunks = 0\n **/","var _ = require('../util')\nvar mergeOptions = require('../util/merge-option')\n\n/**\n * Expose useful internals\n */\n\nexports.util = _\nexports.nextTick = _.nextTick\nexports.config = require('../config')\n\nexports.compiler = {\n  compile: require('../compiler/compile'),\n  transclude: require('../compiler/transclude')\n}\n\nexports.parsers = {\n  path: require('../parsers/path'),\n  text: require('../parsers/text'),\n  template: require('../parsers/template'),\n  directive: require('../parsers/directive'),\n  expression: require('../parsers/expression')\n}\n\n/**\n * Each instance constructor, including Vue, has a unique\n * cid. This enables us to create wrapped \"child\n * constructors\" for prototypal inheritance and cache them.\n */\n\nexports.cid = 0\nvar cid = 1\n\n/**\n * Class inehritance\n *\n * @param {Object} extendOptions\n */\n\nexports.extend = function (extendOptions) {\n  extendOptions = extendOptions || {}\n  var Super = this\n  var Sub = createClass(\n    extendOptions.name ||\n    Super.options.name ||\n    'VueComponent'\n  )\n  Sub.prototype = Object.create(Super.prototype)\n  Sub.prototype.constructor = Sub\n  Sub.cid = cid++\n  Sub.options = mergeOptions(\n    Super.options,\n    extendOptions\n  )\n  Sub['super'] = Super\n  // allow further extension\n  Sub.extend = Super.extend\n  // create asset registers, so extended classes\n  // can have their private assets too.\n  createAssetRegisters(Sub)\n  return Sub\n}\n\n/**\n * A function that returns a sub-class constructor with the\n * given name. This gives us much nicer output when\n * logging instances in the console.\n *\n * @param {String} name\n * @return {Function}\n */\n\nfunction createClass (name) {\n  return new Function(\n    'return function ' + _.classify(name) +\n    ' (options) { this._init(options) }'\n  )()\n}\n\n/**\n * Plugin system\n *\n * @param {Object} plugin\n */\n\nexports.use = function (plugin) {\n  // additional parameters\n  var args = _.toArray(arguments, 1)\n  args.unshift(this)\n  if (typeof plugin.install === 'function') {\n    plugin.install.apply(plugin, args)\n  } else {\n    plugin.apply(null, args)\n  }\n  return this\n}\n\n/**\n * Define asset registration methods on a constructor.\n *\n * @param {Function} Constructor\n */\n\nvar assetTypes = [\n  'directive',\n  'filter',\n  'partial',\n  'transition'\n]\n\nfunction createAssetRegisters (Constructor) {\n\n  /* Asset registration methods share the same signature:\n   *\n   * @param {String} id\n   * @param {*} definition\n   */\n\n  assetTypes.forEach(function (type) {\n    Constructor[type] = function (id, definition) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        this.options[type + 's'][id] = definition\n      }\n    }\n  })\n\n  /**\n   * Component registration needs to automatically invoke\n   * Vue.extend on object values.\n   *\n   * @param {String} id\n   * @param {Object|Function} definition\n   */\n\n  Constructor.component = function (id, definition) {\n    if (!definition) {\n      return this.options.components[id]\n    } else {\n      if (_.isPlainObject(definition)) {\n        definition.name = id\n        definition = _.Vue.extend(definition)\n      }\n      this.options.components[id] = definition\n    }\n  }\n}\n\ncreateAssetRegisters(exports)\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/api/global.js\n ** module id = 29\n ** module chunks = 0\n **/","// manipulation directives\nexports.text       = require('./text')\nexports.html       = require('./html')\nexports.attr       = require('./attr')\nexports.show       = require('./show')\nexports['class']   = require('./class')\nexports.el         = require('./el')\nexports.ref        = require('./ref')\nexports.cloak      = require('./cloak')\nexports.style      = require('./style')\nexports.partial    = require('./partial')\nexports.transition = require('./transition')\n\n// event listener directives\nexports.on         = require('./on')\nexports.model      = require('./model')\n\n// child vm directives\nexports.component  = require('./component')\nexports.repeat     = require('./repeat')\nexports['if']      = require('./if')\n\n// child vm communication directives\nexports['with']    = require('./with')\nexports.events     = require('./events')\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/index.js\n ** module id = 30\n ** module chunks = 0\n **/","var _ = require('../util')\n\nmodule.exports = {\n\n  bind: function () {\n    this.attr = this.el.nodeType === 3\n      ? 'nodeValue'\n      : 'textContent'\n  },\n\n  update: function (value) {\n    this.el[this.attr] = _.toString(value)\n  }\n  \n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/text.js\n ** module id = 31\n ** module chunks = 0\n **/","var _ = require('../util')\nvar templateParser = require('../parsers/template')\n\nmodule.exports = {\n\n  bind: function () {\n    // a comment node means this is a binding for\n    // {{{ inline unescaped html }}}\n    if (this.el.nodeType === 8) {\n      // hold nodes\n      this.nodes = []\n    }\n  },\n\n  update: function (value) {\n    value = _.toString(value)\n    if (this.nodes) {\n      this.swap(value)\n    } else {\n      this.el.innerHTML = value\n    }\n  },\n\n  swap: function (value) {\n    // remove old nodes\n    var i = this.nodes.length\n    while (i--) {\n      _.remove(this.nodes[i])\n    }\n    // convert new value to a fragment\n    // do not attempt to retrieve from id selector\n    var frag = templateParser.parse(value, true, true)\n    // save a reference to these nodes so we can remove later\n    this.nodes = _.toArray(frag.childNodes)\n    _.before(frag, this.el)\n  }\n\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/html.js\n ** module id = 32\n ** module chunks = 0\n **/","// xlink\nvar xlinkNS = 'http://www.w3.org/1999/xlink'\nvar xlinkRE = /^xlink:/\n\nmodule.exports = {\n\n  priority: 850,\n\n  bind: function () {\n    var name = this.arg\n    this.update = xlinkRE.test(name)\n      ? xlinkHandler\n      : defaultHandler\n  }\n\n}\n\nfunction defaultHandler (value) {\n  if (value || value === 0) {\n    this.el.setAttribute(this.arg, value)\n  } else {\n    this.el.removeAttribute(this.arg)\n  }\n}\n\nfunction xlinkHandler (value) {\n  if (value != null) {\n    this.el.setAttributeNS(xlinkNS, this.arg, value)\n  } else {\n    this.el.removeAttributeNS(xlinkNS, 'href')\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/attr.js\n ** module id = 33\n ** module chunks = 0\n **/","var transition = require('../transition')\n\nmodule.exports = function (value) {\n  var el = this.el\n  transition.apply(el, value ? 1 : -1, function () {\n    el.style.display = value ? '' : 'none'\n  }, this.vm)\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/show.js\n ** module id = 34\n ** module chunks = 0\n **/","var _ = require('../util')\n\n/**\n * Append with transition.\n *\n * @oaram {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.append = function (el, target, vm, cb) {\n  apply(el, 1, function () {\n    target.appendChild(el)\n  }, vm, cb)\n}\n\n/**\n * InsertBefore with transition.\n *\n * @oaram {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.before = function (el, target, vm, cb) {\n  apply(el, 1, function () {\n    _.before(el, target)\n  }, vm, cb)\n}\n\n/**\n * Remove with transition.\n *\n * @oaram {Element} el\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.remove = function (el, vm, cb) {\n  apply(el, -1, function () {\n    _.remove(el)\n  }, vm, cb)\n}\n\n/**\n * Remove by appending to another parent with transition.\n * This is only used in block operations.\n *\n * @oaram {Element} el\n * @param {Element} target\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nexports.removeThenAppend = function (el, target, vm, cb) {\n  apply(el, -1, function () {\n    target.appendChild(el)\n  }, vm, cb)\n}\n\n/**\n * Append the childNodes of a fragment to target.\n *\n * @param {DocumentFragment} block\n * @param {Node} target\n * @param {Vue} vm\n */\n\nexports.blockAppend = function (block, target, vm) {\n  var nodes = _.toArray(block.childNodes)\n  for (var i = 0, l = nodes.length; i < l; i++) {\n    exports.before(nodes[i], target, vm)\n  }\n}\n\n/**\n * Remove a block of nodes between two edge nodes.\n *\n * @param {Node} start\n * @param {Node} end\n * @param {Vue} vm\n */\n\nexports.blockRemove = function (start, end, vm) {\n  var node = start.nextSibling\n  var next\n  while (node !== end) {\n    next = node.nextSibling\n    exports.remove(node, vm)\n    node = next\n  }\n}\n\n/**\n * Apply transitions with an operation callback.\n *\n * @oaram {Element} el\n * @param {Number} direction\n *                  1: enter\n *                 -1: leave\n * @param {Function} op - the actual DOM operation\n * @param {Vue} vm\n * @param {Function} [cb]\n */\n\nvar apply = exports.apply = function (el, direction, op, vm, cb) {\n  var transition = el.__v_trans\n  if (\n    !transition ||\n    // skip if there are no js hooks and CSS transition is\n    // not supported\n    (!transition.hooks && !_.transitionEndEvent) ||\n    // skip transitions for initial compile\n    !vm._isCompiled ||\n    // if the vm is being manipulated by a parent directive\n    // during the parent's compilation phase, skip the\n    // animation.\n    (vm.$parent && !vm.$parent._isCompiled)\n  ) {\n    op()\n    if (cb) cb()\n    return\n  }\n  var action = direction > 0 ? 'enter' : 'leave'\n  transition[action](op, cb)\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/transition/index.js\n ** module id = 35\n ** module chunks = 0\n **/","var _ = require('../util')\nvar addClass = _.addClass\nvar removeClass = _.removeClass\n\nmodule.exports = function (value) {\n  if (this.arg) {\n    var method = value ? addClass : removeClass\n    method(this.el, this.arg)\n  } else {\n    if (this.lastVal) {\n      removeClass(this.el, this.lastVal)\n    }\n    if (value) {\n      addClass(this.el, value)\n      this.lastVal = value\n    }\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/class.js\n ** module id = 36\n ** module chunks = 0\n **/","module.exports = {\n\n  isLiteral: true,\n\n  bind: function () {\n    this.vm.$$[this.expression] = this.el\n  },\n\n  unbind: function () {\n    delete this.vm.$$[this.expression]\n  }\n  \n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/el.js\n ** module id = 37\n ** module chunks = 0\n **/","var _ = require('../util')\n\nmodule.exports = {\n\n  isLiteral: true,\n\n  bind: function () {\n    var vm = this.el.__vue__\n    if (!vm) {\n      _.warn(\n        'v-ref should only be used on a component root element.'\n      )\n      return\n    }\n    // If we get here, it means this is a `v-ref` on a\n    // child, because parent scope `v-ref` is stripped in\n    // `v-component` already. So we just record our own ref\n    // here - it will overwrite parent ref in `v-component`,\n    // if any.\n    vm._refID = this.expression\n  }\n  \n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/ref.js\n ** module id = 38\n ** module chunks = 0\n **/","var config = require('../config')\n\nmodule.exports = {\n\n  bind: function () {\n    var el = this.el\n    this.vm.$once('hook:compiled', function () {\n      el.removeAttribute(config.prefix + 'cloak')\n    })\n  }\n\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/cloak.js\n ** module id = 39\n ** module chunks = 0\n **/","var _ = require('../util')\nvar prefixes = ['-webkit-', '-moz-', '-ms-']\nvar camelPrefixes = ['Webkit', 'Moz', 'ms']\nvar importantRE = /!important;?$/\nvar camelRE = /([a-z])([A-Z])/g\nvar testEl = null\nvar propCache = {}\n\nmodule.exports = {\n\n  deep: true,\n\n  update: function (value) {\n    if (this.arg) {\n      this.setProp(this.arg, value)\n    } else {\n      if (typeof value === 'object') {\n        // cache object styles so that only changed props\n        // are actually updated.\n        if (!this.cache) this.cache = {}\n        for (var prop in value) {\n          this.setProp(prop, value[prop])\n          /* jshint eqeqeq: false */\n          if (value[prop] != this.cache[prop]) {\n            this.cache[prop] = value[prop]\n            this.setProp(prop, value[prop])\n          }\n        }\n      } else {\n        this.el.style.cssText = value\n      }\n    }\n  },\n\n  setProp: function (prop, value) {\n    prop = normalize(prop)\n    if (!prop) return // unsupported prop\n    // cast possible numbers/booleans into strings\n    if (value != null) value += ''\n    if (value) {\n      var isImportant = importantRE.test(value)\n        ? 'important'\n        : ''\n      if (isImportant) {\n        value = value.replace(importantRE, '').trim()\n      }\n      this.el.style.setProperty(prop, value, isImportant)\n    } else {\n      this.el.style.removeProperty(prop)\n    }\n  }\n\n}\n\n/**\n * Normalize a CSS property name.\n * - cache result\n * - auto prefix\n * - camelCase -> dash-case\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction normalize (prop) {\n  if (propCache[prop]) {\n    return propCache[prop]\n  }\n  var res = prefix(prop)\n  propCache[prop] = propCache[res] = res\n  return res\n}\n\n/**\n * Auto detect the appropriate prefix for a CSS property.\n * https://gist.github.com/paulirish/523692\n *\n * @param {String} prop\n * @return {String}\n */\n\nfunction prefix (prop) {\n  prop = prop.replace(camelRE, '$1-$2').toLowerCase()\n  var camel = _.camelize(prop)\n  var upper = camel.charAt(0).toUpperCase() + camel.slice(1)\n  if (!testEl) {\n    testEl = document.createElement('div')\n  }\n  if (camel in testEl.style) {\n    return prop\n  }\n  var i = prefixes.length\n  var prefixed\n  while (i--) {\n    prefixed = camelPrefixes[i] + upper\n    if (prefixed in testEl.style) {\n      return prefixes[i] + prop\n    }\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/style.js\n ** module id = 40\n ** module chunks = 0\n **/","module.exports = {\n\n  priority: 1000,\n  isLiteral: true,\n\n  bind: function () {\n    if (!this._isDynamicLiteral) {\n      this.update(this.expression)\n    }\n  },\n\n  update: function (id) {\n    var vm = this.el.__vue__ || this.vm\n    this.el.__v_trans = {\n      id: id,\n      // resolve the custom transition functions now\n      // so the transition module knows this is a\n      // javascript transition without having to check\n      // computed CSS.\n      fns: vm.$options.transitions[id]\n    }\n  }\n\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/transition.js\n ** module id = 41\n ** module chunks = 0\n **/","var _ = require('../util')\n\nmodule.exports = {\n\n  acceptStatement: true,\n  priority: 700,\n\n  bind: function () {\n    // deal with iframes\n    if (\n      this.el.tagName === 'IFRAME' &&\n      this.arg !== 'load'\n    ) {\n      var self = this\n      this.iframeBind = function () {\n        _.on(self.el.contentWindow, self.arg, self.handler)\n      }\n      _.on(this.el, 'load', this.iframeBind)\n    }\n  },\n\n  update: function (handler) {\n    if (typeof handler !== 'function') {\n      _.warn(\n        'Directive \"v-on:' + this.expression + '\" ' +\n        'expects a function value.'\n      )\n      return\n    }\n    this.reset()\n    var vm = this.vm\n    this.handler = function (e) {\n      e.targetVM = vm\n      vm.$event = e\n      var res = handler(e)\n      vm.$event = null\n      return res\n    }\n    if (this.iframeBind) {\n      this.iframeBind()\n    } else {\n      _.on(this.el, this.arg, this.handler)\n    }\n  },\n\n  reset: function () {\n    var el = this.iframeBind\n      ? this.el.contentWindow\n      : this.el\n    if (this.handler) {\n      _.off(el, this.arg, this.handler)\n    }\n  },\n\n  unbind: function () {\n    this.reset()\n    _.off(this.el, 'load', this.iframeBind)\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/on.js\n ** module id = 44\n ** module chunks = 0\n **/","var _ = require('../../util')\n\nvar handlers = {\n  _default: require('./default'),\n  radio: require('./radio'),\n  select: require('./select'),\n  checkbox: require('./checkbox')\n}\n\nmodule.exports = {\n\n  priority: 800,\n  twoWay: true,\n  handlers: handlers,\n\n  /**\n   * Possible elements:\n   *   <select>\n   *   <textarea>\n   *   <input type=\"*\">\n   *     - text\n   *     - checkbox\n   *     - radio\n   *     - number\n   *     - TODO: more types may be supplied as a plugin\n   */\n\n  bind: function () {\n    // friendly warning...\n    var filters = this.filters\n    if (filters && filters.read && !filters.write) {\n      _.warn(\n        'It seems you are using a read-only filter with ' +\n        'v-model. You might want to use a two-way filter ' +\n        'to ensure correct behavior.'\n      )\n    }\n    var el = this.el\n    var tag = el.tagName\n    var handler\n    if (tag === 'INPUT') {\n      handler = handlers[el.type] || handlers._default\n    } else if (tag === 'SELECT') {\n      handler = handlers.select\n    } else if (tag === 'TEXTAREA') {\n      handler = handlers._default\n    } else {\n      _.warn(\"v-model doesn't support element type: \" + tag)\n      return\n    }\n    handler.bind.call(this)\n    this.update = handler.update\n    this.unbind = handler.unbind\n  }\n\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/model/index.js\n ** module id = 45\n ** module chunks = 0\n **/","var _ = require('../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n    this.listener = function () {\n      self.set(el.value, true)\n    }\n    _.on(el, 'change', this.listener)\n    if (el.checked) {\n      this._initValue = el.value\n    }\n  },\n\n  update: function (value) {\n    /* jshint eqeqeq: false */\n    this.el.checked = value == this.el.value\n  },\n\n  unbind: function () {\n    _.off(this.el, 'change', this.listener)\n  }\n\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/model/radio.js\n ** module id = 47\n ** module chunks = 0\n **/","var _ = require('../../util')\nvar Watcher = require('../../watcher')\nvar dirParser = require('../../parsers/directive')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n    // check options param\n    var optionsParam = this._checkParam('options')\n    if (optionsParam) {\n      initOptions.call(this, optionsParam)\n    }\n    this.number = this._checkParam('number') != null\n    this.multiple = el.hasAttribute('multiple')\n    this.listener = function () {\n      var value = self.multiple\n        ? getMultiValue(el)\n        : el.value\n      value = self.number\n        ? _.isArray(value)\n          ? value.map(_.toNumber)\n          : _.toNumber(value)\n        : value\n      self.set(value, true)\n    }\n    _.on(el, 'change', this.listener)\n    checkInitialValue.call(this)\n  },\n\n  update: function (value) {\n    /* jshint eqeqeq: false */\n    var el = this.el\n    el.selectedIndex = -1\n    var multi = this.multiple && _.isArray(value)\n    var options = el.options\n    var i = options.length\n    var option\n    while (i--) {\n      option = options[i]\n      option.selected = multi\n        ? indexOf(value, option.value) > -1\n        : value == option.value\n    }\n  },\n\n  unbind: function () {\n    _.off(this.el, 'change', this.listener)\n    if (this.optionWatcher) {\n      this.optionWatcher.teardown()\n    }\n  }\n\n}\n\n/**\n * Initialize the option list from the param.\n *\n * @param {String} expression\n */\n\nfunction initOptions (expression) {\n  var self = this\n  var descriptor = dirParser.parse(expression)[0]\n  function optionUpdateWatcher (value) {\n    if (_.isArray(value)) {\n      self.el.innerHTML = ''\n      buildOptions(self.el, value)\n      if (self._watcher) {\n        self.update(self._watcher.value)\n      }\n    } else {\n      _.warn('Invalid options value for v-model: ' + value)\n    }\n  }\n  this.optionWatcher = new Watcher(\n    this.vm,\n    descriptor.expression,\n    optionUpdateWatcher,\n    {\n      deep: true,\n      filters: _.resolveFilters(this.vm, descriptor.filters)\n    }\n  )\n  // update with initial value\n  optionUpdateWatcher(this.optionWatcher.value)\n}\n\n/**\n * Build up option elements. IE9 doesn't create options\n * when setting innerHTML on <select> elements, so we have\n * to use DOM API here.\n *\n * @param {Element} parent - a <select> or an <optgroup>\n * @param {Array} options\n */\n\nfunction buildOptions (parent, options) {\n  var op, el\n  for (var i = 0, l = options.length; i < l; i++) {\n    op = options[i]\n    if (!op.options) {\n      el = document.createElement('option')\n      if (typeof op === 'string') {\n        el.text = el.value = op\n      } else {\n        el.text = op.text\n        el.value = op.value\n      }\n    } else {\n      el = document.createElement('optgroup')\n      el.label = op.label\n      buildOptions(el, op.options)\n    }\n    parent.appendChild(el)\n  }\n}\n\n/**\n * Check the initial value for selected options.\n */\n\nfunction checkInitialValue () {\n  var initValue\n  var options = this.el.options\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (options[i].hasAttribute('selected')) {\n      if (this.multiple) {\n        (initValue || (initValue = []))\n          .push(options[i].value)\n      } else {\n        initValue = options[i].value\n      }\n    }\n  }\n  if (typeof initValue !== 'undefined') {\n    this._initValue = this.number\n      ? _.toNumber(initValue)\n      : initValue\n  }\n}\n\n/**\n * Helper to extract a value array for select[multiple]\n *\n * @param {SelectElement} el\n * @return {Array}\n */\n\nfunction getMultiValue (el) {\n  return Array.prototype.filter\n    .call(el.options, filterSelected)\n    .map(getOptionValue)\n}\n\nfunction filterSelected (op) {\n  return op.selected\n}\n\nfunction getOptionValue (op) {\n  return op.value || op.text\n}\n\n/**\n * Native Array.indexOf uses strict equal, but in this\n * case we need to match string/numbers with soft equal.\n *\n * @param {Array} arr\n * @param {*} val\n */\n\nfunction indexOf (arr, val) {\n  /* jshint eqeqeq: false */\n  var i = arr.length\n  while (i--) {\n    if (arr[i] == val) return i\n  }\n  return -1\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/model/select.js\n ** module id = 48\n ** module chunks = 0\n **/","var _ = require('../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n    this.listener = function () {\n      self.set(el.checked, true)\n    }\n    _.on(el, 'change', this.listener)\n    if (el.checked) {\n      this._initValue = el.checked\n    }\n  },\n\n  update: function (value) {\n    this.el.checked = !!value\n  },\n\n  unbind: function () {\n    _.off(this.el, 'change', this.listener)\n  }\n\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/model/checkbox.js\n ** module id = 49\n ** module chunks = 0\n **/","var _ = require('../util')\nvar isObject = _.isObject\nvar isPlainObject = _.isPlainObject\nvar textParser = require('../parsers/text')\nvar expParser = require('../parsers/expression')\nvar templateParser = require('../parsers/template')\nvar compile = require('../compiler/compile')\nvar transclude = require('../compiler/transclude')\nvar mergeOptions = require('../util/merge-option')\nvar uid = 0\n\nmodule.exports = {\n\n  /**\n   * Setup.\n   */\n\n  bind: function () {\n    // uid as a cache identifier\n    this.id = '__v_repeat_' + (++uid)\n    // we need to insert the objToArray converter\n    // as the first read filter, because it has to be invoked\n    // before any user filters. (can't do it in `update`)\n    if (!this.filters) {\n      this.filters = {}\n    }\n    // add the object -> array convert filter\n    var objectConverter = _.bind(objToArray, this)\n    if (!this.filters.read) {\n      this.filters.read = [objectConverter]\n    } else {\n      this.filters.read.unshift(objectConverter)\n    }\n    // setup ref node\n    this.ref = document.createComment('v-repeat')\n    _.replace(this.el, this.ref)\n    // check if this is a block repeat\n    this.template = this.el.tagName === 'TEMPLATE'\n      ? templateParser.parse(this.el, true)\n      : this.el\n    // check other directives that need to be handled\n    // at v-repeat level\n    this.checkIf()\n    this.checkRef()\n    this.checkComponent()\n    // check for trackby param\n    this.idKey =\n      this._checkParam('track-by') ||\n      this._checkParam('trackby') // 0.11.0 compat\n    this.cache = Object.create(null)\n  },\n\n  /**\n   * Warn against v-if usage.\n   */\n\n  checkIf: function () {\n    if (_.attr(this.el, 'if') !== null) {\n      _.warn(\n        'Don\\'t use v-if with v-repeat. ' +\n        'Use v-show or the \"filterBy\" filter instead.'\n      )\n    }\n  },\n\n  /**\n   * Check if v-ref/ v-el is also present.\n   */\n\n  checkRef: function () {\n    var refID = _.attr(this.el, 'ref')\n    this.refID = refID\n      ? this.vm.$interpolate(refID)\n      : null\n    var elId = _.attr(this.el, 'el')\n    this.elId = elId\n      ? this.vm.$interpolate(elId)\n      : null\n  },\n\n  /**\n   * Check the component constructor to use for repeated\n   * instances. If static we resolve it now, otherwise it\n   * needs to be resolved at build time with actual data.\n   */\n\n  checkComponent: function () {\n    var id = _.attr(this.el, 'component')\n    var options = this.vm.$options\n    if (!id) {\n      // default constructor\n      this.Ctor = _.Vue\n      // inline repeats should inherit\n      this.inherit = true\n      // important: transclude with no options, just\n      // to ensure block start and block end\n      this.template = transclude(this.template)\n      this._linkFn = compile(this.template, options)\n    } else {\n      this.asComponent = true\n      // check inline-template\n      if (this._checkParam('inline-template') !== null) {\n        // extract inline template as a DocumentFragment\n        this.inlineTempalte = _.extractContent(this.el, true)\n      }\n      var tokens = textParser.parse(id)\n      if (!tokens) { // static component\n        var Ctor = this.Ctor = options.components[id]\n        _.assertAsset(Ctor, 'component', id)\n        var merged = mergeOptions(Ctor.options, {}, {\n          $parent: this.vm\n        })\n        merged.template = this.inlineTempalte || merged.template\n        merged._asComponent = true\n        merged._parent = this.vm\n        this.template = transclude(this.template, merged)\n        // Important: mark the template as a root node so that\n        // custom element components don't get compiled twice.\n        // fixes #822\n        this.template.__vue__ = true\n        this._linkFn = compile(this.template, merged)\n      } else {\n        // to be resolved later\n        var ctorExp = textParser.tokensToExp(tokens)\n        this.ctorGetter = expParser.parse(ctorExp).get\n      }\n    }\n  },\n\n  /**\n   * Update.\n   * This is called whenever the Array mutates.\n   *\n   * @param {Array|Number|String} data\n   */\n\n  update: function (data) {\n    data = data || []\n    var type = typeof data\n    if (type === 'number') {\n      data = range(data)\n    } else if (type === 'string') {\n      data = _.toArray(data)\n    }\n    this.vms = this.diff(data, this.vms)\n    // update v-ref\n    if (this.refID) {\n      this.vm.$[this.refID] = this.vms\n    }\n    if (this.elId) {\n      this.vm.$$[this.elId] = this.vms.map(function (vm) {\n        return vm.$el\n      })\n    }\n  },\n\n  /**\n   * Diff, based on new data and old data, determine the\n   * minimum amount of DOM manipulations needed to make the\n   * DOM reflect the new data Array.\n   *\n   * The algorithm diffs the new data Array by storing a\n   * hidden reference to an owner vm instance on previously\n   * seen data. This allows us to achieve O(n) which is\n   * better than a levenshtein distance based algorithm,\n   * which is O(m * n).\n   *\n   * @param {Array} data\n   * @param {Array} oldVms\n   * @return {Array}\n   */\n\n  diff: function (data, oldVms) {\n    var idKey = this.idKey\n    var converted = this.converted\n    var ref = this.ref\n    var alias = this.arg\n    var init = !oldVms\n    var vms = new Array(data.length)\n    var obj, raw, vm, i, l\n    // First pass, go through the new Array and fill up\n    // the new vms array. If a piece of data has a cached\n    // instance for it, we reuse it. Otherwise build a new\n    // instance.\n    for (i = 0, l = data.length; i < l; i++) {\n      obj = data[i]\n      raw = converted ? obj.$value : obj\n      vm = !init && this.getVm(raw)\n      if (vm) { // reusable instance\n        vm._reused = true\n        vm.$index = i // update $index\n        if (converted) {\n          vm.$key = obj.$key // update $key\n        }\n        if (idKey) { // swap track by id data\n          if (alias) {\n            vm[alias] = raw\n          } else {\n            vm._setData(raw)\n          }\n        }\n      } else { // new instance\n        vm = this.build(obj, i, true)\n        vm._new = true\n        vm._reused = false\n      }\n      vms[i] = vm\n      // insert if this is first run\n      if (init) {\n        vm.$before(ref)\n      }\n    }\n    // if this is the first run, we're done.\n    if (init) {\n      return vms\n    }\n    // Second pass, go through the old vm instances and\n    // destroy those who are not reused (and remove them\n    // from cache)\n    for (i = 0, l = oldVms.length; i < l; i++) {\n      vm = oldVms[i]\n      if (!vm._reused) {\n        this.uncacheVm(vm)\n        vm.$destroy(true)\n      }\n    }\n    // final pass, move/insert new instances into the\n    // right place. We're going in reverse here because\n    // insertBefore relies on the next sibling to be\n    // resolved.\n    var targetNext, currentNext\n    i = vms.length\n    while (i--) {\n      vm = vms[i]\n      // this is the vm that we should be in front of\n      targetNext = vms[i + 1]\n      if (!targetNext) {\n        // This is the last item. If it's reused then\n        // everything else will eventually be in the right\n        // place, so no need to touch it. Otherwise, insert\n        // it.\n        if (!vm._reused) {\n          vm.$before(ref)\n        }\n      } else {\n        var nextEl = targetNext.$el\n        if (vm._reused) {\n          // this is the vm we are actually in front of\n          currentNext = findNextVm(vm, ref)\n          // we only need to move if we are not in the right\n          // place already.\n          if (currentNext !== targetNext) {\n            vm.$before(nextEl, null, false)\n          }\n        } else {\n          // new instance, insert to existing next\n          vm.$before(nextEl)\n        }\n      }\n      vm._new = false\n      vm._reused = false\n    }\n    return vms\n  },\n\n  /**\n   * Build a new instance and cache it.\n   *\n   * @param {Object} data\n   * @param {Number} index\n   * @param {Boolean} needCache\n   */\n\n  build: function (data, index, needCache) {\n    var meta = { $index: index }\n    if (this.converted) {\n      meta.$key = data.$key\n    }\n    var raw = this.converted ? data.$value : data\n    var alias = this.arg\n    if (alias) {\n      data = {}\n      data[alias] = raw\n    } else if (!isPlainObject(raw)) {\n      // non-object values\n      data = {}\n      meta.$value = raw\n    } else {\n      // default\n      data = raw\n    }\n    // resolve constructor\n    var Ctor = this.Ctor || this.resolveCtor(data, meta)\n    var vm = this.vm.$addChild({\n      el: templateParser.clone(this.template),\n      _asComponent: this.asComponent,\n      _host: this._host,\n      _linkFn: this._linkFn,\n      _meta: meta,\n      data: data,\n      inherit: this.inherit,\n      template: this.inlineTempalte\n    }, Ctor)\n    // flag this instance as a repeat instance\n    // so that we can skip it in vm._digest\n    vm._repeat = true\n    // cache instance\n    if (needCache) {\n      this.cacheVm(raw, vm)\n    }\n    // sync back changes for $value, particularly for\n    // two-way bindings of primitive values\n    var self = this\n    vm.$watch('$value', function (val) {\n      if (self.converted) {\n        self.rawValue[vm.$key] = val\n      } else {\n        self.rawValue.$set(vm.$index, val)\n      }\n    })\n    return vm\n  },\n\n  /**\n   * Resolve a contructor to use for an instance.\n   * The tricky part here is that there could be dynamic\n   * components depending on instance data.\n   *\n   * @param {Object} data\n   * @param {Object} meta\n   * @return {Function}\n   */\n\n  resolveCtor: function (data, meta) {\n    // create a temporary context object and copy data\n    // and meta properties onto it.\n    // use _.define to avoid accidentally overwriting scope\n    // properties.\n    var context = Object.create(this.vm)\n    var key\n    for (key in data) {\n      _.define(context, key, data[key])\n    }\n    for (key in meta) {\n      _.define(context, key, meta[key])\n    }\n    var id = this.ctorGetter.call(context, context)\n    var Ctor = this.vm.$options.components[id]\n    _.assertAsset(Ctor, 'component', id)\n    return Ctor\n  },\n\n  /**\n   * Unbind, teardown everything\n   */\n\n  unbind: function () {\n    if (this.refID) {\n      this.vm.$[this.refID] = null\n    }\n    if (this.vms) {\n      var i = this.vms.length\n      var vm\n      while (i--) {\n        vm = this.vms[i]\n        this.uncacheVm(vm)\n        vm.$destroy()\n      }\n    }\n  },\n\n  /**\n   * Cache a vm instance based on its data.\n   *\n   * If the data is an object, we save the vm's reference on\n   * the data object as a hidden property. Otherwise we\n   * cache them in an object and for each primitive value\n   * there is an array in case there are duplicates.\n   *\n   * @param {Object} data\n   * @param {Vue} vm\n   */\n\n  cacheVm: function (data, vm) {\n    var idKey = this.idKey\n    var cache = this.cache\n    var id\n    if (idKey) {\n      id = data[idKey]\n      if (!cache[id]) {\n        cache[id] = vm\n      } else {\n        _.warn('Duplicate track-by key in v-repeat: ' + id)\n      }\n    } else if (isObject(data)) {\n      id = this.id\n      if (data.hasOwnProperty(id)) {\n        if (data[id] === null) {\n          data[id] = vm\n        } else {\n          _.warn(\n            'Duplicate objects are not supported in v-repeat ' +\n            'when using components or transitions.'\n          )\n        }\n      } else {\n        _.define(data, this.id, vm)\n      }\n    } else {\n      if (!cache[data]) {\n        cache[data] = [vm]\n      } else {\n        cache[data].push(vm)\n      }\n    }\n    vm._raw = data\n  },\n\n  /**\n   * Try to get a cached instance from a piece of data.\n   *\n   * @param {Object} data\n   * @return {Vue|undefined}\n   */\n\n  getVm: function (data) {\n    if (this.idKey) {\n      return this.cache[data[this.idKey]]\n    } else if (isObject(data)) {\n      return data[this.id]\n    } else {\n      var cached = this.cache[data]\n      if (cached) {\n        var i = 0\n        var vm = cached[i]\n        // since duplicated vm instances might be a reused\n        // one OR a newly created one, we need to return the\n        // first instance that is neither of these.\n        while (vm && (vm._reused || vm._new)) {\n          vm = cached[++i]\n        }\n        return vm\n      }\n    }\n  },\n\n  /**\n   * Delete a cached vm instance.\n   *\n   * @param {Vue} vm\n   */\n\n  uncacheVm: function (vm) {\n    var data = vm._raw\n    if (this.idKey) {\n      this.cache[data[this.idKey]] = null\n    } else if (isObject(data)) {\n      data[this.id] = null\n      vm._raw = null\n    } else {\n      this.cache[data].pop()\n    }\n  }\n\n}\n\n/**\n * Helper to find the next element that is an instance\n * root node. This is necessary because a destroyed vm's\n * element could still be lingering in the DOM before its\n * leaving transition finishes, but its __vue__ reference\n * should have been removed so we can skip them.\n *\n * @param {Vue} vm\n * @param {CommentNode} ref\n * @return {Vue}\n */\n\nfunction findNextVm (vm, ref) {\n  var el = (vm._blockEnd || vm.$el).nextSibling\n  while (!el.__vue__ && el !== ref) {\n    el = el.nextSibling\n  }\n  return el.__vue__\n}\n\n/**\n * Attempt to convert non-Array objects to array.\n * This is the default filter installed to every v-repeat\n * directive.\n *\n * It will be called with **the directive** as `this`\n * context so that we can mark the repeat array as converted\n * from an object.\n *\n * @param {*} obj\n * @return {Array}\n * @private\n */\n\nfunction objToArray (obj) {\n  // regardless of type, store the un-filtered raw value.\n  this.rawValue = obj\n  if (!isPlainObject(obj)) {\n    return obj\n  }\n  var keys = Object.keys(obj)\n  var i = keys.length\n  var res = new Array(i)\n  var key\n  while (i--) {\n    key = keys[i]\n    res[i] = {\n      $key: key,\n      $value: obj[key]\n    }\n  }\n  // `this` points to the repeat directive instance\n  this.converted = true\n  return res\n}\n\n/**\n * Create a range array from given number.\n *\n * @param {Number} n\n * @return {Array}\n */\n\nfunction range (n) {\n  var i = -1\n  var ret = new Array(n)\n  while (++i < n) {\n    ret[i] = i\n  }\n  return ret\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/repeat.js\n ** module id = 50\n ** module chunks = 0\n **/","var _ = require('../util')\nvar compile = require('../compiler/compile')\nvar templateParser = require('../parsers/template')\nvar transition = require('../transition')\n\nmodule.exports = {\n\n  bind: function () {\n    var el = this.el\n    if (!el.__vue__) {\n      this.start = document.createComment('v-if-start')\n      this.end = document.createComment('v-if-end')\n      _.replace(el, this.end)\n      _.before(this.start, this.end)\n      if (el.tagName === 'TEMPLATE') {\n        this.template = templateParser.parse(el, true)\n      } else {\n        this.template = document.createDocumentFragment()\n        this.template.appendChild(templateParser.clone(el))\n      }\n      // compile the nested partial\n      this.linker = compile(\n        this.template,\n        this.vm.$options,\n        true\n      )\n    } else {\n      this.invalid = true\n      _.warn(\n        'v-if=\"' + this.expression + '\" cannot be ' +\n        'used on an already mounted instance.'\n      )\n    }\n  },\n\n  update: function (value) {\n    if (this.invalid) return\n    if (value) {\n      // avoid duplicate compiles, since update() can be\n      // called with different truthy values\n      if (!this.unlink) {\n        var frag = templateParser.clone(this.template)\n        this.compile(frag)\n      }\n    } else {\n      this.teardown()\n    }\n  },\n\n  // NOTE: this function is shared in v-partial\n  compile: function (frag) {\n    var vm = this.vm\n    // the linker is not guaranteed to be present because\n    // this function might get called by v-partial \n    this.unlink = this.linker\n      ? this.linker(vm, frag)\n      : vm.$compile(frag)\n    transition.blockAppend(frag, this.end, vm)\n    // call attached for all the child components created\n    // during the compilation\n    if (_.inDoc(vm.$el)) {\n      var children = this.getContainedComponents()\n      if (children) children.forEach(callAttach)\n    }\n  },\n\n  // NOTE: this function is shared in v-partial\n  teardown: function () {\n    if (!this.unlink) return\n    // collect children beforehand\n    var children\n    if (_.inDoc(this.vm.$el)) {\n      children = this.getContainedComponents()\n    }\n    transition.blockRemove(this.start, this.end, this.vm)\n    if (children) children.forEach(callDetach)\n    this.unlink()\n    this.unlink = null\n  },\n\n  // NOTE: this function is shared in v-partial\n  getContainedComponents: function () {\n    var vm = this.vm\n    var start = this.start.nextSibling\n    var end = this.end\n    var selfCompoents =\n      vm._children.length &&\n      vm._children.filter(contains)\n    var transComponents =\n      vm._transCpnts &&\n      vm._transCpnts.filter(contains)\n\n    function contains (c) {\n      var cur = start\n      var next\n      while (next !== end) {\n        next = cur.nextSibling\n        if (cur.contains(c.$el)) {\n          return true\n        }\n        cur = next\n      }\n      return false\n    }\n\n    return selfCompoents\n      ? transComponents\n        ? selfCompoents.concat(transComponents)\n        : selfCompoents\n      : transComponents\n  },\n\n  // NOTE: this function is shared in v-partial\n  unbind: function () {\n    if (this.unlink) this.unlink()\n  }\n\n}\n\nfunction callAttach (child) {\n  if (!child._isAttached) {\n    child._callHook('attached')\n  }\n}\n\nfunction callDetach (child) {\n  if (child._isAttached) {\n    child._callHook('detached')\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/if.js\n ** module id = 51\n ** module chunks = 0\n **/","var _ = require('../util')\n\nmodule.exports = {\n\n  acceptStatement: true,\n\n  bind: function () {\n    var child = this.el.__vue__\n    if (!child || this.vm !== child.$parent) {\n      _.warn(\n        '`v-events` should only be used on a child component ' +\n        'from the parent template.'\n      )\n      return\n    }\n  },\n\n  update: function (handler, oldHandler) {\n    if (typeof handler !== 'function') {\n      _.warn(\n        'Directive \"v-events:' + this.expression + '\" ' +\n        'expects a function value.'\n      )\n      return\n    }\n    var child = this.el.__vue__\n    if (oldHandler) {\n      child.$off(this.arg, oldHandler)\n    }\n    child.$on(this.arg, handler)\n  }\n\n  // when child is destroyed, all events are turned off,\n  // so no need for unbind here.\n\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/events.js\n ** module id = 52\n ** module chunks = 0\n **/","var _ = require('../util')\n\n/**\n * Stringify value.\n *\n * @param {Number} indent\n */\n\nexports.json = {\n  read: function (value, indent) {\n    return typeof value === 'string'\n      ? value\n      : JSON.stringify(value, null, Number(indent) || 2)\n  },\n  write: function (value) {\n    try {\n      return JSON.parse(value)\n    } catch (e) {\n      return value\n    }\n  }\n}\n\n/**\n * 'abc' => 'Abc'\n */\n\nexports.capitalize = function (value) {\n  if (!value && value !== 0) return ''\n  value = value.toString()\n  return value.charAt(0).toUpperCase() + value.slice(1)\n}\n\n/**\n * 'abc' => 'ABC'\n */\n\nexports.uppercase = function (value) {\n  return (value || value === 0)\n    ? value.toString().toUpperCase()\n    : ''\n}\n\n/**\n * 'AbC' => 'abc'\n */\n\nexports.lowercase = function (value) {\n  return (value || value === 0)\n    ? value.toString().toLowerCase()\n    : ''\n}\n\n/**\n * 12345 => $12,345.00\n *\n * @param {String} sign\n */\n\nvar digitsRE = /(\\d{3})(?=\\d)/g\n\nexports.currency = function (value, sign) {\n  value = parseFloat(value)\n  if (!isFinite(value) || (!value && value !== 0)) return ''\n  sign = sign || '$'\n  var s = Math.floor(Math.abs(value)).toString(),\n    i = s.length % 3,\n    h = i > 0\n      ? (s.slice(0, i) + (s.length > 3 ? ',' : ''))\n      : '',\n    v = Math.abs(parseInt((value * 100) % 100, 10)),\n    f = '.' + (v < 10 ? ('0' + v) : v)\n  return (value < 0 ? '-' : '') +\n    sign + h + s.slice(i).replace(digitsRE, '$1,') + f\n}\n\n/**\n * 'item' => 'items'\n *\n * @params\n *  an array of strings corresponding to\n *  the single, double, triple ... forms of the word to\n *  be pluralized. When the number to be pluralized\n *  exceeds the length of the args, it will use the last\n *  entry in the array.\n *\n *  e.g. ['single', 'double', 'triple', 'multiple']\n */\n\nexports.pluralize = function (value) {\n  var args = _.toArray(arguments, 1)\n  return args.length > 1\n    ? (args[value % 10 - 1] || args[args.length - 1])\n    : (args[0] + (value === 1 ? '' : 's'))\n}\n\n/**\n * A special filter that takes a handler function,\n * wraps it so it only gets triggered on specific\n * keypresses. v-on only.\n *\n * @param {String} key\n */\n\nvar keyCodes = {\n  enter    : 13,\n  tab      : 9,\n  'delete' : 46,\n  up       : 38,\n  left     : 37,\n  right    : 39,\n  down     : 40,\n  esc      : 27\n}\n\nexports.key = function (handler, key) {\n  if (!handler) return\n  var code = keyCodes[key]\n  if (!code) {\n    code = parseInt(key, 10)\n  }\n  return function (e) {\n    if (e.keyCode === code) {\n      return handler.call(this, e)\n    }\n  }\n}\n\n// expose keycode hash\nexports.key.keyCodes = keyCodes\n\n/**\n * Install special array filters\n */\n\n_.extend(exports, require('./array-filters'))\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/filters/index.js\n ** module id = 53\n ** module chunks = 0\n **/","var _ = require('../util')\nvar Path = require('../parsers/path')\n\n/**\n * Filter filter for v-repeat\n *\n * @param {String} searchKey\n * @param {String} [delimiter]\n * @param {String} dataKey\n */\n\nexports.filterBy = function (arr, searchKey, delimiter, dataKey) {\n  // allow optional `in` delimiter\n  // because why not\n  if (delimiter && delimiter !== 'in') {\n    dataKey = delimiter\n  }\n  // get the search string\n  var search =\n    _.stripQuotes(searchKey) ||\n    this.$get(searchKey)\n  if (!search) {\n    return arr\n  }\n  search = ('' + search).toLowerCase()\n  // get the optional dataKey\n  dataKey =\n    dataKey &&\n    (_.stripQuotes(dataKey) || this.$get(dataKey))\n  return arr.filter(function (item) {\n    return dataKey\n      ? contains(Path.get(item, dataKey), search)\n      : contains(item, search)\n  })\n}\n\n/**\n * Filter filter for v-repeat\n *\n * @param {String} sortKey\n * @param {String} reverseKey\n */\n\nexports.orderBy = function (arr, sortKey, reverseKey) {\n  var key =\n    _.stripQuotes(sortKey) ||\n    this.$get(sortKey)\n  if (!key) {\n    return arr\n  }\n  var order = 1\n  if (reverseKey) {\n    if (reverseKey === '-1') {\n      order = -1\n    } else if (reverseKey.charCodeAt(0) === 0x21) { // !\n      reverseKey = reverseKey.slice(1)\n      order = this.$get(reverseKey) ? 1 : -1\n    } else {\n      order = this.$get(reverseKey) ? -1 : 1\n    }\n  }\n  // sort on a copy to avoid mutating original array\n  return arr.slice().sort(function (a, b) {\n    a = _.isObject(a) ? Path.get(a, key) : a\n    b = _.isObject(b) ? Path.get(b, key) : b\n    return a === b ? 0 : a > b ? order : -order\n  })\n}\n\n/**\n * String contain helper\n *\n * @param {*} val\n * @param {String} search\n */\n\nfunction contains (val, search) {\n  if (_.isObject(val)) {\n    for (var key in val) {\n      if (contains(val[key], search)) {\n        return true\n      }\n    }\n  } else if (val != null) {\n    return val.toString().toLowerCase().indexOf(search) > -1\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/filters/array-filters.js\n ** module id = 54\n ** module chunks = 0\n **/","var mergeOptions = require('../util/merge-option')\n\n/**\n * The main init sequence. This is called for every\n * instance, including ones that are created from extended\n * constructors.\n *\n * @param {Object} options - this options object should be\n *                           the result of merging class\n *                           options and the options passed\n *                           in to the constructor.\n */\n\nexports._init = function (options) {\n\n  options = options || {}\n\n  this.$el           = null\n  this.$parent       = options._parent\n  this.$root         = options._root || this\n  this.$             = {} // child vm references\n  this.$$            = {} // element references\n  this._watcherList  = [] // all watchers as an array\n  this._watchers     = {} // internal watchers as a hash\n  this._userWatchers = {} // user watchers as a hash\n  this._directives   = [] // all directives\n\n  // a flag to avoid this being observed\n  this._isVue = true\n\n  // events bookkeeping\n  this._events         = {}    // registered callbacks\n  this._eventsCount    = {}    // for $broadcast optimization\n  this._eventCancelled = false // for event cancellation\n\n  // block instance properties\n  this._isBlock     = false\n  this._blockStart  =          // @type {CommentNode}\n  this._blockEnd    = null     // @type {CommentNode}\n\n  // lifecycle state\n  this._isCompiled  =\n  this._isDestroyed =\n  this._isReady     =\n  this._isAttached  =\n  this._isBeingDestroyed = false\n\n  // children\n  this._children = []\n  this._childCtors = {}\n\n  // transclusion unlink functions\n  this._containerUnlinkFn =\n  this._contentUnlinkFn = null\n\n  // transcluded components that belong to the parent.\n  // need to keep track of them so that we can call\n  // attached/detached hooks on them.\n  this._transCpnts = []\n  this._host = options._host\n\n  // push self into parent / transclusion host\n  if (this.$parent) {\n    this.$parent._children.push(this)\n  }\n  if (this._host) {\n    this._host._transCpnts.push(this)\n  }\n\n  // props used in v-repeat diffing\n  this._new = true\n  this._reused = false\n\n  // merge options.\n  options = this.$options = mergeOptions(\n    this.constructor.options,\n    options,\n    this\n  )\n\n  // set data after merge.\n  this._data = options.data || {}\n\n  // initialize data observation and scope inheritance.\n  this._initScope()\n\n  // setup event system and option events.\n  this._initEvents()\n\n  // call created hook\n  this._callHook('created')\n\n  // if `el` option is passed, start compilation.\n  if (options.el) {\n    this.$mount(options.el)\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/instance/init.js\n ** module id = 55\n ** module chunks = 0\n **/","var _ = require('../util')\nvar inDoc = _.inDoc\n\n/**\n * Setup the instance's option events & watchers.\n * If the value is a string, we pull it from the\n * instance's methods by name.\n */\n\nexports._initEvents = function () {\n  var options = this.$options\n  registerCallbacks(this, '$on', options.events)\n  registerCallbacks(this, '$watch', options.watch)\n}\n\n/**\n * Register callbacks for option events and watchers.\n *\n * @param {Vue} vm\n * @param {String} action\n * @param {Object} hash\n */\n\nfunction registerCallbacks (vm, action, hash) {\n  if (!hash) return\n  var handlers, key, i, j\n  for (key in hash) {\n    handlers = hash[key]\n    if (_.isArray(handlers)) {\n      for (i = 0, j = handlers.length; i < j; i++) {\n        register(vm, action, key, handlers[i])\n      }\n    } else {\n      register(vm, action, key, handlers)\n    }\n  }\n}\n\n/**\n * Helper to register an event/watch callback.\n *\n * @param {Vue} vm\n * @param {String} action\n * @param {String} key\n * @param {*} handler\n */\n\nfunction register (vm, action, key, handler) {\n  var type = typeof handler\n  if (type === 'function') {\n    vm[action](key, handler)\n  } else if (type === 'string') {\n    var methods = vm.$options.methods\n    var method = methods && methods[handler]\n    if (method) {\n      vm[action](key, method)\n    } else {\n      _.warn(\n        'Unknown method: \"' + handler + '\" when ' +\n        'registering callback for ' + action +\n        ': \"' + key + '\".'\n      )\n    }\n  }\n}\n\n/**\n * Setup recursive attached/detached calls\n */\n\nexports._initDOMHooks = function () {\n  this.$on('hook:attached', onAttached)\n  this.$on('hook:detached', onDetached)\n}\n\n/**\n * Callback to recursively call attached hook on children\n */\n\nfunction onAttached () {\n  this._isAttached = true\n  this._children.forEach(callAttach)\n  if (this._transCpnts.length) {\n    this._transCpnts.forEach(callAttach)\n  }\n}\n\n/**\n * Iterator to call attached hook\n * \n * @param {Vue} child\n */\n\nfunction callAttach (child) {\n  if (!child._isAttached && inDoc(child.$el)) {\n    child._callHook('attached')\n  }\n}\n\n/**\n * Callback to recursively call detached hook on children\n */\n\nfunction onDetached () {\n  this._isAttached = false\n  this._children.forEach(callDetach)\n  if (this._transCpnts.length) {\n    this._transCpnts.forEach(callDetach)\n  }\n}\n\n/**\n * Iterator to call detached hook\n * \n * @param {Vue} child\n */\n\nfunction callDetach (child) {\n  if (child._isAttached && !inDoc(child.$el)) {\n    child._callHook('detached')\n  }\n}\n\n/**\n * Trigger all handlers for a hook\n *\n * @param {String} hook\n */\n\nexports._callHook = function (hook) {\n  var handlers = this.$options[hook]\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      handlers[i].call(this)\n    }\n  }\n  this.$emit('hook:' + hook)\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/instance/events.js\n ** module id = 56\n ** module chunks = 0\n **/","var _ = require('../util')\nvar Observer = require('../observer')\nvar Dep = require('../observer/dep')\n\n/**\n * Setup the scope of an instance, which contains:\n * - observed data\n * - computed properties\n * - user methods\n * - meta properties\n */\n\nexports._initScope = function () {\n  this._initData()\n  this._initComputed()\n  this._initMethods()\n  this._initMeta()\n}\n\n/**\n * Initialize the data. \n */\n\nexports._initData = function () {\n  // proxy data on instance\n  var data = this._data\n  var keys = Object.keys(data)\n  var i = keys.length\n  var key\n  while (i--) {\n    key = keys[i]\n    if (!_.isReserved(key)) {\n      this._proxy(key)\n    }\n  }\n  // observe data\n  Observer.create(data).addVm(this)\n}\n\n/**\n * Swap the isntance's $data. Called in $data's setter.\n *\n * @param {Object} newData\n */\n\nexports._setData = function (newData) {\n  newData = newData || {}\n  var oldData = this._data\n  this._data = newData\n  var keys, key, i\n  // unproxy keys not present in new data\n  keys = Object.keys(oldData)\n  i = keys.length\n  while (i--) {\n    key = keys[i]\n    if (!_.isReserved(key) && !(key in newData)) {\n      this._unproxy(key)\n    }\n  }\n  // proxy keys not already proxied,\n  // and trigger change for changed values\n  keys = Object.keys(newData)\n  i = keys.length\n  while (i--) {\n    key = keys[i]\n    if (!this.hasOwnProperty(key) && !_.isReserved(key)) {\n      // new property\n      this._proxy(key)\n    }\n  }\n  oldData.__ob__.removeVm(this)\n  Observer.create(newData).addVm(this)\n  this._digest()\n}\n\n/**\n * Proxy a property, so that\n * vm.prop === vm._data.prop\n *\n * @param {String} key\n */\n\nexports._proxy = function (key) {\n  // need to store ref to self here\n  // because these getter/setters might\n  // be called by child instances!\n  var self = this\n  Object.defineProperty(self, key, {\n    configurable: true,\n    enumerable: true,\n    get: function proxyGetter () {\n      return self._data[key]\n    },\n    set: function proxySetter (val) {\n      self._data[key] = val\n    }\n  })\n}\n\n/**\n * Unproxy a property.\n *\n * @param {String} key\n */\n\nexports._unproxy = function (key) {\n  delete this[key]\n}\n\n/**\n * Force update on every watcher in scope.\n */\n\nexports._digest = function () {\n  var i = this._watcherList.length\n  while (i--) {\n    this._watcherList[i].update()\n  }\n  var children = this._children\n  i = children.length\n  while (i--) {\n    var child = children[i]\n    if (child.$options.inherit) {\n      child._digest()\n    }\n  }\n}\n\n/**\n * Setup computed properties. They are essentially\n * special getter/setters\n */\n\nfunction noop () {}\nexports._initComputed = function () {\n  var computed = this.$options.computed\n  if (computed) {\n    for (var key in computed) {\n      var userDef = computed[key]\n      var def = {\n        enumerable: true,\n        configurable: true\n      }\n      if (typeof userDef === 'function') {\n        def.get = _.bind(userDef, this)\n        def.set = noop\n      } else {\n        def.get = userDef.get\n          ? _.bind(userDef.get, this)\n          : noop\n        def.set = userDef.set\n          ? _.bind(userDef.set, this)\n          : noop\n      }\n      Object.defineProperty(this, key, def)\n    }\n  }\n}\n\n/**\n * Setup instance methods. Methods must be bound to the\n * instance since they might be called by children\n * inheriting them.\n */\n\nexports._initMethods = function () {\n  var methods = this.$options.methods\n  if (methods) {\n    for (var key in methods) {\n      this[key] = _.bind(methods[key], this)\n    }\n  }\n}\n\n/**\n * Initialize meta information like $index, $key & $value.\n */\n\nexports._initMeta = function () {\n  var metas = this.$options._meta\n  if (metas) {\n    for (var key in metas) {\n      this._defineMeta(key, metas[key])\n    }\n  }\n}\n\n/**\n * Define a meta property, e.g $index, $key, $value\n * which only exists on the vm instance but not in $data.\n *\n * @param {String} key\n * @param {*} value\n */\n\nexports._defineMeta = function (key, value) {\n  var dep = new Dep()\n  Object.defineProperty(this, key, {\n    enumerable: true,\n    configurable: true,\n    get: function metaGetter () {\n      if (Observer.target) {\n        Observer.target.addDep(dep)\n      }\n      return value\n    },\n    set: function metaSetter (val) {\n      if (val !== value) {\n        value = val\n        dep.notify()\n      }\n    }\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/instance/scope.js\n ** module id = 57\n ** module chunks = 0\n **/","var _ = require('../util')\nvar Watcher = require('../watcher')\nvar Path = require('../parsers/path')\nvar textParser = require('../parsers/text')\nvar dirParser = require('../parsers/directive')\nvar expParser = require('../parsers/expression')\nvar filterRE = /[^|]\\|[^|]/\n\n/**\n * Get the value from an expression on this vm.\n *\n * @param {String} exp\n * @return {*}\n */\n\nexports.$get = function (exp) {\n  var res = expParser.parse(exp)\n  if (res) {\n    try {\n      return res.get.call(this, this)\n    } catch (e) {}\n  }\n}\n\n/**\n * Set the value from an expression on this vm.\n * The expression must be a valid left-hand\n * expression in an assignment.\n *\n * @param {String} exp\n * @param {*} val\n */\n\nexports.$set = function (exp, val) {\n  var res = expParser.parse(exp, true)\n  if (res && res.set) {\n    res.set.call(this, this, val)\n  }\n}\n\n/**\n * Add a property on the VM\n *\n * @param {String} key\n * @param {*} val\n */\n\nexports.$add = function (key, val) {\n  this._data.$add(key, val)\n}\n\n/**\n * Delete a property on the VM\n *\n * @param {String} key\n */\n\nexports.$delete = function (key) {\n  this._data.$delete(key)\n}\n\n/**\n * Watch an expression, trigger callback when its\n * value changes.\n *\n * @param {String} exp\n * @param {Function} cb\n * @param {Boolean} [deep]\n * @param {Boolean} [immediate]\n * @return {Function} - unwatchFn\n */\n\nexports.$watch = function (exp, cb, deep, immediate) {\n  var vm = this\n  var key = deep ? exp + '**deep**' : exp\n  var watcher = vm._userWatchers[key]\n  var wrappedCb = function (val, oldVal) {\n    cb.call(vm, val, oldVal)\n  }\n  if (!watcher) {\n    watcher = vm._userWatchers[key] =\n      new Watcher(vm, exp, wrappedCb, {\n        deep: deep,\n        user: true\n      })\n  } else {\n    watcher.addCb(wrappedCb)\n  }\n  if (immediate) {\n    wrappedCb(watcher.value)\n  }\n  return function unwatchFn () {\n    watcher.removeCb(wrappedCb)\n    if (!watcher.active) {\n      vm._userWatchers[key] = null\n    }\n  }\n}\n\n/**\n * Evaluate a text directive, including filters.\n *\n * @param {String} text\n * @return {String}\n */\n\nexports.$eval = function (text) {\n  // check for filters.\n  if (filterRE.test(text)) {\n    var dir = dirParser.parse(text)[0]\n    // the filter regex check might give false positive\n    // for pipes inside strings, so it's possible that\n    // we don't get any filters here\n    return dir.filters\n      ? _.applyFilters(\n          this.$get(dir.expression),\n          _.resolveFilters(this, dir.filters).read,\n          this\n        )\n      : this.$get(dir.expression)\n  } else {\n    // no filter\n    return this.$get(text)\n  }\n}\n\n/**\n * Interpolate a piece of template text.\n *\n * @param {String} text\n * @return {String}\n */\n\nexports.$interpolate = function (text) {\n  var tokens = textParser.parse(text)\n  var vm = this\n  if (tokens) {\n    return tokens.length === 1\n      ? vm.$eval(tokens[0].value)\n      : tokens.map(function (token) {\n          return token.tag\n            ? vm.$eval(token.value)\n            : token.value\n        }).join('')\n  } else {\n    return text\n  }\n}\n\n/**\n * Log instance data as a plain JS object\n * so that it is easier to inspect in console.\n * This method assumes console is available.\n *\n * @param {String} [path]\n */\n\nexports.$log = function (path) {\n  var data = path\n    ? Path.get(this._data, path)\n    : this._data\n  if (data) {\n    data = JSON.parse(JSON.stringify(data))\n  }\n  console.log(data)\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/api/data.js\n ** module id = 59\n ** module chunks = 0\n **/","var _ = require('../util')\nvar transition = require('../transition')\n\n/**\n * Append instance to target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$appendTo = function (target, cb, withTransition) {\n  return insert(\n    this, target, cb, withTransition,\n    append, transition.append\n  )\n}\n\n/**\n * Prepend instance to target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$prependTo = function (target, cb, withTransition) {\n  target = query(target)\n  if (target.hasChildNodes()) {\n    this.$before(target.firstChild, cb, withTransition)\n  } else {\n    this.$appendTo(target, cb, withTransition)\n  }\n  return this\n}\n\n/**\n * Insert instance before target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$before = function (target, cb, withTransition) {\n  return insert(\n    this, target, cb, withTransition,\n    before, transition.before\n  )\n}\n\n/**\n * Insert instance after target\n *\n * @param {Node} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$after = function (target, cb, withTransition) {\n  target = query(target)\n  if (target.nextSibling) {\n    this.$before(target.nextSibling, cb, withTransition)\n  } else {\n    this.$appendTo(target.parentNode, cb, withTransition)\n  }\n  return this\n}\n\n/**\n * Remove instance from DOM\n *\n * @param {Function} [cb]\n * @param {Boolean} [withTransition] - defaults to true\n */\n\nexports.$remove = function (cb, withTransition) {\n  var inDoc = this._isAttached && _.inDoc(this.$el)\n  // if we are not in document, no need to check\n  // for transitions\n  if (!inDoc) withTransition = false\n  var op\n  var self = this\n  var realCb = function () {\n    if (inDoc) self._callHook('detached')\n    if (cb) cb()\n  }\n  if (\n    this._isBlock &&\n    !this._blockFragment.hasChildNodes()\n  ) {\n    op = withTransition === false\n      ? append\n      : transition.removeThenAppend\n    blockOp(this, this._blockFragment, op, realCb)\n  } else {\n    op = withTransition === false\n      ? remove\n      : transition.remove\n    op(this.$el, this, realCb)\n  }\n  return this\n}\n\n/**\n * Shared DOM insertion function.\n *\n * @param {Vue} vm\n * @param {Element} target\n * @param {Function} [cb]\n * @param {Boolean} [withTransition]\n * @param {Function} op1 - op for non-transition insert\n * @param {Function} op2 - op for transition insert\n * @return vm\n */\n\nfunction insert (vm, target, cb, withTransition, op1, op2) {\n  target = query(target)\n  var targetIsDetached = !_.inDoc(target)\n  var op = withTransition === false || targetIsDetached\n    ? op1\n    : op2\n  var shouldCallHook =\n    !targetIsDetached &&\n    !vm._isAttached &&\n    !_.inDoc(vm.$el)\n  if (vm._isBlock) {\n    blockOp(vm, target, op, cb)\n  } else {\n    op(vm.$el, target, vm, cb)\n  }\n  if (shouldCallHook) {\n    vm._callHook('attached')\n  }\n  return vm\n}\n\n/**\n * Execute a transition operation on a block instance,\n * iterating through all its block nodes.\n *\n * @param {Vue} vm\n * @param {Node} target\n * @param {Function} op\n * @param {Function} cb\n */\n\nfunction blockOp (vm, target, op, cb) {\n  var current = vm._blockStart\n  var end = vm._blockEnd\n  var next\n  while (next !== end) {\n    next = current.nextSibling\n    op(current, target, vm)\n    current = next\n  }\n  op(end, target, vm, cb)\n}\n\n/**\n * Check for selectors\n *\n * @param {String|Element} el\n */\n\nfunction query (el) {\n  return typeof el === 'string'\n    ? document.querySelector(el)\n    : el\n}\n\n/**\n * Append operation that takes a callback.\n *\n * @param {Node} el\n * @param {Node} target\n * @param {Vue} vm - unused\n * @param {Function} [cb]\n */\n\nfunction append (el, target, vm, cb) {\n  target.appendChild(el)\n  if (cb) cb()\n}\n\n/**\n * InsertBefore operation that takes a callback.\n *\n * @param {Node} el\n * @param {Node} target\n * @param {Vue} vm - unused\n * @param {Function} [cb]\n */\n\nfunction before (el, target, vm, cb) {\n  _.before(el, target)\n  if (cb) cb()\n}\n\n/**\n * Remove operation that takes a callback.\n *\n * @param {Node} el\n * @param {Vue} vm - unused\n * @param {Function} [cb]\n */\n\nfunction remove (el, vm, cb) {\n  _.remove(el)\n  if (cb) cb()\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/api/dom.js\n ** module id = 60\n ** module chunks = 0\n **/","var _ = require('../util')\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n */\n\nexports.$on = function (event, fn) {\n  (this._events[event] || (this._events[event] = []))\n    .push(fn)\n  modifyListenerCount(this, event, 1)\n  return this\n}\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n */\n\nexports.$once = function (event, fn) {\n  var self = this\n  function on () {\n    self.$off(event, on)\n    fn.apply(this, arguments)\n  }\n  on.fn = fn\n  this.$on(event, on)\n  return this\n}\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n */\n\nexports.$off = function (event, fn) {\n  var cbs\n  // all\n  if (!arguments.length) {\n    if (this.$parent) {\n      for (event in this._events) {\n        cbs = this._events[event]\n        if (cbs) {\n          modifyListenerCount(this, event, -cbs.length)\n        }\n      }\n    }\n    this._events = {}\n    return this\n  }\n  // specific event\n  cbs = this._events[event]\n  if (!cbs) {\n    return this\n  }\n  if (arguments.length === 1) {\n    modifyListenerCount(this, event, -cbs.length)\n    this._events[event] = null\n    return this\n  }\n  // specific handler\n  var cb\n  var i = cbs.length\n  while (i--) {\n    cb = cbs[i]\n    if (cb === fn || cb.fn === fn) {\n      modifyListenerCount(this, event, -1)\n      cbs.splice(i, 1)\n      break\n    }\n  }\n  return this\n}\n\n/**\n * Trigger an event on self.\n *\n * @param {String} event\n */\n\nexports.$emit = function (event) {\n  this._eventCancelled = false\n  var cbs = this._events[event]\n  if (cbs) {\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length - 1\n    var args = new Array(i)\n    while (i--) {\n      args[i] = arguments[i + 1]\n    }\n    i = 0\n    cbs = cbs.length > 1\n      ? _.toArray(cbs)\n      : cbs\n    for (var l = cbs.length; i < l; i++) {\n      if (cbs[i].apply(this, args) === false) {\n        this._eventCancelled = true\n      }\n    }\n  }\n  return this\n}\n\n/**\n * Recursively broadcast an event to all children instances.\n *\n * @param {String} event\n * @param {...*} additional arguments\n */\n\nexports.$broadcast = function (event) {\n  // if no child has registered for this event,\n  // then there's no need to broadcast.\n  if (!this._eventsCount[event]) return\n  var children = this._children\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i]\n    child.$emit.apply(child, arguments)\n    if (!child._eventCancelled) {\n      child.$broadcast.apply(child, arguments)\n    }\n  }\n  return this\n}\n\n/**\n * Recursively propagate an event up the parent chain.\n *\n * @param {String} event\n * @param {...*} additional arguments\n */\n\nexports.$dispatch = function () {\n  var parent = this.$parent\n  while (parent) {\n    parent.$emit.apply(parent, arguments)\n    parent = parent._eventCancelled\n      ? null\n      : parent.$parent\n  }\n  return this\n}\n\n/**\n * Modify the listener counts on all parents.\n * This bookkeeping allows $broadcast to return early when\n * no child has listened to a certain event.\n *\n * @param {Vue} vm\n * @param {String} event\n * @param {Number} count\n */\n\nvar hookRE = /^hook:/\nfunction modifyListenerCount (vm, event, count) {\n  var parent = vm.$parent\n  // hooks do not get broadcasted so no need\n  // to do bookkeeping for them\n  if (!parent || !count || hookRE.test(event)) return\n  while (parent) {\n    parent._eventsCount[event] =\n      (parent._eventsCount[event] || 0) + count\n    parent = parent.$parent\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/api/events.js\n ** module id = 61\n ** module chunks = 0\n **/","var _ = require('../util')\n\n/**\n * Create a child instance that prototypally inehrits\n * data on parent. To achieve that we create an intermediate\n * constructor with its prototype pointing to parent.\n *\n * @param {Object} opts\n * @param {Function} [BaseCtor]\n * @return {Vue}\n * @public\n */\n\nexports.$addChild = function (opts, BaseCtor) {\n  BaseCtor = BaseCtor || _.Vue\n  opts = opts || {}\n  var parent = this\n  var ChildVue\n  var inherit = opts.inherit !== undefined\n    ? opts.inherit\n    : BaseCtor.options.inherit\n  if (inherit) {\n    var ctors = parent._childCtors\n    ChildVue = ctors[BaseCtor.cid]\n    if (!ChildVue) {\n      var optionName = BaseCtor.options.name\n      var className = optionName\n        ? _.classify(optionName)\n        : 'VueComponent'\n      ChildVue = new Function(\n        'return function ' + className + ' (options) {' +\n        'this.constructor = ' + className + ';' +\n        'this._init(options) }'\n      )()\n      ChildVue.options = BaseCtor.options\n      ChildVue.prototype = this\n      ctors[BaseCtor.cid] = ChildVue\n    }\n  } else {\n    ChildVue = BaseCtor\n  }\n  opts._parent = parent\n  opts._root = parent.$root\n  var child = new ChildVue(opts)\n  return child\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/api/child.js\n ** module id = 62\n ** module chunks = 0\n **/","var _ = require('../util')\nvar compile = require('../compiler/compile')\n\n/**\n * Set instance target element and kick off the compilation\n * process. The passed in `el` can be a selector string, an\n * existing Element, or a DocumentFragment (for block\n * instances).\n *\n * @param {Element|DocumentFragment|string} el\n * @public\n */\n\nexports.$mount = function (el) {\n  if (this._isCompiled) {\n    _.warn('$mount() should be called only once.')\n    return\n  }\n  if (!el) {\n    el = document.createElement('div')\n  } else if (typeof el === 'string') {\n    var selector = el\n    el = document.querySelector(el)\n    if (!el) {\n      _.warn('Cannot find element: ' + selector)\n      return\n    }\n  }\n  this._compile(el)\n  this._isCompiled = true\n  this._callHook('compiled')\n  if (_.inDoc(this.$el)) {\n    this._callHook('attached')\n    this._initDOMHooks()\n    ready.call(this)\n  } else {\n    this._initDOMHooks()\n    this.$once('hook:attached', ready)\n  }\n  return this\n}\n\n/**\n * Mark an instance as ready.\n */\n\nfunction ready () {\n  this._isAttached = true\n  this._isReady = true\n  this._callHook('ready')\n}\n\n/**\n * Teardown the instance, simply delegate to the internal\n * _destroy.\n */\n\nexports.$destroy = function (remove, deferCleanup) {\n  this._destroy(remove, deferCleanup)\n}\n\n/**\n * Partially compile a piece of DOM and return a\n * decompile function.\n *\n * @param {Element|DocumentFragment} el\n * @return {Function}\n */\n\nexports.$compile = function (el) {\n  return compile(el, this.$options, true)(this, el)\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/api/lifecycle.js\n ** module id = 63\n ** module chunks = 0\n **/","var Vue = require('../../../../src/vue')\nvar _ = require('../../../../src/util')\nvar nextTick = _.nextTick\n\ndescribe('Data API', function () {\n\n  var vm\n  beforeEach(function () {\n    spyOn(_, 'warn')\n    vm = new Vue({\n      data: {\n        a: 1,\n        b: {\n          c: 2\n        }\n      },\n      filters: {\n        double: function (v) {\n          return v * 2\n        }\n      }\n    })\n  })\n\n  it('$get', function () {\n    expect(vm.$get('a')).toBe(1)\n    expect(vm.$get('b[\"c\"]')).toBe(2)\n    expect(vm.$get('a + b.c')).toBe(3)\n    expect(vm.$get('c')).toBeUndefined()\n    // invalid, should warn\n    vm.$get('a(')\n    expect(_.warn).toHaveBeenCalled()\n  })\n\n  it('$set', function () {\n    vm.$set('a', 2)\n    expect(vm.a).toBe(2)\n    vm.$set('b[\"c\"]', 3)\n    expect(vm.b.c).toBe(3)\n    // setting unexisting\n    vm.$set('c.d', 2)\n    expect(vm.c.d).toBe(2)\n    // invalid, should throw\n    if (leftHandThrows()) {\n      // if creating a function with invalid left hand\n      // expression throws, the exp parser will catch the \n      // error and warn.\n      vm.$set('c + d', 1)\n      expect(_.warn).toHaveBeenCalled()\n    } else {\n      // otherwise it will throw when calling the setter.\n      expect(function () {\n        try {\n          vm.$set('c + d', 1)\n        } catch (e) {\n          return true\n        }\n      }()).toBe(true)\n    }\n  })\n\n  it('$add', function () {\n    vm._digest = jasmine.createSpy()\n    vm.$add('c', 1)\n    expect(vm.c).toBe(1)\n    expect(vm._data.c).toBe(1)\n    expect(vm._digest).toHaveBeenCalled()\n    // reserved key should not be proxied\n    vm.$add('_c', 1)\n    expect(vm._c).toBeUndefined()\n  })\n\n  it('$delete', function () {\n    vm._digest = jasmine.createSpy()\n    vm.$delete('a')\n    expect(vm.hasOwnProperty('a')).toBe(false)\n    expect(vm._data.hasOwnProperty('a')).toBe(false)\n    expect(vm._digest).toHaveBeenCalled()\n    // reserved key should not be deleted\n    vm.$delete('_data')\n    expect(vm._data).toBeTruthy()\n  })\n\n  it('$watch', function (done) {\n    var spy = jasmine.createSpy()\n    // test immediate invoke\n    var unwatch = vm.$watch('a + b.c', spy, false, true)\n    expect(spy).toHaveBeenCalledWith(3, undefined)\n    vm.a = 2\n    nextTick(function () {\n      expect(spy).toHaveBeenCalledWith(4, 3)\n      // reuse same watcher\n      var spy2 = jasmine.createSpy()\n      var unwatch2 = vm.$watch('a + b.c', spy2)\n      expect(vm._watcherList.length).toBe(1)\n      vm.b = { c: 3 }\n      nextTick(function () {\n        expect(spy).toHaveBeenCalledWith(5, 4)\n        expect(spy2).toHaveBeenCalledWith(5, 4)\n        // unwatch\n        unwatch()\n        unwatch2()\n        vm.a = 3\n        nextTick(function () {\n          expect(spy.calls.count()).toBe(3)\n          expect(spy2.calls.count()).toBe(1)\n          done()\n        })\n      })\n    })\n  })\n\n  it('deep $watch', function (done) {\n    var oldB = vm.b\n    var spy = jasmine.createSpy()\n    vm.$watch('b', spy, true)\n    vm.b.c = 3\n    nextTick(function () {\n      expect(spy).toHaveBeenCalledWith(oldB, oldB)\n      vm.b = { c: 4 }\n      nextTick(function () {\n        expect(spy).toHaveBeenCalledWith(vm.b, oldB)\n        done()\n      })\n    })\n  })\n\n  it('$eval', function () {\n    expect(vm.$eval('a')).toBe(1)\n    expect(vm.$eval('b.c')).toBe(2)\n    expect(vm.$eval('a + b.c | double')).toBe(6)\n  })\n\n  it('$interpolate', function () {\n    expect(vm.$interpolate('abc')).toBe('abc')\n    expect(vm.$interpolate('{{a}} and {{a + b.c | double}}')).toBe('1 and 6')\n  })\n\n  if (typeof console !== 'undefined') {\n    it('$log', function () {\n      var oldLog = console.log\n      var spy = jasmine.createSpy()\n      console.log = function (val) {\n        expect(val.a).toBe(1)\n        expect(val.b.c).toBe(2)\n        spy()\n      }\n      vm.$log()\n      expect(spy.calls.count()).toBe(1)\n      console.log = function (val) {\n        expect(val.c).toBe(2)\n        spy()\n      }\n      vm.$log('b')\n      expect(spy.calls.count()).toBe(2)\n      console.log = oldLog\n    })\n  }\n\n})\n\n/**\n * check if creating a new Function with invalid left-hand\n * assignment would throw\n */\n\nfunction leftHandThrows () {\n  try {\n    var fn = new Function('a + b = 1')\n  } catch (e) {\n    return true\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/api/data_spec.js\n ** module id = 64\n ** module chunks = 0\n **/","/**\n * We are not testing transition-related stuff here,\n * those are tested in transition_spec.js.\n */\n\nvar Vue = require('../../../../src/vue')\nvar _ = require('../../../../src/util')\n\nif (_.inBrowser) {\n  describe('DOM API', function () {\n\n    var vm, vm2, parent, target, sibling, empty, spy\n    beforeEach(function () {\n      spy = jasmine.createSpy('dom')\n      parent = document.createElement('div')\n      target = document.createElement('div')\n      sibling = document.createElement('div')\n      empty = document.createElement('div')\n      parent.appendChild(target)\n      parent.appendChild(sibling)\n      var el = document.createElement('div')\n      vm = new Vue({ el: el })\n      // block instance\n      var frag = document.createDocumentFragment()\n      frag.appendChild(document.createElement('p'))\n      frag.appendChild(document.createElement('span'))\n      vm2 = new Vue({\n        el: frag\n      })\n    })\n    \n    describe('$appendTo', function () {\n      \n      it('normal instance', function () {\n        vm.$appendTo(parent, spy)\n        expect(parent.childNodes.length).toBe(3)\n        expect(parent.lastChild).toBe(vm.$el)\n        expect(spy.calls.count()).toBe(1)\n      })\n\n      it('block instance', function () {\n        vm2.$appendTo(parent, spy)\n        expect(parent.childNodes.length).toBe(6)\n        expect(parent.childNodes[2]).toBe(vm2._blockStart)\n        expect(parent.childNodes[2]).toBe(vm2.$el)\n        expect(parent.childNodes[3].tagName).toBe('P')\n        expect(parent.childNodes[4].tagName).toBe('SPAN')\n        expect(parent.childNodes[5]).toBe(vm2._blockEnd)\n        expect(spy.calls.count()).toBe(1)\n      })\n\n    })\n\n    describe('$prependTo', function () {\n      \n      it('normal instance', function () {\n        vm.$prependTo(parent, spy)\n        expect(parent.childNodes.length).toBe(3)\n        expect(parent.firstChild).toBe(vm.$el)\n        expect(spy.calls.count()).toBe(1)\n        vm.$prependTo(empty, spy)\n        expect(empty.childNodes.length).toBe(1)\n        expect(empty.firstChild).toBe(vm.$el)\n        expect(spy.calls.count()).toBe(2)\n      })\n\n      it('block instance', function () {\n        vm2.$prependTo(parent, spy)\n        expect(parent.childNodes.length).toBe(6)\n        expect(parent.childNodes[0]).toBe(vm2._blockStart)\n        expect(parent.childNodes[0]).toBe(vm2.$el)\n        expect(parent.childNodes[1].tagName).toBe('P')\n        expect(parent.childNodes[2].tagName).toBe('SPAN')\n        expect(parent.childNodes[3]).toBe(vm2._blockEnd)\n        expect(spy.calls.count()).toBe(1)\n        // empty\n        vm2.$prependTo(empty, spy)\n        expect(empty.childNodes.length).toBe(4)\n        expect(empty.childNodes[0]).toBe(vm2._blockStart)\n        expect(empty.childNodes[0]).toBe(vm2.$el)\n        expect(empty.childNodes[1].tagName).toBe('P')\n        expect(empty.childNodes[2].tagName).toBe('SPAN')\n        expect(empty.childNodes[3]).toBe(vm2._blockEnd)\n        expect(spy.calls.count()).toBe(2)\n      })\n\n    })\n\n    describe('$before', function () {\n      \n      it('normal instance', function () {\n        vm.$before(sibling, spy)\n        expect(parent.childNodes.length).toBe(3)\n        expect(parent.childNodes[1]).toBe(vm.$el)\n        expect(spy.calls.count()).toBe(1)\n      })\n\n      it('block instance', function () {\n        vm2.$before(sibling, spy)\n        expect(parent.childNodes.length).toBe(6)\n        expect(parent.childNodes[1]).toBe(vm2._blockStart)\n        expect(parent.childNodes[1]).toBe(vm2.$el)\n        expect(parent.childNodes[2].tagName).toBe('P')\n        expect(parent.childNodes[3].tagName).toBe('SPAN')\n        expect(parent.childNodes[4]).toBe(vm2._blockEnd)\n        expect(spy.calls.count()).toBe(1)\n      })\n\n    })\n\n    describe('$after', function () {\n      \n      it('normal instance', function () {\n        vm.$after(target, spy)\n        expect(parent.childNodes.length).toBe(3)\n        expect(parent.childNodes[1]).toBe(vm.$el)\n        expect(spy.calls.count()).toBe(1)\n      })\n\n      it('normal instance no next sibling', function () {\n        vm.$after(sibling, spy)\n        expect(parent.childNodes.length).toBe(3)\n        expect(parent.lastChild).toBe(vm.$el)\n        expect(spy.calls.count()).toBe(1)\n      })\n\n      it('block instance', function () {\n        vm2.$after(target, spy)\n        expect(parent.childNodes.length).toBe(6)\n        expect(parent.childNodes[1]).toBe(vm2._blockStart)\n        expect(parent.childNodes[1]).toBe(vm2.$el)\n        expect(parent.childNodes[2].tagName).toBe('P')\n        expect(parent.childNodes[3].tagName).toBe('SPAN')\n        expect(parent.childNodes[4]).toBe(vm2._blockEnd)\n        expect(spy.calls.count()).toBe(1)\n      })\n\n      it('block instance no next sibling', function () {\n        vm2.$after(sibling, spy)\n        expect(parent.childNodes.length).toBe(6)\n        expect(parent.childNodes[2]).toBe(vm2._blockStart)\n        expect(parent.childNodes[2]).toBe(vm2.$el)\n        expect(parent.childNodes[3].tagName).toBe('P')\n        expect(parent.childNodes[4].tagName).toBe('SPAN')\n        expect(parent.childNodes[5]).toBe(vm2._blockEnd)\n        expect(spy.calls.count()).toBe(1)\n      })\n\n    })\n\n    describe('$remove', function () {\n      \n      it('normal instance', function () {\n        vm.$before(sibling)\n        expect(parent.childNodes.length).toBe(3)\n        expect(parent.childNodes[1]).toBe(vm.$el)\n        vm.$remove(spy)\n        expect(parent.childNodes.length).toBe(2)\n        expect(parent.childNodes[0]).toBe(target)\n        expect(parent.childNodes[1]).toBe(sibling)\n        expect(spy.calls.count()).toBe(1)\n      })\n\n      it('block instance', function () {\n        vm2.$before(sibling)\n        expect(parent.childNodes.length).toBe(6)\n        expect(parent.childNodes[1]).toBe(vm2._blockStart)\n        expect(parent.childNodes[1]).toBe(vm2.$el)\n        expect(parent.childNodes[2].tagName).toBe('P')\n        expect(parent.childNodes[3].tagName).toBe('SPAN')\n        expect(parent.childNodes[4]).toBe(vm2._blockEnd)\n        vm2.$remove(spy)\n        expect(parent.childNodes.length).toBe(2)\n        expect(parent.childNodes[0]).toBe(target)\n        expect(parent.childNodes[1]).toBe(sibling)\n        expect(spy.calls.count()).toBe(1)\n      })\n\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/api/dom_spec.js\n ** module id = 65\n ** module chunks = 0\n **/","var Vue = require('../../../../src/vue')\n\ndescribe('Events API', function () {\n\n  var vm, spy\n  beforeEach(function () {\n    vm = new Vue()\n    spy = jasmine.createSpy('emitter')\n  })\n  \n  it('$on', function () {\n    vm.$on('test', function () {\n      // expect correct context\n      expect(this).toBe(vm)\n      spy.apply(this, arguments)\n    })\n    vm.$emit('test', 1, 2 ,3, 4)\n    expect(spy.calls.count()).toBe(1)\n    expect(spy).toHaveBeenCalledWith(1, 2, 3, 4)\n  })\n\n  it('$once', function () {\n    vm.$once('test', spy)\n    vm.$emit('test', 1, 2 ,3)\n    vm.$emit('test', 2, 3, 4)\n    expect(spy.calls.count()).toBe(1)\n    expect(spy).toHaveBeenCalledWith(1, 2, 3)\n  })\n\n  it('$off', function () {\n    vm.$on('test1', spy)\n    vm.$on('test2', spy)\n    vm.$off()\n    vm.$emit('test1')\n    vm.$emit('test2')\n    expect(spy).not.toHaveBeenCalled()\n  })\n\n  it('$off event', function () {\n    vm.$on('test1', spy)\n    vm.$on('test2', spy)\n    vm.$off('test1')\n    vm.$off('test1') // test off something that's already off\n    vm.$emit('test1', 1)\n    vm.$emit('test2', 2)\n    expect(spy.calls.count()).toBe(1)\n    expect(spy).toHaveBeenCalledWith(2)\n  })\n\n  it('$off event + fn', function () {\n    var spy2 = jasmine.createSpy('emitter')\n    vm.$on('test', spy)\n    vm.$on('test', spy2)\n    vm.$off('test', spy)\n    vm.$emit('test', 1, 2, 3)\n    expect(spy).not.toHaveBeenCalled()\n    expect(spy2.calls.count()).toBe(1)\n    expect(spy2).toHaveBeenCalledWith(1, 2, 3)\n  })\n\n  it('$broadcast', function () {\n    var child1 = vm.$addChild()\n    var child2 = vm.$addChild()\n    var child3 = child1.$addChild()\n    child1.$on('test', spy)\n    child2.$on('test', spy)\n    child3.$on('test', spy)\n    vm.$broadcast('test')\n    expect(spy.calls.count()).toBe(3)\n  })\n\n  it('$broadcast optimization', function () {\n    var child = vm.$addChild()\n    var child2 = child.$addChild()\n    // hooks should not incurr the bookkeeping cost\n    child.$on('hook:created', function () {})\n    expect(vm._eventsCount['hook:created']).toBeUndefined()\n    child.$on('test', spy)\n    expect(vm._eventsCount['test']).toBe(1)\n    // child2's $emit & $broadcast\n    // shouldn't get called if no child listens to the event\n    child2.$emit = spy\n    child2.$broadcast = spy\n    vm.$broadcast('test')\n    expect(spy.calls.count()).toBe(1)\n    // check $off bookkeeping\n    child.$off('test', spy)\n    expect(vm._eventsCount['test']).toBe(0)\n    function noop () {}\n    child.$on('test', noop)\n    child2.$on('test', noop)\n    expect(vm._eventsCount['test']).toBe(2)\n    child.$off('test')\n    expect(vm._eventsCount['test']).toBe(1)\n    child.$on('test', noop)\n    child2.$on('test', noop)\n    expect(vm._eventsCount['test']).toBe(3)\n    child.$off()\n    child2.$off()\n    expect(vm._eventsCount['test']).toBe(0)\n  })\n\n  it('$broadcast cancel', function () {\n    var child = vm.$addChild()\n    var child2 = child.$addChild()\n    child.$on('test', function () {\n      return false\n    })\n    child2.$on('test', spy)\n    vm.$broadcast('test')\n    expect(spy).not.toHaveBeenCalled()\n  })\n\n  it('$dispatch', function () {\n    var child = vm.$addChild()\n    var child2 = child.$addChild()\n    child.$on('test', spy)\n    vm.$on('test', spy)\n    child2.$dispatch('test')\n    expect(spy.calls.count()).toBe(2)\n  })\n\n  it('$dispatch cancel', function () {\n    var child = vm.$addChild()\n    var child2 = child.$addChild()\n    child.$on('test', function () {\n      return false\n    })\n    vm.$on('test', spy)\n    child2.$dispatch('test')\n    expect(spy).not.toHaveBeenCalled()\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/api/events_spec.js\n ** module id = 66\n ** module chunks = 0\n **/","var Vue = require('../../../../src/vue')\nvar _ = require('../../../../src/util')\nvar config = require('../../../../src/config')\n\ndescribe('Global API', function () {\n\n  it('exposed utilities', function () {\n    expect(Vue.util).toBe(_)\n    expect(Vue.nextTick).toBe(_.nextTick)\n    expect(Vue.config).toBe(config)\n  })\n\n  it('extend', function () {\n    var Test = Vue.extend({\n      name: 'test',\n      a: 1,\n      b: 2\n    })\n    expect(Test.options.a).toBe(1)\n    expect(Test.options.b).toBe(2)\n    expect(Test.super).toBe(Vue)\n    // function.name is not available in IE\n    expect(Test.toString().match(/^function Test\\s?\\(/)).toBeTruthy()\n    var t = new Test({\n      a: 2\n    })\n    expect(t.$options.a).toBe(2)\n    expect(t.$options.b).toBe(2)\n    // inheritance\n    var Test2 = Test.extend({\n      a: 2\n    })\n    expect(Test2.options.a).toBe(2)\n    expect(Test2.options.b).toBe(2)\n    var t2 = new Test2({\n      a: 3\n    })\n    expect(t2.$options.a).toBe(3)\n    expect(t2.$options.b).toBe(2)\n  })\n\n  it('use', function () {\n    var def = {}\n    var options = {}\n    var pluginStub = {\n      install: function (Vue, opts) {\n        Vue.directive('plugin-test', def)\n        expect(opts).toBe(options)\n      }\n    }\n    Vue.use(pluginStub, options)\n    expect(Vue.options.directives['plugin-test']).toBe(def)\n    delete Vue.options.directives['plugin-test']\n    // use a function\n    Vue.use(pluginStub.install, options)\n    expect(Vue.options.directives['plugin-test']).toBe(def)\n    delete Vue.options.directives['plugin-test']\n  })\n\n  describe('Asset registration', function () {\n\n    var Test = Vue.extend()\n    \n    it('directive / filter / partial / transition', function () {\n      [\n        'directive',\n        'filter',\n        'partial',\n        'transition'\n      ].forEach(function (type) {\n        var def = {}\n        Test[type]('test', def)\n        expect(Test.options[type + 's'].test).toBe(def)\n        expect(Test[type]('test')).toBe(def)\n        // extended registration should not pollute global\n        expect(Vue.options[type + 's'].test).toBeUndefined()\n      })\n    })\n\n    it('component', function () {\n      var def = { a: 1 }\n      Test.component('test', def)\n      var component = Test.options.components.test\n      expect(typeof component).toBe('function')\n      expect(component.super).toBe(Vue)\n      expect(component.options.a).toBe(1)\n      expect(component.options.name).toBe('test')\n      expect(Test.component('test')).toBe(component)\n      // already extended\n      Test.component('test2', component)\n      expect(Test.component('test2')).toBe(component)\n      // extended registration should not pollute global\n      expect(Vue.options.components.test).toBeUndefined()\n    })\n\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/api/global_spec.js\n ** module id = 67\n ** module chunks = 0\n **/","var Vue = require('../../../../src/vue')\nvar _ = require('../../../../src/util')\nvar compile = require('../../../../src/compiler/compile')\n\nif (_.inBrowser) {\n  describe('Lifecycle API', function () {\n    \n    describe('$mount', function () {\n\n      var el, frag\n      beforeEach(function () {\n        el = document.createElement('div')\n        el.textContent = '{{test}}'\n        frag = document.createDocumentFragment()\n        frag.appendChild(el)\n        spyOn(_, 'warn')\n      })\n\n      it('normal', function () {\n        var vm = new Vue({\n          data: {\n            test: 'hi!'\n          }\n        })\n        vm.$mount(el)\n        expect(vm.$el).toBe(el)\n        expect(el.__vue__).toBe(vm)\n        expect(el.textContent).toBe('hi!')\n      })\n\n      it('auto-create', function () {\n        var vm = new Vue({\n          template: '{{a}}',\n          data: {\n            a: 123\n          }\n        })\n        vm.$mount()\n        expect(vm.$el).toBeTruthy()\n        expect(vm.$el.tagName).toBe('DIV')\n        expect(vm.$el.textContent).toBe('123')\n      })\n\n      it('selector', function () {\n        el.id = 'mount-test'\n        document.body.appendChild(el)\n        var vm = new Vue({\n          data: { test: 'hi!' }\n        })\n        vm.$mount('#mount-test')\n        expect(vm.$el).toBe(el)\n        expect(el.__vue__).toBe(vm)\n        expect(el.textContent).toBe('hi!')\n        document.body.removeChild(el)\n      })\n\n      it('warn invalid selector', function () {\n        var vm = new Vue()\n        vm.$mount('#none-exist')\n        expect(_.warn).toHaveBeenCalled()\n      })\n\n      it('replace', function () {\n        el.className = 'replace-test'\n        document.body.appendChild(el)\n        var vm = new Vue({\n          replace: true,\n          data: { test: 'hi!' },\n          template: '<div>{{test}}</div>'\n        })\n        vm.$mount(el)\n        expect(vm.$el).not.toBe(el)\n        expect(vm.$el.textContent).toBe('hi!')\n        expect(document.body.contains(el)).toBe(false)\n        expect(document.body.lastChild).toBe(vm.$el)\n        expect(vm.$el.className).toBe('replace-test')\n        document.body.removeChild(vm.$el)\n      })\n      \n      it('precompiled linker', function () {\n        var linker = compile(el, Vue.options)\n        var vm = new Vue({\n          _linker: linker,\n          data: {\n            test: 'hi!'\n          }\n        })\n        vm.$mount(el)\n        expect(vm.$el).toBe(el)\n        expect(el.__vue__).toBe(vm)\n        expect(el.textContent).toBe('hi!')\n      })\n\n      it('mount to fragment', function () {\n        var vm = new Vue({\n          data: { test: 'frag' }\n        })\n        vm.$mount(frag)\n        expect(vm._blockFragment).toBe(frag)\n        expect(vm.$el.nextSibling.textContent).toBe('frag')\n      })\n\n      it('replace fragment', function () {\n        document.body.appendChild(el)\n        var vm = new Vue({\n          replace: true,\n          data: { test: 'hi!' },\n          template: '<div>{{test}}</div><div>{{test + \"!\"}}</div>'\n        })\n        vm.$mount(el)\n        expect(vm.$el).not.toBe(el)\n        expect(vm.$el.nextSibling.textContent).toBe('hi!')\n        expect(vm.$el.nextSibling.nextSibling.textContent).toBe('hi!!')\n        expect(document.body.contains(el)).toBe(false)\n        expect(document.body.lastChild).toBe(vm._blockEnd)\n        vm.$remove()\n      })\n\n      it('hooks', function () {\n        var hooks = ['created', 'beforeCompile', 'compiled', 'attached', 'ready']\n        var options = {\n          data: {\n            test: 'hihi'\n          }\n        }\n        hooks.forEach(function (hook) {\n          options[hook] = jasmine.createSpy(hook)\n        })\n        var vm = new Vue(options)\n        expect(options.created).toHaveBeenCalled()\n        expect(options.beforeCompile).not.toHaveBeenCalled()\n        vm.$mount(el)\n        expect(options.beforeCompile).toHaveBeenCalled()\n        expect(options.compiled).toHaveBeenCalled()\n        expect(options.attached).not.toHaveBeenCalled()\n        expect(options.ready).not.toHaveBeenCalled()\n        vm.$appendTo(document.body)\n        expect(options.attached).toHaveBeenCalled()\n        expect(options.ready).toHaveBeenCalled()\n        vm.$remove()\n      })\n\n      it('warn against multiple calls', function () {\n        var vm = new Vue({\n          el: el\n        })\n        vm.$mount(el)\n        expect(_.warn).toHaveBeenCalled()\n      })\n\n    })\n\n    describe('$destroy', function () {\n\n      it('normal', function () {\n        var vm = new Vue()\n        expect(vm._isDestroyed).toBe(false)\n        var data = vm._data\n        expect(data.__ob__.vms.length).toBe(1)\n        vm.$destroy()\n        expect(data.__ob__.vms.length).toBe(0)\n        expect(vm._isDestroyed).toBe(true)\n        expect(vm._watchers).toBeNull()\n        expect(vm._userWatchers).toBeNull()\n        expect(vm._watcherList).toBeNull()\n        expect(vm.$el).toBeNull()\n        expect(vm.$parent).toBeNull()\n        expect(vm.$root).toBeNull()\n        expect(vm._children).toBeNull()\n        expect(vm._directives).toBeNull()\n        expect(Object.keys(vm._events).length).toBe(0)\n      })\n      \n      it('remove element', function () {\n        var el = document.createElement('div')\n        var parent = document.createElement('div')\n        parent.appendChild(el)\n        var vm = new Vue({ el: el })\n        vm.$destroy(true)\n        expect(parent.childNodes.length).toBe(0)\n        expect(el.__vue__).toBeNull()\n      })\n\n      it('hooks', function () {\n        var opts = {\n          beforeDestroy: jasmine.createSpy(),\n          destroyed: jasmine.createSpy(),\n          detached: jasmine.createSpy()\n        }\n        var el = opts.el = document.createElement('div')\n        document.body.appendChild(el)\n        var vm = new Vue(opts)\n        vm.$destroy(true)\n        expect(opts.beforeDestroy).toHaveBeenCalled()\n        expect(opts.destroyed).toHaveBeenCalled()\n        expect(opts.detached).toHaveBeenCalled()\n      })\n\n      it('parent', function () {\n        var parent = new Vue()\n        var child = parent.$addChild()\n        var child2 = parent.$addChild()\n        expect(parent._children.length).toBe(2)\n        child.$destroy()\n        expect(parent._children.length).toBe(1)\n        child2.$destroy()\n        expect(parent._children.length).toBe(0)\n      })\n\n      it('children', function () {\n        var parent = new Vue()\n        var child = parent.$addChild()\n        parent.$destroy()\n        expect(child._isDestroyed).toBe(true)\n      })\n\n      it('directives', function () {\n        var spy = jasmine.createSpy('directive unbind')\n        var vm = new Vue({\n          el: document.createElement('div'),\n          template: '<div v-test></div>',\n          directives: {\n            test: {\n              unbind: spy\n            }\n          }\n        })\n        vm.$destroy()\n        expect(spy).toHaveBeenCalled()\n      })\n\n      it('watchers', function () {\n        var vm = new Vue({\n          el: document.createElement('div'),\n          template: '{{a}}',\n          data: { a: 1 }\n        })\n        vm.$watch('a', function () {})\n        var dirWatcher = vm._watcherList[0]\n        var userWatcher = vm._watcherList[1]\n        vm.$destroy()\n        expect(dirWatcher.active).toBe(false)\n        expect(userWatcher.active).toBe(false)\n      })\n\n      it('refuse multiple calls', function () {\n        var spy = jasmine.createSpy()\n        var vm = new Vue({\n          beforeDestroy: spy\n        })\n        vm.$destroy()\n        vm.$destroy()\n        expect(spy.calls.count()).toBe(1)\n      })\n\n      it('safely teardown partial compilation', function () {\n        var vm = new Vue({\n          template: '<div v-component=\"dialog\"><div v-partial=\"hello\"></div></div>',\n          partials: {\n            hello: 'Hello {{name}}'\n          },\n          components: {\n            dialog: {\n              template: '<content>'\n            }\n          }\n        }).$mount()\n        expect(function () {\n          vm.$destroy()\n        }).not.toThrow()\n      })\n\n    })\n\n    describe('$compile', function () {\n\n      it('should partial compile and teardown stuff', function (done) {\n        var el = document.createElement('div')\n        var vm = new Vue({\n          el: el,\n          template: '{{a}}',\n          data: {\n            a: 'hi'\n          }\n        })\n        expect(vm._directives.length).toBe(1)\n        var partial = document.createElement('span')\n        partial.textContent = '{{a}}'\n        var decompile = vm.$compile(partial)\n        expect(partial.textContent).toBe('hi')\n        expect(vm._directives.length).toBe(2)\n        decompile()\n        expect(vm._directives.length).toBe(1)\n        vm.a = 'ha'\n        _.nextTick(function () {\n          expect(el.textContent).toBe('ha')\n          expect(partial.textContent).toBe('hi')\n          done()\n        })\n      })\n\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/api/lifecycle_spec.js\n ** module id = 68\n ** module chunks = 0\n **/","var _ = require('../../../src/util')\nvar batcher = require('../../../src/batcher')\nvar nextTick = require('../../../src/util').nextTick\n\ndescribe('Batcher', function () {\n\n  var spy\n\n  beforeEach(function () {\n    spy = jasmine.createSpy('batcher')\n    spyOn(_, 'warn')\n  })\n  \n  it('push', function (done) {\n    batcher.push({\n      run: spy\n    })\n    nextTick(function () {\n      expect(spy.calls.count()).toBe(1)\n      done()\n    })\n  })\n\n  it('dedup', function (done) {\n    batcher.push({\n      id: 1,\n      run: spy\n    })\n    batcher.push({\n      id: 1,\n      run: spy\n    })\n    nextTick(function () {\n      expect(spy.calls.count()).toBe(1)\n      done()\n    })\n  })\n\n  it('allow diplicate when flushing', function (done) {\n    batcher.push({\n      id: 1,\n      run: function () {\n        spy()\n        batcher.push({\n          id: 1,\n          run: spy\n        })\n      }\n    })\n    nextTick(function () {\n      expect(spy.calls.count()).toBe(2)\n      done()\n    })\n  })\n\n  it('calls user watchers after directive updates', function (done) {\n    var vals = []\n    function run () {\n      vals.push(this.id)\n    }\n    batcher.push({\n      id: 2,\n      user: true,\n      run: function () {\n        run.call(this)\n        // user watcher triggering another directive update!\n        batcher.push({\n          id: 3,\n          run: run\n        })\n      }\n    })\n    batcher.push({\n      id: 1,\n      run: run\n    })\n    nextTick(function () {\n      expect(vals[0]).toBe(1)\n      expect(vals[1]).toBe(2)\n      expect(vals[2]).toBe(3)\n      done()\n    })\n  })\n\n  it('warn against infinite update loops', function (done) {\n    var count = 0\n    var job = {\n      id: 1,\n      run: function () {\n        count++\n        batcher.push(job)\n      }\n    }\n    batcher.push(job)\n    nextTick(function () {\n      expect(count).not.toBe(0)\n      expect(_.warn).toHaveBeenCalled()\n      done()\n    })\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/batcher_spec.js\n ** module id = 70\n ** module chunks = 0\n **/","var Cache = require('../../../src/cache')\n\n/**\n * Debug function to assert cache state\n *\n * @param {Cache} cache\n */\n\nfunction toString (cache) {\n  var s = ''\n  var entry = cache.head\n  while (entry) {\n    s += String(entry.key) + ':' + entry.value\n    entry = entry.newer\n    if (entry) {\n      s += ' < '\n    }\n  }\n  return s\n}\n\ndescribe('Cache', function () {\n\n  var c = new Cache(4)\n  \n  it('put', function () {\n    c.put('adam', 29)\n    c.put('john', 26)\n    c.put('angela', 24)\n    c.put('bob', 48)\n    expect(c.size).toBe(4)\n    expect(toString(c)).toBe('adam:29 < john:26 < angela:24 < bob:48')\n  })\n\n  it('get', function () {\n    expect(c.get('adam')).toBe(29)\n    expect(c.get('john')).toBe(26)\n    expect(c.get('angela')).toBe(24)\n    expect(c.get('bob')).toBe(48)\n    expect(toString(c)).toBe('adam:29 < john:26 < angela:24 < bob:48')\n\n    expect(c.get('angela')).toBe(24)\n    // angela should now be the tail\n    expect(toString(c)).toBe('adam:29 < john:26 < bob:48 < angela:24')\n  })\n\n  it('expire', function () {\n    c.put('ygwie', 81)\n    expect(c.size).toBe(4)\n    expect(toString(c)).toBe('john:26 < bob:48 < angela:24 < ygwie:81')\n    expect(c.get('adam')).toBeUndefined()\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/cache_spec.js\n ** module id = 71\n ** module chunks = 0\n **/","var Vue = require('../../../../src/vue')\nvar _ = require('../../../../src/util')\nvar dirParser = require('../../../../src/parsers/directive')\nvar merge = require('../../../../src/util/merge-option')\nvar compile = require('../../../../src/compiler/compile')\n\nif (_.inBrowser) {\n  describe('Compile', function () {\n\n    var vm, el, data, directiveTeardown\n    beforeEach(function () {\n      // We mock vms here so we can assert what the generated\n      // linker functions do.\n      el = document.createElement('div')\n      data = {}\n      directiveTeardown = jasmine.createSpy()\n      vm = {\n        _directives: [],\n        _bindDir: function (name) {\n          this._directives.push({\n            name: name,\n            _teardown: directiveTeardown\n          })\n        },\n        $set: jasmine.createSpy(),\n        $eval: function (value) {\n          return data[value]\n        },\n        $interpolate: function (value) {\n          return data[value]\n        }\n      }\n      spyOn(vm, '_bindDir').and.callThrough()\n      spyOn(vm, '$eval').and.callThrough()\n      spyOn(vm, '$interpolate').and.callThrough()\n      spyOn(_, 'warn')\n    })\n\n    it('normal directives', function () {\n      el.setAttribute('v-a', 'b')\n      el.innerHTML = '<p v-a=\"a\" v-b=\"b\">hello</p><div v-b=\"b\"></div>'\n      var defA = { priority: 1 }\n      var defB = { priority: 2 }\n      var descriptorA = dirParser.parse('a')[0]\n      var descriptorB = dirParser.parse('b')[0]\n      var options = merge(Vue.options, {\n        directives: {\n          a: defA,\n          b: defB\n        }\n      })\n      var linker = compile(el, options)\n      expect(typeof linker).toBe('function')\n      linker(vm, el)\n      expect(vm._bindDir.calls.count()).toBe(4)\n      expect(vm._bindDir).toHaveBeenCalledWith('a', el, descriptorB, defA, undefined)\n      expect(vm._bindDir).toHaveBeenCalledWith('a', el.firstChild, descriptorA, defA, undefined)\n      expect(vm._bindDir).toHaveBeenCalledWith('b', el.firstChild, descriptorB, defB, undefined)\n      expect(vm._bindDir).toHaveBeenCalledWith('b', el.lastChild, descriptorB, defB, undefined)\n      // check the priority sorting\n      // the \"b\" on the firstNode should be called first!\n      expect(vm._bindDir.calls.argsFor(1)[0]).toBe('b')\n    })\n\n    it('text interpolation', function () {\n      data.b = 'yeah'\n      el.innerHTML = '{{a}} and {{*b}}'\n      var def = Vue.options.directives.text\n      var linker = compile(el, Vue.options)\n      linker(vm, el)\n      // expect 1 call because one-time bindings do not generate a directive.\n      expect(vm._bindDir.calls.count()).toBe(1)\n      var args = vm._bindDir.calls.argsFor(0)\n      expect(args[0]).toBe('text')\n      // skip the node because it's generated in the linker fn via cloneNode\n      expect(args[2]).toBe(dirParser.parse('a')[0])\n      expect(args[3]).toBe(def)\n      // expect $eval to be called during onetime\n      expect(vm.$eval).toHaveBeenCalledWith('b')\n      // {{a}} is mocked so it's a space.\n      // but we want to make sure {{*b}} worked.\n      expect(el.innerHTML).toBe('  and yeah')\n    })\n\n    it('inline html and partial', function () {\n      data.html = 'yoyoyo'\n      el.innerHTML = '{{{html}}} {{{*html}}} {{>partial}}'\n      var htmlDef = Vue.options.directives.html\n      var partialDef = Vue.options.directives.partial\n      var htmlDesc = dirParser.parse('html')[0]\n      var partialDesc = dirParser.parse('partial')[0]\n      var linker = compile(el, Vue.options)\n      linker(vm, el)\n      expect(vm._bindDir.calls.count()).toBe(2)\n      var htmlArgs = vm._bindDir.calls.argsFor(0)\n      expect(htmlArgs[0]).toBe('html')\n      expect(htmlArgs[2]).toBe(htmlDesc)\n      expect(htmlArgs[3]).toBe(htmlDef)\n      var partialArgs = vm._bindDir.calls.argsFor(1)\n      expect(partialArgs[0]).toBe('partial')\n      expect(partialArgs[2]).toBe(partialDesc)\n      expect(partialArgs[3]).toBe(partialDef)\n      expect(vm.$eval).toHaveBeenCalledWith('html')\n      // with placeholder comments & interpolated one-time html\n      expect(el.innerHTML).toBe('<!--v-html--> yoyoyo <!--v-partial-->')\n    })\n\n    it('terminal directives', function () {\n      el.innerHTML =\n        '<div v-repeat=\"items\"><p v-a=\"b\"></p></div>' + // v-repeat\n        '<div v-pre><p v-a=\"b\"></p></div>' // v-pre\n      var def = Vue.options.directives.repeat\n      var descriptor = dirParser.parse('items')[0]\n      var linker = compile(el, Vue.options)\n      linker(vm, el)\n      // expect 1 call because terminal should return early and let\n      // the directive handle the rest.\n      expect(vm._bindDir.calls.count()).toBe(1)\n      expect(vm._bindDir).toHaveBeenCalledWith('repeat', el.firstChild, descriptor, def, undefined)\n    })\n\n    it('custom element components', function () {\n      var options = merge(Vue.options, {\n        components: {\n          'my-component': {}\n        }\n      })\n      el.innerHTML = '<my-component><div v-a=\"b\"></div></my-component>'\n      var def = Vue.options.directives.component\n      var descriptor = dirParser.parse('my-component')[0]\n      var linker = compile(el, options)\n      linker(vm, el)\n      expect(vm._bindDir.calls.count()).toBe(1)\n      expect(vm._bindDir).toHaveBeenCalledWith('component', el.firstChild, descriptor, def, undefined)\n      expect(_.warn).not.toHaveBeenCalled()\n    })\n\n    it('attribute interpolation', function () {\n      data['{{*b}}'] = 'B'\n      el.innerHTML = '<div a=\"{{a}}\" b=\"{{*b}}\"></div>'\n      var def = Vue.options.directives.attr\n      var descriptor = dirParser.parse('a:a')[0]\n      var linker = compile(el, Vue.options)\n      linker(vm, el)\n      expect(vm._bindDir.calls.count()).toBe(1)\n      expect(vm._bindDir).toHaveBeenCalledWith('attr', el.firstChild, descriptor, def)\n      expect(el.firstChild.getAttribute('b')).toBe('B')\n    })\n\n    it('param attributes', function () {\n      var options = merge(Vue.options, {\n        paramAttributes: ['a', 'data-some-attr', 'some-other-attr', 'invalid', 'camelCase']\n      })\n      var def = Vue.options.directives['with']\n      el.setAttribute('a', '1')\n      el.setAttribute('data-some-attr', '{{a}}')\n      el.setAttribute('some-other-attr', '2')\n      el.setAttribute('invalid', 'a {{b}} c') // invalid\n      var linker = compile(el, options)\n      linker(vm, el)\n      // should skip literal & invliad\n      expect(vm._bindDir.calls.count()).toBe(1)\n      var args = vm._bindDir.calls.argsFor(0)\n      expect(args[0]).toBe('with')\n      expect(args[1]).toBe(el)\n      expect(args[2].arg).toBe('someAttr')\n      expect(args[3]).toBe(def)\n      // invalid and camelCase should've warn\n      expect(_.warn.calls.count()).toBe(2)\n      // literal should've called vm.$set\n      expect(vm.$set).toHaveBeenCalledWith('a', '1')\n      expect(vm.$set).toHaveBeenCalledWith('someOtherAttr', '2')\n    })\n\n    it('DocumentFragment', function () {\n      var frag = document.createDocumentFragment()\n      frag.appendChild(el)\n      var el2 = document.createElement('div')\n      frag.appendChild(el2)\n      el.innerHTML = '{{*a}}'\n      el2.innerHTML = '{{*b}}'\n      data.a = 'A'\n      data.b = 'B'\n      var linker = compile(frag, Vue.options)\n      linker(vm, frag)\n      expect(el.innerHTML).toBe('A')\n      expect(el2.innerHTML).toBe('B')\n    })\n\n    it('partial compilation', function () {\n      el.innerHTML = '<div v-attr=\"test:abc\">{{bcd}}<p v-show=\"ok\"></p></div>'\n      var linker = compile(el, Vue.options, true)\n      var decompile = linker(vm, el)\n      expect(vm._directives.length).toBe(3)\n      decompile()\n      expect(directiveTeardown.calls.count()).toBe(3)\n      expect(vm._directives.length).toBe(0)\n    })\n\n    it('skip script tags', function () {\n      el.innerHTML = '<script type=\"x/template\">{{test}}</script>'\n      var linker = compile(el, Vue.options)\n      linker(vm, el)\n      expect(vm._bindDir.calls.count()).toBe(0)\n    })\n\n    it('should handle nested transclusions', function (done) {\n      vm = new Vue({\n        el: el,\n        template:\n          '<div v-component=\"a\">' +\n            '<div v-component=\"b\">' +\n              '<div v-repeat=\"list\">{{$value}}</div>' +\n            '</div>' +\n          '</div>',\n        data: {\n          list: [1,2]\n        },\n        components: {\n          a: { template: '<content></content>' },\n          b: { template: '<content></content>' }\n        }\n      })\n      expect(el.innerHTML).toBe(\n        '<div><div>' +\n          '<div>1</div><div>2</div><!--v-repeat-->' +\n        '</div><!--v-component-->' +\n        '</div><!--v-component-->'\n      )\n      vm.list.push(3)\n      _.nextTick(function () {\n        expect(el.innerHTML).toBe(\n          '<div><div>' +\n            '<div>1</div><div>2</div><div>3</div><!--v-repeat-->' +\n          '</div><!--v-component-->' +\n          '</div><!--v-component-->'\n        )\n        done()\n      })\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/compiler/compile_spec.js\n ** module id = 72\n ** module chunks = 0\n **/","var transclude = require('../../../../src/compiler/transclude')\nvar _ = require('../../../../src/util')\n\nif (_.inBrowser) {\n  describe('Transclude', function () {\n\n    var el, options\n    beforeEach(function () {\n      el = document.createElement('div')\n      options = {}\n      spyOn(_, 'warn')\n    })\n\n    it('normal', function () {\n      var res = transclude(el, options)\n      expect(res).toBe(el)\n    })\n\n    it('template', function () {\n      options.template = '{{hi}}'\n      var res = transclude(el, options)\n      expect(res).toBe(el)\n      expect(res.innerHTML).toBe('{{hi}}')\n    })\n\n    it('template invalid', function () {\n      options.template = '#non-existent-stuff'\n      var res = transclude(el, options)\n      expect(res).toBeUndefined()\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n    it('template replace', function () {\n      el.className = 'hello'\n      options.template = '<div>{{hi}}</div>'\n      options.replace = true\n      var res = transclude(el, options)\n      expect(res).not.toBe(el)\n      expect(res.tagName).toBe('DIV')\n      expect(res.className).toBe('hello')\n      expect(res.innerHTML).toBe('{{hi}}')\n    })\n\n    it('block instance', function () {\n      var frag = document.createDocumentFragment()\n      frag.appendChild(el)\n      var res = transclude(frag, options)\n      expect(res).toBe(frag)\n      expect(res.childNodes.length).toBe(3)\n      expect(res.childNodes[0].nodeType).toBe(8)\n      expect(res.childNodes[1]).toBe(el)\n      expect(res.childNodes[2].nodeType).toBe(8)\n    })\n\n    it('template element', function () {\n      var tpl = document.createElement('template')\n      tpl.innerHTML = '<div>123</div>'\n      var res = transclude(tpl, options)\n      expect(res instanceof DocumentFragment).toBe(true)\n      expect(res.childNodes.length).toBe(3)\n      expect(res.childNodes[0].nodeType).toBe(8)\n      expect(res.childNodes[1].textContent).toBe('123')\n      expect(res.childNodes[2].nodeType).toBe(8)\n    })\n\n    it('content transclusion', function () {\n      el.innerHTML = '<p>hi</p>'\n      options.template = '<div><content></content></div>'\n      var res = transclude(el, options)\n      expect(res.firstChild.tagName).toBe('DIV')\n      expect(res.firstChild.firstChild.tagName).toBe('P')\n      expect(res.firstChild.firstChild.textContent).toBe('hi')\n    })\n\n    it('fallback content', function () {\n      options.template = '<content><p>fallback</p></content>'\n      var res = transclude(el, options)\n      expect(res.firstChild.tagName).toBe('P')\n      expect(res.firstChild.textContent).toBe('fallback')\n    })\n\n    it('fallback content with multiple select', function () {\n      el.innerHTML = '<p class=\"b\">select b</p>'\n      options.template = '<content select=\".a\"><p>fallback a</p></content><content select=\".b\">fallback b</content>'\n      var res = transclude(el, options)\n      expect(res.childNodes.length).toBe(2)\n      expect(res.firstChild.textContent).toBe('fallback a')\n      expect(res.lastChild.textContent).toBe('select b')\n    })\n\n    it('content transclusion with replace', function () {\n      el.innerHTML = '<p>hi</p>'\n      options.template = '<div><div><content></content></div></div>'\n      options.replace = true\n      var res = transclude(el, options)\n      expect(res).not.toBe(el)\n      expect(res.firstChild.tagName).toBe('DIV')\n      expect(res.firstChild.firstChild.tagName).toBe('P')\n      expect(res.firstChild.firstChild.textContent).toBe('hi')\n    })\n\n    it('block instance content transclusion', function () {\n      el.innerHTML = '<p>hi</p><span>ho</span>'\n      options.template = '<div></div><content select=\"p\"></content><content select=\"span\"></content>'\n      options.replace = true\n      var res = transclude(el, options)\n      expect(res.childNodes[1].tagName).toBe('DIV')\n      expect(res.childNodes[2].tagName).toBe('P')\n      expect(res.childNodes[3].tagName).toBe('SPAN')\n    })\n\n    it('select should only match children', function () {\n      el.innerHTML = '<p class=\"b\">select b</p><span><p class=\"b\">nested b</p></span><span><p class=\"c\">nested c</p></span>'\n      options.template = '<content select=\".a\"><p>fallback a</p></content><content select=\".b\">fallback b</content><content select=\".c\">fallback c</content>'\n      var res = transclude(el, options)\n      expect(res.childNodes.length).toBe(3)\n      expect(res.firstChild.textContent).toBe('fallback a')\n      expect(res.childNodes[1].textContent).toBe('select b')\n      expect(res.lastChild.textContent).toBe('fallback c')\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/compiler/transclude_spec.js\n ** module id = 73\n ** module chunks = 0\n **/","var Vue = require('../../../src/vue')\nvar Directive = require('../../../src/directive')\nvar nextTick = Vue.nextTick\n\ndescribe('Directive', function () {\n\n  var el = {} // simply a mock to be able to run in Node\n  var vm, def\n\n  beforeEach(function () {\n    def = {\n      bind: jasmine.createSpy('bind'),\n      update: jasmine.createSpy('update'),\n      unbind: jasmine.createSpy('unbind')\n    }\n    vm = new Vue({\n      data:{\n        a:1,\n        b: { c: { d: 2 }}\n      },\n      filters: {\n        test: function (v) {\n          return v * 2\n        }\n      },\n      directives: {\n        test: def\n      }\n    })\n  })\n\n  it('normal', function (done) {\n    var d = new Directive('test', el, vm, {\n      expression: 'a',\n      arg: 'someArg',\n      filters: [{name:'test'}]\n    }, def)\n    // properties\n    expect(d.el).toBe(el)\n    expect(d.name).toBe('test')\n    expect(d.vm).toBe(vm)\n    expect(d.arg).toBe('someArg')\n    expect(d.expression).toBe('a')\n    // init calls\n    expect(def.bind).toHaveBeenCalled()\n    expect(def.update).toHaveBeenCalledWith(2)\n    expect(d._bound).toBe(true)\n    // update\n    vm.a = 2\n    nextTick(function () {\n      expect(def.update).toHaveBeenCalledWith(4, 2)\n      // teardown\n      d._teardown()\n      expect(def.unbind).toHaveBeenCalled()\n      expect(d._bound).toBe(false)\n      expect(d._watcher).toBe(null)\n      done()\n    })\n  })\n\n  it('static literal', function () {\n    def.isLiteral = true\n    var d = new Directive('test', el, vm, {\n      expression: 'a'\n    }, def)\n    expect(d._watcher).toBeUndefined()\n    expect(d.expression).toBe('a')\n    expect(d.bind).toHaveBeenCalled()\n    expect(d.update).not.toHaveBeenCalled()\n  })\n\n  it('static literal, interpolate with no update', function () {\n    def.isLiteral = true\n    delete def.update\n    var d = new Directive('test', el, vm, {\n      expression: '{{a}}'\n    }, def)\n    expect(d._watcher).toBeUndefined()\n    expect(d.expression).toBe(1)\n    expect(d.bind).toHaveBeenCalled()\n  })\n\n  it('dynamic literal', function (done) {\n    vm.a = '' // #468 dynamic literals with falsy initial\n              // should still create the watcher.\n    def.isLiteral = true\n    var d = new Directive('test', el, vm, {\n      expression: '{{a}}'\n    }, def)\n    expect(d._watcher).toBeDefined()\n    expect(d.expression).toBe('')\n    expect(def.bind).toHaveBeenCalled()\n    expect(def.update).toHaveBeenCalledWith('')\n    vm.a = 'aa'\n    nextTick(function () {\n      expect(def.update).toHaveBeenCalledWith('aa', '')\n      done()\n    })\n  })\n\n  it('inline statement', function () {\n    def.acceptStatement = true\n    var spy = jasmine.createSpy()\n    vm.$options.filters.test = function (fn) {\n      spy()\n      return function () {\n        // call it twice\n        fn()\n        fn()\n      }\n    }\n    var d = new Directive('test', el, vm, {\n      expression: 'a++',\n      filters: [{name:'test'}]\n    }, def)\n    expect(d._watcher).toBeUndefined()\n    expect(d.bind).toHaveBeenCalled()\n    var wrappedFn = d.update.calls.argsFor(0)[0]\n    expect(typeof wrappedFn).toBe('function')\n    // test invoke the wrapped fn\n    wrappedFn()\n    expect(vm.a).toBe(3)\n  })\n\n  it('two-way', function (done) {\n    def.twoWay = true\n    vm.$options.filters.test = {\n      write: function (v) {\n        return v * 3\n      }\n    }\n    var d = new Directive('test', el, vm, {\n      expression: 'a',\n      filters: [{name:'test'}]\n    }, def)\n    d.set(2)\n    expect(vm.a).toBe(6)\n    nextTick(function () {\n      expect(def.update.calls.count()).toBe(2)\n      expect(def.update).toHaveBeenCalledWith(6, 1)\n      // locked set\n      d.set(3, true)\n      expect(vm.a).toBe(9)\n      nextTick(function () {\n        // should have no update calls\n        expect(def.update.calls.count()).toBe(2)\n        done()\n      })\n    })\n  })\n\n  it('deep', function (done) {\n    def.deep = true\n    var d = new Directive('test', el, vm, {\n      expression: 'b'\n    }, def)\n    vm.b.c.d = 3\n    nextTick(function () {\n      expect(def.update.calls.count()).toBe(2)\n      done()\n    })\n  })\n\n  it('function def', function () {\n    var d = new Directive('test', el, vm, {\n      expression: 'a'\n    }, def.update)\n    expect(d.update).toBe(def.update)\n    expect(def.update).toHaveBeenCalled()\n  })\n\n  it('reuse the same watcher', function (done) {\n    var d = new Directive('test', el, vm, {\n      expression: 'a',\n    }, def)\n    var d2 = new Directive('test', el, vm, {\n      expression: 'a',\n    }, def)\n    expect(vm._watcherList.length).toBe(1)\n    expect(d._watcher).toBe(d2._watcher)\n    d2._teardown()\n    expect(d2._watcher).toBeNull()\n    expect(vm._watcherList.length).toBe(1)\n    vm.a = 2\n    nextTick(function () {\n      expect(def.update).toHaveBeenCalledWith(2, 1)\n      d._teardown()\n      expect(vm._watcherList.length).toBe(0)\n      done()\n    })\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directive_spec.js\n ** module id = 74\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar def = require('../../../../src/directives/attr')\n\nif (_.inBrowser) {\n  describe('v-attr', function () {\n\n    var el\n    beforeEach(function () {\n      el = document.createElement('div')\n    })\n\n    it('normal attr', function () {\n      var dir = {\n        el: el,\n        arg: 'test'\n      }\n      _.extend(dir, def)\n      dir.bind()\n      dir.update('ok')\n      expect(el.getAttribute('test')).toBe('ok')\n      dir.update('again')\n      expect(el.getAttribute('test')).toBe('again')\n      dir.update(null)\n      expect(el.hasAttribute('test')).toBe(false)\n      dir.update(false)\n      expect(el.hasAttribute('test')).toBe(false)\n      dir.update(0)\n      expect(el.getAttribute('test')).toBe('0')\n    })\n\n    it('xlink', function () {\n      var xlinkNS = 'http://www.w3.org/1999/xlink'\n      var dir = {\n        el: el,\n        arg: 'xlink:href'\n      }\n      _.extend(dir, def)\n      dir.bind()\n      dir.update('ok')\n      expect(el.getAttributeNS(xlinkNS, 'href')).toBe('ok')\n      dir.update('again')\n      expect(el.getAttributeNS(xlinkNS, 'href')).toBe('again')\n      dir.update(null)\n      expect(el.hasAttributeNS(xlinkNS, 'test')).toBe(false)\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/attr_spec.js\n ** module id = 75\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar def = require('../../../../src/directives/class')\n\nif (_.inBrowser) {\n  describe('v-class', function () {\n\n    var el\n    beforeEach(function () {\n      el = document.createElement('div')\n    })\n\n    it('with className', function () {\n      el.className = 'haha'\n      var dir = {\n        el: el,\n        arg: 'test',\n        update: def\n      }\n      dir.update(true)\n      expect(el.className).toBe('haha test')\n      dir.update(false)\n      expect(el.className).toBe('haha')\n    })\n\n    it('without className', function () {\n      el.className = 'haha'\n      var dir = {\n        el: el,\n        update: def\n      }\n      dir.update('test')\n      expect(el.className).toBe('haha test')\n      dir.update('what')\n      expect(el.className).toBe('haha what')\n      dir.update()\n      expect(el.className).toBe('haha')\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/class_spec.js\n ** module id = 76\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar compile = require('../../../../src/compiler/compile')\nvar Vue = require('../../../../src/vue')\n\nif (_.inBrowser) {\n  describe('v-cloak', function () {\n\n    it('should not remove during compile', function () {\n      var el = document.createElement('div')\n      el.setAttribute('v-cloak', '')\n      compile(el, Vue.options)\n      expect(el.hasAttribute('v-cloak')).toBe(true)\n    })\n\n    it('should remove after compile', function () {\n      var el = document.createElement('div')\n      el.setAttribute('v-cloak', '')\n      new Vue({\n        el: el\n      })\n      expect(el.hasAttribute('v-cloak')).toBe(false)\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/cloak_spec.js\n ** module id = 77\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar Vue = require('../../../../src/vue')\n\nif (_.inBrowser) {\n  describe('v-component', function () {\n\n    var el\n    beforeEach(function () {\n      el = document.createElement('div')\n      document.body.appendChild(el)\n      spyOn(_, 'warn')\n    })\n\n    afterEach(function () {\n      document.body.removeChild(el)\n    })\n\n    it('static', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-component=\"test\"></div>',\n        components: {\n          test: {\n            data: function () {\n              return { a: 123 }\n            },\n            template: '{{a}}'\n          }\n        }\n      })\n      expect(el.innerHTML).toBe('<div>123</div><!--v-component-->')\n    })\n\n    it('replace', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-component=\"test\"></div>',\n        components: {\n          test: {\n            replace: true,\n            data: function () {\n              return { a: 123 }\n            },\n            template: '<p>{{a}}</p>'\n          }\n        }\n      })\n      expect(el.innerHTML).toBe('<p>123</p><!--v-component-->')\n    })\n\n    it('inline-template', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-component=\"test\" inline-template>{{a}}</div>',\n        data: {\n          a: 'parent'\n        },\n        components: {\n          test: {\n            data: function () {\n              return { a: 'child' }\n            },\n            template: 'child option template'\n          }\n        }\n      })\n      expect(el.innerHTML).toBe('<div>child</div><!--v-component-->')\n    })\n\n    it('block replace', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-component=\"test\"></div>',\n        components: {\n          test: {\n            replace: true,\n            data: function () {\n              return { a: 123, b: 234 }\n            },\n            template: '<p>{{a}}</p><p>{{b}}</p>'\n          }\n        }\n      })\n      expect(el.innerHTML).toBe('<!--v-start--><p>123</p><p>234</p><!--v-end--><!--v-component-->')\n    })\n\n    it('dynamic', function (done) {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-component=\"{{view}}\" v-attr=\"view:view\"></div>',\n        data: {\n          view: 'a'\n        },\n        components: {\n          a: {\n            template: 'AAA',\n            data: function () {\n              return { view: 'a' }\n            }\n          },\n          b: {\n            template: 'BBB',\n            data: function () {\n              return { view: 'b' }\n            }\n          }\n        }\n      })\n      expect(el.innerHTML).toBe('<div view=\"a\">AAA</div><!--v-component-->')\n      vm.view = 'b'\n      _.nextTick(function () {\n        expect(el.innerHTML).toBe('<div view=\"b\">BBB</div><!--v-component-->')\n        vm.view = ''\n        _.nextTick(function () {\n          expect(el.innerHTML).toBe('<!--v-component-->')\n          done()\n        })\n      })\n    })\n\n    it('keep-alive', function (done) {\n      var spyA = jasmine.createSpy()\n      var spyB = jasmine.createSpy()\n      var vm = new Vue({\n        el: el,\n        template: '<div v-component=\"{{view}}\" keep-alive></div>',\n        data: {\n          view: 'a'\n        },\n        components: {\n          a: {\n            created: spyA,\n            template: 'AAA'\n          },\n          b: {\n            created: spyB,\n            template: 'BBB'\n          }\n        }\n      })\n      expect(el.innerHTML).toBe('<div>AAA</div><!--v-component-->')\n      expect(spyA.calls.count()).toBe(1)\n      expect(spyB.calls.count()).toBe(0)\n      vm.view = 'b'\n      _.nextTick(function () {\n        expect(el.innerHTML).toBe('<div>BBB</div><!--v-component-->')\n        expect(spyA.calls.count()).toBe(1)\n        expect(spyB.calls.count()).toBe(1)\n        vm.view = 'a'\n        _.nextTick(function () {\n          expect(el.innerHTML).toBe('<div>AAA</div><!--v-component-->')\n          expect(spyA.calls.count()).toBe(1)\n          expect(spyB.calls.count()).toBe(1)\n          vm.view = 'b'\n          _.nextTick(function () {\n            expect(el.innerHTML).toBe('<div>BBB</div><!--v-component-->')\n            expect(spyA.calls.count()).toBe(1)\n            expect(spyB.calls.count()).toBe(1)\n            done()\n          })\n        })\n      })\n    })\n\n    it('should compile parent template directives & content in parent scope', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          ok: false,\n          message: 'hello'\n        },\n        template: '<div v-component=\"test\" v-show=\"ok\">{{message}}</div>',\n        components: {\n          test: {\n            template: '<div><content></content> {{message}}</div>',\n            replace: true,\n            data: function () {\n              return {\n                message: 'world'\n              }\n            }\n          }\n        }\n      })\n      expect(el.firstChild.style.display).toBe('none')\n      expect(el.firstChild.textContent).toBe('hello world')\n      vm.ok = true\n      vm.message = 'bye'\n      _.nextTick(function () {\n        expect(el.firstChild.style.display).toBe('')\n        expect(el.firstChild.textContent).toBe('bye world')\n        done()\n      })\n    })\n\n    it('parent content + v-if', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          ok: false,\n          message: 'hello'\n        },\n        template: '<div v-component=\"test\" v-if=\"ok\">{{message}}</div>',\n        components: {\n          test: {\n            template: '<content></content> {{message}}',\n            data: function () {\n              return {\n                message: 'world'\n              }\n            }\n          }\n        }\n      })\n      expect(el.textContent).toBe('')\n      expect(vm._children.length).toBe(0)\n      expect(vm._directives.length).toBe(1) // v-if\n      vm.ok = true\n      _.nextTick(function () {\n        expect(vm._children.length).toBe(1)\n        expect(vm._directives.length).toBe(3) // v-if, v-component, v-text\n        expect(el.textContent).toBe('hello world')\n        done()\n      })\n    })\n\n    it('paramAttributes', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          list: [{a:1}, {a:2}]\n        },\n        template: '<ul v-component=\"test\" collection=\"{{list}}\"></ul>',\n        components: {\n          test: {\n            template: '<li v-repeat=\"collection\">{{a}}</li>',\n            paramAttributes: ['collection']\n          }\n        }\n      })\n      expect(el.innerHTML).toBe('<ul><li>1</li><li>2</li><!--v-repeat--></ul><!--v-component-->')\n    })\n\n    it('wait-for', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          view: 'a'\n        },\n        template: '<div v-component=\"{{view}}\" wait-for=\"ok\"></div>',\n        components: {\n          a: {\n            template: 'AAA'\n          },\n          b: {\n            template: 'BBB'\n          }\n        }\n      })\n      vm._children[0].$emit('ok')\n      vm.view = 'b'\n      _.nextTick(function () {\n        expect(el.textContent).toBe('AAA')\n        // old vm is already removed, this is the new vm\n        vm._children[0].$emit('ok')\n        expect(el.textContent).toBe('BBB')\n        done()\n      })\n    })\n\n    it('transition-mode: in-out', function (done) {\n      var spy1 = jasmine.createSpy('enter')\n      var spy2 = jasmine.createSpy('leave')\n      var next\n      var vm = new Vue({\n        el: el,\n        data: {\n          view: 'a'\n        },\n        template: '<div v-component=\"{{view}}\" v-transition=\"test\" transition-mode=\"in-out\"></div>',\n        components: {\n          a: { template: 'AAA' },\n          b: { template: 'BBB' }\n        },\n        transitions: {\n          test: {\n            enter: function (el, done) {\n              spy1()\n              next = done\n            },\n            leave: function (el, done) {\n              spy2()\n              done()\n            }\n          }\n        }\n      })\n      expect(el.textContent).toBe('AAA')\n      vm.view = 'b'\n      _.nextTick(function () {\n        expect(spy1).toHaveBeenCalled()\n        expect(spy2).not.toHaveBeenCalled()\n        expect(el.textContent).toBe('AAABBB')\n        next()\n        expect(spy2).toHaveBeenCalled()\n        expect(el.textContent).toBe('BBB')\n        done()\n      })\n    })\n\n    it('transition-mode: out-in', function (done) {\n      var spy1 = jasmine.createSpy('enter')\n      var spy2 = jasmine.createSpy('leave')\n      var next\n      var vm = new Vue({\n        el: el,\n        data: {\n          view: 'a'\n        },\n        template: '<div v-component=\"{{view}}\" v-transition=\"test\" transition-mode=\"out-in\"></div>',\n        components: {\n          a: { template: 'AAA' },\n          b: { template: 'BBB' }\n        },\n        transitions: {\n          test: {\n            enter: function (el, done) {\n              spy2()\n              done()\n            },\n            leave: function (el, done) {\n              spy1()\n              next = done\n            }\n          }\n        }\n      })\n      expect(el.textContent).toBe('AAA')\n      vm.view = 'b'\n      _.nextTick(function () {\n        expect(spy1).toHaveBeenCalled()\n        expect(spy2).not.toHaveBeenCalled()\n        expect(el.textContent).toBe('AAA')\n        next()\n        expect(spy2).toHaveBeenCalled()\n        expect(el.textContent).toBe('BBB')\n        done()\n      })\n    })\n\n    it('teardown', function (done) {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-component=\"{{view}}\" keep-alive></div>',\n        data: {\n          view: 'test'\n        },\n        components: {\n          test: {},\n          test2: {}\n        }\n      })\n      vm.view = 'test2'\n      _.nextTick(function () {\n        expect(vm._children.length).toBe(2)\n        var child = vm._children[0]\n        var child2 = vm._children[1]\n        vm._directives[0].unbind()\n        expect(vm._directives[0].cache).toBeNull()\n        expect(vm._children.length).toBe(0)\n        expect(child._isDestroyed).toBe(true)\n        expect(child2._isDestroyed).toBe(true)\n        done()\n      })\n    })\n\n    it('already mounted warn', function () {\n      el.setAttribute('v-component', 'test')\n      var vm = new Vue({\n        el: el\n      })\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/component_spec.js\n ** module id = 78\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar Vue = require('../../../../src/vue')\n\nif (_.inBrowser) {\n  describe('v-el', function () {\n\n    var el\n    beforeEach(function () {\n      el = document.createElement('div')\n      spyOn(_, 'warn')\n    })\n\n    it('normal', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-el=\"test\" id=\"test\"></div>'\n      })\n      expect(vm.$$.test).toBeTruthy()\n      expect(vm.$$.test.id).toBe('test')\n      vm._directives[0]._teardown()\n      expect(vm.$$.test).toBeUndefined()\n    })\n\n    it('with v-repeat', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: { items: [1,2,3,4,5] },\n        template: '<div v-repeat=\"items\" v-el=\"test\">{{$value}}</div>'\n      })\n      expect(vm.$$.test).toBeTruthy()\n      expect(Array.isArray(vm.$$.test)).toBe(true)\n      expect(vm.$$.test[0].textContent).toBe('1')\n      expect(vm.$$.test[4].textContent).toBe('5')\n      vm.items = []\n      _.nextTick(function () {\n        expect(vm.$$.test.length).toBe(0)\n        done()\n      })\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/el_spec.js\n ** module id = 79\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar Vue = require('../../../../src/vue')\n\nif (_.inBrowser) {\n  describe('v-events', function () {\n\n    var el\n    beforeEach(function () {\n      spyOn(_, 'warn')\n      el = document.createElement('div')\n    })\n\n    it('should register events', function () {\n      var spy = jasmine.createSpy('v-events')\n      new Vue({\n        el: el,\n        template: '<div v-component=\"test\" v-events=\"test:test\"></div>',\n        methods: {\n          test: spy\n        },\n        components: {\n          test: {\n            compiled: function () {\n              this.$emit('test')\n            }\n          }\n        }\n      })\n      expect(spy).toHaveBeenCalled()\n    })\n\n    it('should warn when used on non-root node', function () {\n      new Vue({\n        el: el,\n        template: '<div v-events=\"test:test\"></div>'\n      })\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n    it('should warn when used on child component root', function () {\n      var spy = jasmine.createSpy('v-events')\n      new Vue({\n        el: el,\n        template: '<div v-component=\"test\"></div>',\n        methods: {\n          test: spy\n        },\n        components: {\n          test: {\n            replace: true,\n            template: '<div v-events=\"test:test\"></div>',\n            compiled: function () {\n              this.$emit('test')\n            }\n          }\n        }\n      })\n      expect(_.warn).toHaveBeenCalled()\n      expect(spy).not.toHaveBeenCalled()\n    })\n\n    it('should warn on non-function values', function () {\n      var vm = new Vue({\n        el: el,\n        data: { test: 123 },\n        template: '<div v-component=\"test\" v-events=\"test:test\"></div>',\n        components: {\n          test: {}\n        }\n      })\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n    it('should accept inline statement', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {a:1},\n        template: '<div v-component=\"test\" v-events=\"test:a++\"></div>',\n        components: {\n          test: {\n            compiled: function () {\n              this.$emit('test')\n            }\n          }\n        }\n      })\n      _.nextTick(function () {\n        expect(vm.a).toBe(2)\n        done()\n      })\n    })\n\n    it('should be able to switch handlers if not a method', function (done) {\n      var a = 0\n      var b = 0\n      var vm = new Vue({\n        el: el,\n        data: {\n          handle: function () {\n            a++\n          }\n        },\n        template: '<div v-component=\"test\" v-events=\"test:handle\"></div>',\n        components: {\n          test: {\n            compiled: function () {\n              this.$emit('test')\n            }\n          }\n        }\n      })\n      _.nextTick(function () {\n        expect(a).toBe(1)\n        expect(b).toBe(0)\n        vm.handle = function () {\n          b++\n        }\n        _.nextTick(function () {\n          vm._children[0].$emit('test')\n          expect(a).toBe(1)\n          expect(b).toBe(1)\n          done()\n        })\n      })\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/events_spec.js\n ** module id = 80\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar def = require('../../../../src/directives/html')\n\nif (_.inBrowser) {\n  describe('v-html', function () {\n\n    var el\n    beforeEach(function () {\n      el = document.createElement('div')\n    })\n\n    it('element', function () {\n      var dir = {\n        el: el\n      }\n      _.extend(dir, def)\n      dir.bind()\n      dir.update('<div>1234</div><p>234</p>')\n      expect(el.innerHTML).toBe('<div>1234</div><p>234</p>')\n      dir.update('<p>123</p><div>444</div>')\n      expect(el.innerHTML).toBe('<p>123</p><div>444</div>')\n      dir.update(null)\n      expect(el.innerHTML).toBe('')\n    })\n\n    it('inline', function () {\n      var node = document.createComment('htm-test')\n      el.appendChild(node)\n      var dir = {\n        el: node\n      }\n      _.extend(dir, def)\n      dir.bind()\n      dir.update('<div>1234</div><p>234</p>')\n      expect(el.innerHTML).toBe('<div>1234</div><p>234</p><!--htm-test-->')\n      dir.update('<p>123</p><div>444</div>')\n      expect(el.innerHTML).toBe('<p>123</p><div>444</div><!--htm-test-->')\n      dir.update(null)\n      expect(el.innerHTML).toBe('<!--htm-test-->')\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/html_spec.js\n ** module id = 81\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar Vue = require('../../../../src/vue')\n\nif (_.inBrowser) {\n  describe('v-if', function () {\n\n    var el\n    beforeEach(function () {\n      el = document.createElement('div')\n      spyOn(_, 'warn')\n    })\n\n    function wrap (content) {\n      return '<!--v-if-start-->' + content + '<!--v-if-end-->'\n    }\n\n    it('normal', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: { test: false, a: 'A' },\n        template: '<div v-if=\"test\"><div v-component=\"test\"></div></div>',\n        components: {\n          test: {\n            inherit: true,\n            template: '{{a}}'\n          }\n        }\n      })\n      // lazy instantitation\n      expect(el.innerHTML).toBe(wrap(''))\n      expect(vm._children.length).toBe(0)\n      vm.test = true\n      _.nextTick(function () {\n        expect(el.innerHTML).toBe(wrap('<div><div>A</div><!--v-component--></div>'))\n        expect(vm._children.length).toBe(1)\n        vm.test = false\n        _.nextTick(function () {\n          expect(el.innerHTML).toBe(wrap(''))\n          expect(vm._children.length).toBe(0)\n          vm.test = true\n          _.nextTick(function () {\n            expect(el.innerHTML).toBe(wrap('<div><div>A</div><!--v-component--></div>'))\n            expect(vm._children.length).toBe(1)\n            var child = vm._children[0]\n            vm.$destroy()\n            expect(child._isDestroyed).toBe(true)\n            done()\n          })\n        })\n      })\n    })\n\n    it('template block', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: { test: false, a: 'A', b: 'B' },\n        template: '<template v-if=\"test\"><p>{{a}}</p><p>{{b}}</p></template>'\n      })\n      // lazy instantitation\n      expect(el.innerHTML).toBe(wrap(''))\n      vm.test = true\n      _.nextTick(function () {\n        expect(el.innerHTML).toBe(wrap('<p>A</p><p>B</p>'))\n        vm.test = false\n        _.nextTick(function () {\n          expect(el.innerHTML).toBe(wrap(''))\n          done()\n        })\n      })\n    })\n\n    it('v-if + v-component', function (done) {\n      var attachSpy = jasmine.createSpy()\n      var detachSpy = jasmine.createSpy()\n      var readySpy = jasmine.createSpy()\n      var vm = new Vue({\n        el: el,\n        data: { ok: false },\n        template: '<div v-component=\"test\" v-if=\"ok\"></div>',\n        components: {\n          test: {\n            data: function () {\n              return { a: 123 }\n            },\n            template: '{{a}}',\n            ready: readySpy,\n            attached: attachSpy,\n            detached: detachSpy\n          }\n        }\n      })\n      vm.$appendTo(document.body)\n      expect(el.innerHTML).toBe(wrap(''))\n      expect(vm._children.length).toBe(0)\n      vm.ok = true\n      _.nextTick(function () {\n        expect(el.innerHTML).toBe(wrap('<div>123</div><!--v-component-->'))\n        expect(vm._children.length).toBe(1)\n        expect(attachSpy).toHaveBeenCalled()\n        expect(readySpy).toHaveBeenCalled()\n        vm.ok = false\n        _.nextTick(function () {\n          expect(detachSpy).toHaveBeenCalled()\n          expect(el.innerHTML).toBe(wrap(''))\n          expect(vm._children.length).toBe(0)\n          vm.$remove()\n          done()\n        })\n      })\n    })\n\n    it('v-if + dynamic component', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          ok: false,\n          view: 'a'\n        },\n        template: '<div v-component=\"{{view}}\" v-if=\"ok\"></div>',\n        components: {\n          a: {\n            template: 'AAA'\n          },\n          b: {\n            template: 'BBB'\n          }\n        }\n      })\n      expect(el.innerHTML).toBe(wrap(''))\n      expect(vm._children.length).toBe(0)\n      // toggle if with lazy instantiation\n      vm.ok = true\n      _.nextTick(function () {\n        expect(el.innerHTML).toBe(wrap('<div>AAA</div><!--v-component-->'))\n        expect(vm._children.length).toBe(1)\n        // switch view when if=true\n        vm.view = 'b'\n        _.nextTick(function () {\n          expect(el.innerHTML).toBe(wrap('<div>BBB</div><!--v-component-->'))\n          expect(vm._children.length).toBe(1)\n          // toggle if when already instantiated\n          vm.ok = false\n          _.nextTick(function () {\n            expect(el.innerHTML).toBe(wrap(''))\n            expect(vm._children.length).toBe(0)\n            // toggle if and switch view at the same time\n            vm.view = 'a'\n            vm.ok = true\n            _.nextTick(function () {\n              expect(el.innerHTML).toBe(wrap('<div>AAA</div><!--v-component-->'))\n              expect(vm._children.length).toBe(1)\n              done()\n            })\n          })\n        })\n      })\n    })\n\n    it('v-if with different truthy values', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          a: 1\n        },\n        template: '<div v-if=\"a\">{{a}}</div>'\n      })\n      expect(el.innerHTML).toBe(wrap('<div>1</div>'))\n      vm.a = 2\n      _.nextTick(function () {\n        expect(el.innerHTML).toBe(wrap('<div>2</div>'))\n        done()\n      })\n    })\n\n    it('invalid warn', function () {\n      el.setAttribute('v-if', 'test')\n      var vm = new Vue({\n        el: el\n      })\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n    it('v-if with content transclusion', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          a: 1,\n          show: true\n        },\n        template: '<div v-component=\"test\" show=\"{{show}}\">{{a}}</div>',\n        components: {\n          test: {\n            paramAttributes: ['show'],\n            template: '<div v-if=\"show\"><content></cotent></div>'\n          }\n        }\n      })\n      expect(el.textContent).toBe('1')\n      vm.a = 2\n      _.nextTick(function () {\n        expect(el.textContent).toBe('2')\n        vm.show = false\n        _.nextTick(function () {\n          expect(el.textContent).toBe('')\n          vm.show = true\n          vm.a = 3\n          _.nextTick(function () {\n            expect(el.textContent).toBe('3')\n            done()\n          })\n        })\n      })\n    })\n\n    it('call attach/detach for transcluded components', function (done) {\n      document.body.appendChild(el)\n      var attachSpy = jasmine.createSpy('attached')\n      var detachSpy = jasmine.createSpy('detached')\n      var vm = new Vue({\n        el: el,\n        data: { show: true },\n        template: '<div v-component=\"outer\"><div v-component=\"transcluded\"></div></div>',\n        components: {\n          outer: {\n            template: '<div v-if=\"$parent.show\"><content></content></div>'\n          },\n          transcluded: {\n            template: 'transcluded',\n            attached: attachSpy,\n            detached: detachSpy\n          }\n        }\n      })\n      expect(attachSpy).toHaveBeenCalled()\n      vm.show = false\n      _.nextTick(function () {\n        expect(detachSpy).toHaveBeenCalled()\n        document.body.removeChild(el)\n        done()\n      })\n    })\n\n    it('call attach/detach for dynamicly created components inside if block', function (done) {\n      document.body.appendChild(el)\n      var attachSpy = jasmine.createSpy('attached')\n      var detachSpy = jasmine.createSpy('detached')\n      var vm = new Vue({\n        el: el,\n        data: {\n          show: true,\n          list: [{a:0}]\n        },\n        template:\n          '<div v-component=\"outer\">' +\n            '<div>' + // an extra layer to test components deep inside the tree\n              '<div v-repeat=\"list\" v-component=\"transcluded\"></div>' +\n            '</div>' +\n          '</div>',\n        components: {\n          outer: {\n            template:\n              '<div v-if=\"$parent.show\">' +\n                '<content></content>' +\n              '</div>' +\n              // this is to test that compnents that are not in the if block\n              // should not fire attach/detach when v-if toggles\n              '<div v-component=\"transcluded\"></div>'\n          },\n          transcluded: {\n            template: '{{a}}',\n            attached: attachSpy,\n            detached: detachSpy\n          }\n        }\n      })\n      assertMarkup()\n      expect(attachSpy.calls.count()).toBe(2)\n      vm.show = false\n      _.nextTick(function () {\n        assertMarkup()\n        expect(detachSpy.calls.count()).toBe(1)\n        vm.list.push({a:1})\n        vm.show = true\n        _.nextTick(function () {\n          assertMarkup()\n          expect(attachSpy.calls.count()).toBe(2 + 2)\n          vm.list.push({a:2})\n          vm.show = false\n          _.nextTick(function () {\n            assertMarkup()\n            expect(attachSpy.calls.count()).toBe(2 + 2 + 1)\n            expect(detachSpy.calls.count()).toBe(1 + 3)\n            document.body.removeChild(el)\n            done()\n          })\n        })\n      })\n\n      function assertMarkup () {\n        var showBlock = vm.show\n          ? '<div><div>' +\n              vm.list.map(function (o) {\n                return '<div>' + o.a + '</div>'\n              }).join('') + '<!--v-repeat-->' +\n            '</div></div>'\n          : ''\n        var markup = '<div>' +\n          '<!--v-if-start-->' +\n            showBlock +\n          '<!--v-if-end-->' +\n          '<div></div><!--v-component-->' +\n        '</div><!--v-component-->'\n        expect(el.innerHTML).toBe(markup)\n      }\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/if_spec.js\n ** module id = 82\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar Vue = require('../../../../src/vue')\n\n// unset jQuery to bypass jQuery check for normal test cases\njQuery = null\n\n/**\n * Mock event helper\n */\n\nfunction trigger (target, event, process) {\n  var e = document.createEvent('HTMLEvents')\n  e.initEvent(event, true, true)\n  if (process) process(e)\n  target.dispatchEvent(e)\n}\n\n/**\n * setting <select>'s value in IE9 doesn't work\n * we have to manually loop through the options\n */\n\nfunction updateSelect (el, value) {\n  /* jshint eqeqeq: false */\n  var options = el.options\n  var i = options.length\n  while (i--) {\n    if (options[i].value == value) {\n        options[i].selected = true\n        break\n    }\n  }\n}\n\nif (_.inBrowser) {\n  describe('v-model', function () {\n\n    var el\n    beforeEach(function () {\n      el = document.createElement('div')\n      el.style.display = 'none'\n      document.body.appendChild(el)\n      spyOn(_, 'warn')\n    })\n\n    it('radio buttons', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'a'\n        },\n        template:\n          '<input type=\"radio\" value=\"a\" v-model=\"test\" name=\"test\">' +\n          '<input type=\"radio\" value=\"b\" v-model=\"test\" name=\"test\">'\n      })\n      expect(el.childNodes[0].checked).toBe(true)\n      expect(el.childNodes[1].checked).toBe(false)\n      vm.test = 'b'\n      _.nextTick(function () {\n        expect(el.childNodes[0].checked).toBe(false)\n        expect(el.childNodes[1].checked).toBe(true)\n        el.childNodes[0].click()\n        expect(el.childNodes[0].checked).toBe(true)\n        expect(el.childNodes[1].checked).toBe(false)\n        expect(vm.test).toBe('a')\n        vm._directives[1].unbind()\n        el.childNodes[1].click()\n        expect(vm.test).toBe('a')\n        done()\n      })\n    })\n\n    it('radio default value', function () {\n      var vm = new Vue({\n        el: el,\n        data: {},\n        template: '<input type=\"radio\" checked value=\"a\" v-model=\"test\">'\n      })\n      expect(vm.test).toBe('a')\n    })\n\n    it('checkbox', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: true\n        },\n        template: '<input type=\"checkbox\" v-model=\"test\">'\n      })\n      expect(el.firstChild.checked).toBe(true)\n      vm.test = false\n      _.nextTick(function () {\n        expect(el.firstChild.checked).toBe(false)\n        expect(vm.test).toBe(false)\n        el.firstChild.click()\n        expect(el.firstChild.checked).toBe(true)\n        expect(vm.test).toBe(true)\n        vm._directives[0].unbind()\n        el.firstChild.click()\n        expect(el.firstChild.checked).toBe(false)\n        expect(vm.test).toBe(true)\n        done()\n      })\n    })\n\n    it('checkbox default value', function () {\n      var vm = new Vue({\n        el: el,\n        data: {},\n        template: '<input type=\"checkbox\" checked v-model=\"test\">'\n      })\n      expect(vm.test).toBe(true)\n    })\n\n    it('select', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'b'\n        },\n        template:\n          '<select v-model=\"test\">' +\n            '<option>a</option>' +\n            '<option>b</option>' +\n            '<option>c</option>' +\n          '</select>'\n      })\n      expect(vm.test).toBe('b')\n      expect(el.firstChild.value).toBe('b')\n      expect(el.firstChild.childNodes[1].selected).toBe(true)\n      vm.test = 'c'\n      _.nextTick(function () {\n        expect(el.firstChild.value).toBe('c')\n        expect(el.firstChild.childNodes[2].selected).toBe(true)\n        updateSelect(el.firstChild, 'a')\n        trigger(el.firstChild, 'change')\n        expect(vm.test).toBe('a')\n        done()\n      })\n    })\n\n    it('select default value', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'a'\n        },\n        template:\n          '<select v-model=\"test\">' +\n            '<option>a</option>' +\n            '<option selected>b</option>' +\n          '</select>'\n      })\n      expect(vm.test).toBe('b')\n      expect(el.firstChild.value).toBe('b')\n      expect(el.firstChild.childNodes[1].selected).toBe(true)\n    })\n\n    it('select + empty default value', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<select v-model=\"test\"><option value=\"\" selected>null</option><<option value=\"1\">1</option></select>'\n      })\n      expect(vm.test).toBe('')\n      trigger(vm.$el.firstChild, 'change')\n      expect(vm.test).toBe('')\n    })\n\n    it('select + multiple', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: [2] // test number soft equal\n        },\n        template:\n          '<select v-model=\"test\" multiple>' +\n            '<option>1</option>' +\n            '<option>2</option>' +\n            '<option>3</option>' +\n          '</select>'\n      })\n      var opts = el.firstChild.options\n      expect(opts[0].selected).toBe(false)\n      expect(opts[1].selected).toBe(true)\n      expect(opts[2].selected).toBe(false)\n      vm.test = [1, '3'] // mix of number/string\n      _.nextTick(function () {\n        expect(opts[0].selected).toBe(true)\n        expect(opts[1].selected).toBe(false)\n        expect(opts[2].selected).toBe(true)\n        opts[0].selected = false\n        opts[1].selected = true\n        trigger(el.firstChild, 'change')\n        expect(vm.test[0]).toBe('2')\n        expect(vm.test[1]).toBe('3')\n        done()\n      })\n    })\n\n    it('select + multiple default value', function () {\n      var vm = new Vue({\n        el: el,\n        data: {},\n        template:\n          '<select v-model=\"test\" multiple>' +\n            '<option>a</option>' +\n            '<option selected>b</option>' +\n            '<option selected>c</option>' +\n          '</select>'\n      })\n      expect(vm.test[0]).toBe('b')\n      expect(vm.test[1]).toBe('c')\n    })\n\n    it('select + options', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'b',\n          opts: ['a', 'b', 'c']\n        },\n        template: '<select v-model=\"test\" options=\"opts\"></select>'\n      })\n      var opts = el.firstChild.options\n      expect(opts.length).toBe(3)\n      expect(opts[0].selected).toBe(false)\n      expect(opts[1].selected).toBe(true)\n      expect(opts[2].selected).toBe(false)\n      vm.opts = ['b', 'c']\n      _.nextTick(function () {\n        expect(opts.length).toBe(2)\n        expect(opts[0].selected).toBe(true)\n        expect(opts[1].selected).toBe(false)\n        // should teardown option watcher when unbind\n        expect(vm._watcherList.length).toBe(2)\n        vm._directives[0]._teardown()\n        expect(vm._watcherList.length).toBe(0)\n        done()\n      })\n    })\n\n    it('select + options + text', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'b',\n          opts: [\n            { text: 'A', value: 'a' },\n            { text: 'B', value: 'b' }\n          ]\n        },\n        template: '<select v-model=\"test\" options=\"opts\"></select>'\n      })\n      expect(el.firstChild.innerHTML).toBe(\n        '<option value=\"a\">A</option>' +\n        '<option value=\"b\">B</option>'\n      )\n      var opts = el.firstChild.options\n      expect(opts[0].selected).toBe(false)\n      expect(opts[1].selected).toBe(true)\n    })\n\n    it('select + options + optgroup', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'b',\n          opts: [\n            { label: 'A', options: ['a','b'] },\n            { label: 'B', options: ['c'] }\n          ]\n        },\n        template: '<select v-model=\"test\" options=\"opts\"></select>'\n      })\n      expect(el.firstChild.innerHTML).toBe(\n        '<optgroup label=\"A\">' +\n          '<option value=\"a\">a</option><option value=\"b\">b</option>' +\n        '</optgroup>' +\n        '<optgroup label=\"B\">' +\n          '<option value=\"c\">c</option>' +\n        '</optgroup>'\n      )\n      var opts = el.firstChild.options\n      expect(opts[0].selected).toBe(false)\n      expect(opts[1].selected).toBe(true)\n      expect(opts[2].selected).toBe(false)\n    })\n\n    it('select + number', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: '1'\n        },\n        template: '<select v-model=\"test\" number><option value=\"1\">1</option></select>'\n      })\n      expect(vm.test).toBe('1')\n      trigger(vm.$el.firstChild, 'change')\n      expect(vm.test).toBe(1)\n    })\n\n    it('select + number + multiple', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: []\n        },\n        template: '<select v-model=\"test\" multiple number><option>1</option><option>2</option></select>'\n      })\n      ;[].forEach.call(el.querySelectorAll('option'), function (o) {\n        o.selected = true\n      })\n      trigger(el.firstChild, 'change')\n      expect(vm.test[0]).toBe(1)\n      expect(vm.test[1]).toBe(2)\n    })\n\n    it('select + number initial value', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: '1'\n        },\n        template: '<select v-model=\"test\" number><option value=\"1\" selected>1</option></select>'\n      })\n      expect(vm.test).toBe(1)\n    })\n\n    it('select + options + filter', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          opts: ['a','b']\n        },\n        filters: {\n          aFilter: function (opts){\n            return opts.map(function (val,i){\n              return val + i\n            })\n          }\n        },\n        template: '<select v-model=\"test\" options=\"opts | aFilter\"></select>'\n      })\n      expect(el.firstChild.innerHTML).toBe(\n          '<option value=\"a0\">a0</option>' +\n          '<option value=\"b1\">b1</option>'\n      )\n    })\n\n    it('text', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'b'\n        },\n        template: '<input v-model=\"test\">'\n      })\n      expect(el.firstChild.value).toBe('b')\n      vm.test = 'a'\n      _.nextTick(function () {\n        expect(el.firstChild.value).toBe('a')\n        el.firstChild.value = 'c'\n        trigger(el.firstChild, 'input')\n        expect(vm.test).toBe('c')\n        vm._directives[0].unbind()\n        el.firstChild.value = 'd'\n        trigger(el.firstChild, 'input')\n        expect(vm.test).toBe('c')\n        done()\n      })\n    })\n\n    it('text default value', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'b'\n        },\n        template: '<input v-model=\"test | test\" value=\"a\">',\n        filters: {\n          test: {\n            read: function (v) {\n              return v.slice(0, -1)\n            },\n            write: function (v) {\n              return v + 'c'\n            }\n          }\n        }\n      })\n      expect(vm.test).toBe('ac')\n      expect(el.firstChild.value).toBe('a')\n    })\n\n    it('text lazy', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'b'\n        },\n        template: '<input v-model=\"test\" lazy>'\n      })\n      expect(el.firstChild.value).toBe('b')\n      expect(vm.test).toBe('b')\n      el.firstChild.value = 'c'\n      trigger(el.firstChild, 'input')\n      expect(vm.test).toBe('b')\n      trigger(el.firstChild, 'change')\n      expect(vm.test).toBe('c')\n    })\n\n    it('text with filters', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'b'\n        },\n        filters: {\n          test: {\n            write: function (val) {\n              return val.toLowerCase()\n            }\n          }\n        },\n        template: '<input v-model=\"test | uppercase | test\">'\n      })\n      expect(el.firstChild.value).toBe('B')\n      el.firstChild.value = 'cc'\n      trigger(el.firstChild, 'input')\n      _.nextTick(function () {\n        expect(el.firstChild.value).toBe('CC')\n        expect(vm.test).toBe('cc')\n        done()\n      })\n    })\n\n    // when there's only write filter, should allow\n    // out of sync between the input field and actual data\n    it('text with only write filter', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'b'\n        },\n        filters: {\n          test: {\n            write: function (val) {\n              return val.toUpperCase()\n            }\n          }\n        },\n        template: '<input v-model=\"test | test\">'\n      })\n      el.firstChild.value = 'cc'\n      trigger(el.firstChild, 'input')\n      _.nextTick(function () {\n        expect(el.firstChild.value).toBe('cc')\n        expect(vm.test).toBe('CC')\n        done()\n      })\n    })\n\n    it('number', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 1\n        },\n        template: '<input v-model=\"test\" value=\"2\" number>'\n      })\n      expect(vm.test).toBe(2)\n      el.firstChild.value = 3\n      trigger(el.firstChild, 'input')\n      expect(vm.test).toBe(3)\n    })\n\n    it('IE9 cut and delete', function (done) {\n      var ie9 = _.isIE9\n      _.isIE9 = true\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'aaa'\n        },\n        template: '<input v-model=\"test\">'\n      })\n      var input = el.firstChild\n      input.value = 'aa'\n      trigger(input, 'cut')\n      _.nextTick(function () {\n        expect(vm.test).toBe('aa')\n        input.value = 'a'\n        trigger(input, 'keyup', function (e) {\n          e.keyCode = 8\n        })\n        expect(vm.test).toBe('a')\n        // teardown\n        vm._directives[0].unbind()\n        input.value = 'bbb'\n        trigger(input, 'keyup', function (e) {\n          e.keyCode = 8\n        })\n        expect(vm.test).toBe('a')\n        _.isIE9 = ie9\n        done()\n      })\n    })\n\n    it('text + compositionevents', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'aaa',\n          test2: 'bbb'\n        },\n        template: '<input v-model=\"test\"><input v-model=\"test2 | uppercase\">'\n      })\n      var input = el.firstChild\n      var input2 = el.childNodes[1]\n      trigger(input, 'compositionstart')\n      trigger(input2, 'compositionstart')\n      input.value = input2.value = 'ccc'\n      // input before composition unlock should not call set\n      trigger(input, 'input')\n      trigger(input2, 'input')\n      expect(vm.test).toBe('aaa')\n      expect(vm.test2).toBe('bbb')\n      // after composition unlock it should work\n      trigger(input, 'compositionend')\n      trigger(input2, 'compositionend')\n      trigger(input, 'input')\n      trigger(input2, 'input')\n      expect(vm.test).toBe('ccc')\n      expect(vm.test2).toBe('ccc')\n      // IE complains about \"unspecified error\" when calling\n      // setSelectionRange() on an input element that's been\n      // removed from the DOM, so we wait until the\n      // selection range callback has fired to end this test.\n      _.nextTick(done)\n    })\n\n    it('textarea', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'b',\n          b: 'BB'\n        },\n        template: '<textarea v-model=\"test\">a {{b}} c</textarea>'\n      })\n      expect(vm.test).toBe('a BB c')\n      expect(el.firstChild.value).toBe('a BB c')\n    })\n\n    it('warn invalid tag', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-model=\"test\"></div>'\n      })\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n    it('warn invalid option value', function () {\n      var vm = new Vue({\n        el: el,\n        data: { a: 123 },\n        template: '<select v-model=\"test\" options=\"a\"></select>'\n      })\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n    it('warn read-only filters', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<input v-model=\"abc | test\">',\n        filters: {\n          test: function (v) {\n            return v\n          }\n        }\n      })\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n    it('support jQuery change event', function (done) {\n      // restore jQuery\n      jQuery = $\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'b'\n        },\n        template: '<input v-model=\"test\" lazy>'\n      })\n      expect(el.firstChild.value).toBe('b')\n      vm.test = 'a'\n      _.nextTick(function () {\n        expect(el.firstChild.value).toBe('a')\n        el.firstChild.value = 'c'\n        jQuery(el.firstChild).trigger('change')\n        expect(vm.test).toBe('c')\n        vm._directives[0].unbind()\n        el.firstChild.value = 'd'\n        jQuery(el.firstChild).trigger('change')\n        expect(vm.test).toBe('c')\n        // unset jQuery\n        jQuery = null\n        done()\n      })\n    })\n\n    it('support debounce', function (done) {\n      var spy = jasmine.createSpy()\n      var vm = new Vue({\n        el: el,\n        data: {\n          test: 'a'\n        },\n        watch: {\n          test: spy\n        },\n        template: '<input v-model=\"test\" debounce=\"100\">'\n      })\n      el.firstChild.value = 'b'\n      trigger(el.firstChild, 'input')\n      setTimeout(function () {\n        el.firstChild.value = 'c'\n        trigger(el.firstChild, 'input')\n      }, 10)\n      setTimeout(function () {\n        el.firstChild.value = 'd'\n        trigger(el.firstChild, 'input')\n      }, 20)\n      setTimeout(function () {\n        expect(spy.calls.count()).toBe(0)\n        expect(vm.test).toBe('a')\n      }, 30)\n      setTimeout(function () {\n        expect(spy.calls.count()).toBe(1)\n        expect(vm.test).toBe('d')\n        done()\n      }, 200)\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/model_spec.js\n ** module id = 83\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar Vue = require('../../../../src/vue')\n\nfunction trigger (target, event, process) {\n  var e = document.createEvent('HTMLEvents')\n  e.initEvent(event, true, true)\n  if (process) process(e)\n  target.dispatchEvent(e)\n  return e\n}\n\nif (_.inBrowser) {\n  describe('v-on', function () {\n\n    var el\n    beforeEach(function () {\n      el = document.createElement('div')\n      spyOn(_, 'warn')\n    })\n\n    it('methods', function () {\n      var spy = jasmine.createSpy()\n      var vm = new Vue({\n        el: el,\n        template: '<a v-on=\"click:test\"></a>',\n        data: {a:1},\n        methods: {\n          test: spy\n        }\n      })\n      var a = el.firstChild\n      trigger(a, 'click')\n      expect(spy.calls.count()).toBe(1)\n      vm.$destroy()\n      trigger(a, 'click')\n      expect(spy.calls.count()).toBe(1)\n    })\n\n    it('inline expression', function (done) {\n      var vm = new Vue({\n        el: el,\n        template: '<a v-on=\"click:a++\">{{a}}</a>',\n        data: {a:1}\n      })\n      var a = el.firstChild\n      trigger(a, 'click')\n      _.nextTick(function () {\n        expect(a.textContent).toBe('2')\n        done()\n      })\n    })\n\n    it('with key filter', function (done) {\n      var vm = new Vue({\n        el: el,\n        template: '<a v-on=\"keyup:test | key enter\">{{a}}</a>',\n        data: {a:1},\n        methods: {\n          test: function () {\n            this.a++\n          }\n        }\n      })\n      var a = el.firstChild\n      trigger(a, 'keyup', function (e) {\n        e.keyCode = 13\n      })\n      _.nextTick(function () {\n        expect(a.textContent).toBe('2')\n        done()\n      })\n    })\n\n    it('warn non-function values', function () {\n      var vm = new Vue({\n        el: el,\n        data: { test: 123 },\n        template: '<a v-on=\"keyup:test\"></a>'\n      })\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n    it('iframe', function () {\n      // iframes only gets contentWindow when inserted\n      // into the document\n      document.body.appendChild(el)\n      var spy = jasmine.createSpy()\n      var vm = new Vue({\n        el: el,\n        template: '<iframe v-on=\"click:test\"></iframe>',\n        methods: {\n          test: spy\n        }\n      })\n      var iframeDoc = el.firstChild.contentDocument\n      trigger(iframeDoc, 'click')\n      expect(spy.calls.count()).toBe(1)\n      vm.$destroy()\n      trigger(iframeDoc, 'click')\n      expect(spy.calls.count()).toBe(1)\n      document.body.removeChild(el)\n    })\n\n    it('passing $event', function () {\n      var test = jasmine.createSpy()\n      var vm = new Vue({\n        el: el,\n        template: '<a v-on=\"click:test($event)\"></a>',\n        methods: {\n          test: test\n        }\n      })\n      var e = trigger(el.firstChild, 'click')\n      expect(test).toHaveBeenCalledWith(e)\n    })\n\n    it('passing $event on a nested instance', function () {\n      var test = jasmine.createSpy()\n      var parent = new Vue({\n        methods: {\n          test: test\n        }\n      })\n      var child = parent.$addChild({\n        el: el,\n        inherit: true,\n        template: '<a v-on=\"click:test($event)\"></a>'\n      })\n      var e = trigger(el.firstChild, 'click')\n      expect(test).toHaveBeenCalledWith(e)\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/on_spec.js\n ** module id = 84\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar Vue = require('../../../../src/vue')\n\nif (_.inBrowser) {\n  describe('v-pre', function () {\n\n    it('should work', function () {\n      var vm = new Vue({\n        el: document.createElement('div'),\n        template: '<div v-pre>{{a}}</div>',\n        data: {\n          a: 123\n        }\n      })\n      expect(vm.$el.firstChild.textContent).toBe('{{a}}')\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/pre_spec.js\n ** module id = 85\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar Vue = require('../../../../src/vue')\n\nif (_.inBrowser) {\n  describe('v-ref', function () {\n\n    var el\n    beforeEach(function () {\n      el = document.createElement('div')\n      spyOn(_, 'warn')\n    })\n\n    var components = {\n      test: {\n        id: 'test'\n      },\n      test2: {\n        id: 'test2'\n      }\n    }\n\n    it('normal', function () {\n      var vm = new Vue({\n        el: el,\n        components: components,\n        template: '<div v-component=\"test\" v-ref=\"test\"></div>'\n      })\n      expect(vm.$.test).toBeTruthy()\n      expect(vm.$.test.$options.id).toBe('test')\n    })\n\n    it('with dynamic v-component', function (done) {\n      var vm = new Vue({\n        el: el,\n        components: components,\n        data: { test: 'test' },\n        template: '<div v-component=\"{{test}}\" v-ref=\"test\"></div>'\n      })\n      expect(vm.$.test.$options.id).toBe('test')\n      vm.test = 'test2'\n      _.nextTick(function () {\n        expect(vm.$.test.$options.id).toBe('test2')\n        vm.test = ''\n        _.nextTick(function () {\n          expect(vm.$.test).toBeNull()\n          done()          \n        })\n      })\n    })\n\n    it('should also work in child template', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: { view: 'test1' },\n        template: '<div v-component=\"{{view}}\"></div>',\n        components: {\n          test1: {\n            id: 'test1',\n            template: '<div v-ref=\"test1\"></div>',\n            replace: true\n          },\n          test2: {\n            id: 'test2',\n            template: '<div v-ref=\"test2\"></div>',\n            replace: true\n          }\n        }\n      })\n      expect(vm.$.test1.$options.id).toBe('test1')\n      vm.view = 'test2'\n      _.nextTick(function () {\n        expect(vm.$.test1).toBeNull()\n        expect(vm.$.test2.$options.id).toBe('test2')\n        done()\n      })\n    })\n\n    it('with v-repeat', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: { items: [1,2,3,4,5] },\n        template: '<div v-repeat=\"items\" v-ref=\"test\"></div>'\n      })\n      expect(vm.$.test).toBeTruthy()\n      expect(Array.isArray(vm.$.test)).toBe(true)\n      expect(vm.$.test[0].$value).toBe(1)\n      expect(vm.$.test[4].$value).toBe(5)\n      vm.items = []\n      _.nextTick(function () {\n        expect(vm.$.test.length).toBe(0)\n        vm._directives[0].unbind()\n        expect(vm.$.test).toBeNull()\n        done()\n      })\n    })\n\n    it('nested v-repeat', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-component=\"c1\" v-ref=\"c1\"></div>',\n        components: {\n          c1: {\n            template: '<div v-repeat=\"2\" v-ref=\"c2\"></div>'\n          }\n        }\n      })\n      expect(vm.$.c1 instanceof Vue).toBe(true)\n      expect(vm.$.c2).toBeUndefined()\n      expect(Array.isArray(vm.$.c1.$.c2)).toBe(true)\n      expect(vm.$.c1.$.c2.length).toBe(2)\n    })\n\n    it('should warn on non-root', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-ref=\"test\"></div>'\n      })\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/ref_spec.js\n ** module id = 87\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar Vue = require('../../../../src/vue')\n\nif (_.inBrowser) {\n  describe('v-repeat', function () {\n\n    var el\n    beforeEach(function () {\n      el = document.createElement('div')\n      spyOn(_, 'warn')\n    })\n\n    it('objects', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: [{a:1}, {a:2}]\n        },\n        template: '<div v-repeat=\"items\">{{$index}} {{a}}</div>'\n      })\n      assertMutations(vm, el, done)\n    })\n\n    it('primitive values', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: [2, 1, 2]\n        },\n        template: '<div v-repeat=\"items\">{{$index}} {{$value}}</div>'\n      })\n      assertPrimitiveMutations(vm, el, done)\n    })\n\n    it('objects with identifier', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: [{a:1}, {a:2}]\n        },\n        template: '<div v-repeat=\"item:items\">{{$index}} {{item.a}}</div>'\n      })\n      assertMutations(vm, el, done)\n    })\n\n    it('primitive with identifier', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: [2, 1, 2]\n        },\n        template: '<div v-repeat=\"item:items\">{{$index}} {{item}}</div>'\n      })\n      assertPrimitiveMutations(vm, el, done)\n    })\n\n    it('repeating an object of objects', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: {\n            a: {a:1},\n            b: {a:2}\n          }\n        },\n        template: '<div v-repeat=\"items\">{{$index}} {{$key}} {{a}}</div>'\n      })\n      assertObjectMutations(vm, el, done)\n    })\n\n    it('repeating an object of primitives', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: {\n            a: 1,\n            b: 2\n          }\n        },\n        template: '<div v-repeat=\"items\">{{$index}} {{$key}} {{$value}}</div>'\n      })\n      assertObjectPrimitiveMutations(vm, el, done)\n    })\n\n    it('repeating an object of objects with identifier', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: {\n            a: {a:1},\n            b: {a:2}\n          }\n        },\n        template: '<div v-repeat=\"item:items\">{{$index}} {{$key}} {{item.a}}</div>'\n      })\n      assertObjectMutations(vm, el, done)\n    })\n\n    it('repeating an object of primitives with identifier', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: {\n            a: 1,\n            b: 2\n          }\n        },\n        template: '<div v-repeat=\"item:items\">{{$index}} {{$key}} {{item}}</div>'\n      })\n      assertObjectPrimitiveMutations(vm, el, done)\n    })\n\n    it('array of arrays', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: [[1,1], [2,2], [3,3]]\n        },\n        template: '<div v-repeat=\"items\">{{$index}} {{$value}}</div>'\n      })\n      var markup = vm.items.map(function (item, i) {\n        return '<div>' + i + ' ' + item.toString() + '</div>'\n      }).join('') + '<!--v-repeat-->'\n      expect(el.innerHTML).toBe(markup)\n    })\n\n    it('repeating object with filter', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: {\n            a: { msg: 'aaa' },\n            b: { msg: 'bbb' }\n          }\n        },\n        template: '<div v-repeat=\"items | filterBy \\'aaa\\'\">{{msg}}</div>'\n      })\n      expect(el.innerHTML).toBe('<div>aaa</div><!--v-repeat-->')\n    })\n\n    it('v-component', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: [{a:1}, {a:2}]\n        },\n        template: '<p v-repeat=\"items\" v-component=\"test\"></p>',\n        components: {\n          test: {\n            template: '<div>{{$index}} {{a}}</div>',\n            replace: true\n          }\n        }\n      })\n      assertMutations(vm, el, done)\n    })\n\n    it('v-component with inline-template', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: [{a:1}, {a:2}]\n        },\n        template:\n          '<div v-repeat=\"items\" v-component=\"test\" inline-template>' +\n            '{{$index}} {{a}}' +\n          '</div>',\n        components: {\n          test: {}\n        }\n      })\n      assertMutations(vm, el, done)\n    })\n\n    it('v-component with primitive values', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: [2, 1, 2]\n        },\n        template: '<p v-repeat=\"items\" v-component=\"test\"></p>',\n        components: {\n          test: {\n            template: '<div>{{$index}} {{$value}}</div>',\n            replace: true\n          }\n        }\n      })\n      assertPrimitiveMutations(vm, el, done)\n    })\n\n    it('v-component with object of objects', function (done) {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: {\n            a: {a:1},\n            b: {a:2}\n          }\n        },\n        template: '<p v-repeat=\"items\" v-component=\"test\"></p>',\n        components: {\n          test: {\n            template: '<div>{{$index}} {{$key}} {{a}}</div>',\n            replace: true\n          }\n        }\n      })\n      assertObjectMutations(vm, el, done)\n    })\n\n    it('custom element component', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: [{a:1}, {a:2}, {a:3}]\n        },\n        template: '<test-component v-repeat=\"items\"></test-component>',\n        components: {\n          'test-component': {\n            template: '{{$index}} {{a}}'\n          }\n        }\n      })\n      expect(el.innerHTML).toBe(\n        '<test-component>0 1</test-component>' +\n        '<test-component>1 2</test-component>' +\n        '<test-component>2 3</test-component>' +\n        '<!--v-repeat-->'\n      )\n    })\n\n    it('custom element component with replace:true', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: [{a:1}, {a:2}, {a:3}]\n        },\n        template: '<test-component v-repeat=\"items\"></test-component>',\n        components: {\n          'test-component': {\n            template: '<p>{{$index}} {{a}}</p>',\n            replace: true\n          }\n        }\n      })\n      expect(el.innerHTML).toBe('<p>0 1</p><p>1 2</p><p>2 3</p><!--v-repeat-->')\n    })\n\n    it('nested repeats', function () {\n      var vm = new Vue({\n        el: el,\n        data: {\n          items: [\n            { items: [{a:1}, {a:2}], a: 1 },\n            { items: [{a:3}, {a:4}], a: 2 }\n          ]\n        },\n        template: '<div v-repeat=\"items\">' +\n            '<p v-repeat=\"items\">{{$index}} {{a}} {{$parent.$index}} {{$parent.a}}</p>' +\n          '</div>'\n      })\n      expect(el.innerHTML).toBe(\n        '<div><p>0 1 0 1</p><p>1 2 0 1</p><!--v-repeat--></div>' +\n        '<div><p>0 3 1 2</p><p>1 4 1 2</p><!--v-repeat--></div>' +\n        '<!--v-repeat-->'\n      )\n    })\n\n    it('nested repeats on object', function(){\n      var vm = new Vue({\n        el: el,\n        data: {\n          listHash: {\n            listA: [{a: 1},{a: 2}],\n            listB: [{a: 1},{a: 2}]\n          }\n        },\n        template: '<div v-repeat=\"listHash\">{{$key}}' +\n            '<p v-repeat=\"$value\">{{a}}</p>' +\n            '</div>'\n      })\n      function output(key){\n        var key1 = key === 'listA' ? 'listB' : 'listA'\n        return  '<div>'+ key +'<p>1</p><p>2</p><!--v-repeat--></div>' +\n                '<div>'+ key1 +'<p>1</p><p>2</p><!--v-repeat--></div>' +\n                '<!--v-repeat-->'\n      }\n      expect(el.innerHTML === output('listA') || el.innerHTML === output('listB')).toBeTruthy()\n    })\n\n    it('dynamic component type based on instance data', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"list\" v-component=\"view-{{type}}\"></div>',\n        data: {\n          list: [\n            { type: 'a' },\n            { type: 'b' },\n            { type: 'c' }\n          ]\n        },\n        components: {\n          'view-a': {\n            template: 'AAA'\n          },\n          'view-b': {\n            template: 'BBB'\n          },\n          'view-c': {\n            template: 'CCC'\n          }\n        }\n      })\n      expect(el.innerHTML).toBe('<div>AAA</div><div>BBB</div><div>CCC</div><!--v-repeat-->')\n      // #458 meta properties\n      vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"list\" v-component=\"view-{{$value}}\"></div>',\n        data: {\n          list: ['a', 'b', 'c']\n        },\n        components: {\n          'view-a': {\n            template: 'AAA'\n          },\n          'view-b': {\n            template: 'BBB'\n          },\n          'view-c': {\n            template: 'CCC'\n          }\n        }\n      })\n      expect(el.innerHTML).toBe('<div>AAA</div><div>BBB</div><div>CCC</div><!--v-repeat-->')\n    })\n\n    it('block repeat', function (done) {\n      var vm = new Vue({\n        el: el,\n        template: '<template v-repeat=\"list\"><p>{{a}}</p><p>{{a + 1}}</p></template>',\n        data: {\n          list: [\n            { a: 1 },\n            { a: 2 },\n            { a: 3 }\n          ]\n        }\n      })\n      assertMarkup()\n      vm.list.reverse()\n      _.nextTick(function () {\n        assertMarkup()\n        done()\n      })\n\n      function assertMarkup () {\n        var markup = vm.list.map(function (item) {\n          return '<!--v-start--><p>' + item.a + '</p><p>' + (item.a + 1) + '</p><!--v-end-->'\n        }).join('')\n        expect(el.innerHTML).toBe(markup + '<!--v-repeat-->')\n      }\n    })\n\n    // added for #799\n    it('block repeat with diff', function (done) {\n      var vm = new Vue({\n        el: el,\n        template: '<template v-repeat=\"list\" v-component=\"test\"></template>',\n        data: {\n          list: [\n            { a: 1 },\n            { a: 2 },\n            { a: 3 }\n          ]\n        },\n        components: {\n          test: {\n            template: '<p>{{a}}</p><p>{{a + 1}}</p>'\n          }\n        }\n      })\n      assertMarkup()\n      vm.list.reverse()\n      _.nextTick(function () {\n        assertMarkup()\n        done()\n      })\n\n      function assertMarkup () {\n        var markup = vm.list.map(function (item) {\n          return '<!--v-start--><p>' + item.a + '</p><p>' + (item.a + 1) + '</p><!--v-end-->'\n        }).join('')\n        expect(el.innerHTML).toBe(markup + '<!--v-repeat-->')\n      }\n    })\n\n    it('component + parent directive + transclusion', function (done) {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"list\" v-component=\"test\" v-class=\"cls\">{{msg}}</div>',\n        data: {\n          cls: 'parent',\n          msg: 'hi',\n          list: [{a:1},{a:2},{a:3}]\n        },\n        components: {\n          test: {\n            replace: true,\n            template: '<div class=\"child\">{{a}} <content></content></div>'\n          }\n        }\n      })\n      var markup = vm.list.map(function (item) {\n        return '<div class=\"child parent\">' + item.a + ' hi</div>'\n      }).join('')\n      expect(el.innerHTML).toBe(markup + '<!--v-repeat-->')\n      vm.msg = 'ho'\n      markup = vm.list.map(function (item) {\n        return '<div class=\"child parent\">' + item.a + ' ho</div>'\n      }).join('')\n      _.nextTick(function () {\n        expect(el.innerHTML).toBe(markup + '<!--v-repeat-->')\n        done()\n      })\n    })\n\n    it('array filters', function (done) {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"list | filterBy filterKey | orderBy sortKey -1\">{{id}}</div>',\n        data: {\n          filterKey: 'hi!',\n          sortKey: 'id',\n          list: [\n            { id: 1, id2: 4, msg: 'hi!' },\n            { id: 2, id2: 3, msg: 'na' },\n            { id: 3, id2: 2, msg: 'hi!' },\n            { id: 4, id2: 1, msg: 'na' }\n          ]\n        }\n      })\n      assertMarkup()\n\n      go(\n        function () {\n          vm.filterKey = 'na'\n        }, assertMarkup\n      )\n      .then(\n        function () {\n          vm.sortKey = 'id2'\n        }, assertMarkup\n      )\n      .then(\n        function () {\n          vm.list[0].id2 = 0\n        }, assertMarkup\n      )\n      .then(\n        function () {\n          vm.list.push({ id: 0, id2: 4, msg: 'na' })\n        }, assertMarkup\n      )\n      .then(\n        function () {\n          vm.list = [\n            { id: 33, id2: 4, msg: 'hi!' },\n            { id: 44, id2: 3, msg: 'na' }\n          ]\n        }, assertMarkup\n      )\n      .run(done)\n\n      function assertMarkup () {\n        var markup = vm.list\n          .filter(function (item) {\n            return item.msg === vm.filterKey\n          })\n          .sort(function (a, b) {\n            return a[vm.sortKey] > b[vm.sortKey] ? -1 : 1\n          })\n          .map(function (item) {\n            return '<div>' + item.id + '</div>'\n          }).join('')\n        expect(el.innerHTML).toBe(markup + '<!--v-repeat-->')\n      }\n    })\n\n    it('orderBy supporting $key for object repeaters', function (done) {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"obj | orderBy sortKey\">{{$value}}</div>',\n        data: {\n          sortKey: '$key',\n          obj: {\n            c: 1,\n            a: 3,\n            b: 2\n          }\n        }\n      })\n      expect(el.innerHTML).toBe('<div>3</div><div>2</div><div>1</div><!--v-repeat-->')\n      vm.sortKey = '$value'\n      _.nextTick(function () {\n        expect(el.innerHTML).toBe('<div>1</div><div>2</div><div>3</div><!--v-repeat-->')\n        done()\n      })\n    })\n\n    it('orderBy supporting $value for primitive arrays', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"list | orderBy \\'$value\\'\">{{$value}}</div>',\n        data: {\n          list: [3, 2, 1]\n        }\n      })\n      expect(el.innerHTML).toBe('<div>1</div><div>2</div><div>3</div><!--v-repeat-->')\n    })\n\n    it('track by id', function (done) {\n\n      assertTrackBy('<div v-repeat=\"list\" v-component=\"test\" track-by=\"id\"></div>', '{{msg}}', function () {\n        assertTrackBy('<div v-repeat=\"item:list\" v-component=\"test\" track-by=\"id\"></div>', '{{item.msg}}', done)\n      })\n      \n      function assertTrackBy (template, componentTemplate, next) {\n        var vm = new Vue({\n          el: el,\n          template: template,\n          data: {\n            list: [\n              { id: 1, msg: 'hi' },\n              { id: 2, msg: 'ha' },\n              { id: 3, msg: 'ho' }\n            ]\n          },\n          components: {\n            test: {\n              template: componentTemplate\n            }\n          }\n        })\n        assertMarkup()\n        var oldVms = vm._children.slice()\n        // swap the data with different objects, but with\n        // the same ID!\n        vm.list = [\n          { id: 1, msg: 'wa' },\n          { id: 2, msg: 'wo' }\n        ]\n        _.nextTick(function () {\n          assertMarkup()\n          // should reuse old vms!\n          var i = 2\n          while (i--) {\n            expect(vm._children[i]).toBe(oldVms[i])\n          }\n          next()\n        })\n\n        function assertMarkup () {\n          var markup = vm.list.map(function (item) {\n            return '<div>' + item.msg + '</div>'\n          }).join('')\n          expect(el.innerHTML).toBe(markup + '<!--v-repeat-->')\n        }\n      }\n    })\n\n    it('warn duplicate objects', function () {\n      var obj = {}\n      var vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"items\" v-component=\"test\"></div>',\n        data: {\n          items: [obj, obj]\n        },\n        components: {\n          test: {}\n        }\n      })\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n    it('warn duplicate trackby id', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"items\" v-component=\"test\" track-by=\"id\"></div>',\n        data: {\n          items: [{id:1}, {id:1}]\n        },\n        components: {\n          test: {}\n        }\n      })\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n    it('warn v-if', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"items\" v-if=\"aaa\"></div>',\n        data: {\n          items: []\n        }\n      })\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n    it('repeat number', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"3\">{{$index}} {{$value}}</div>'\n      })\n      expect(el.innerHTML).toBe('<div>0 0</div><div>1 1</div><div>2 2</div><!--v-repeat-->')\n    })\n\n    it('repeat string', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"\\'vue\\'\">{{$index}} {{$value}}</div>'\n      })\n      expect(el.innerHTML).toBe('<div>0 v</div><div>1 u</div><div>2 e</div><!--v-repeat-->')\n    })\n\n    it('teardown', function () {\n      var vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"items\" v-component=\"test\"></div>',\n        data: {\n          items: [{a:1}, {a:2}]\n        },\n        components: {\n          test: {}\n        }\n      })\n      vm._directives[0].unbind()\n      expect(vm._children.length).toBe(0)\n    })\n\n    it('with transition', function (done) {\n      document.body.appendChild(el)\n      var vm = new Vue({\n        el: el,\n        template: '<div v-repeat=\"items\" v-transition=\"test\">{{a}}</div>',\n        data: {\n          items: [{a:1}, {a:2}, {a:3}]\n        },\n        transitions: {\n          test: {\n            leave: function (el, done) {\n              setTimeout(done, 1)\n            }\n          }\n        }\n      })\n      vm.items.splice(1, 1, {a:4})\n      setTimeout(function () {\n        expect(el.innerHTML).toBe('<div>1</div><div>4</div><div>3</div><!--v-repeat-->')\n        document.body.removeChild(el)\n        done()\n      }, 30)\n    })\n\n    it('sync $value changes back to original array/object', function (done) {\n      var vm = new Vue({\n        el: el,\n        template:\n          '<div v-repeat=\"items\">{{$value}}</div>' +\n          '<div v-repeat=\"obj\">{{$value}}</div>',\n        data: {\n          items: ['a', 'b'],\n          obj: { foo: 'a', bar: 'b' }\n        }\n      })\n      vm._children[0].$value = 'c'\n      var key = vm._children[2].$key\n      vm._children[2].$value = 'd'\n      _.nextTick(function () {\n        expect(vm.items[0]).toBe('c')\n        expect(vm.obj[key]).toBe('d')\n        done()\n      })\n    })\n\n    it('nested track by', function (done) {\n      assertTrackBy('<div v-repeat=\"list\" track-by=\"id\">{{msg}}<div v-repeat=\"list\" track-by=\"id\">{{msg}}</div></div>', function () {\n        assertTrackBy('<div v-transition v-repeat=\"list\" track-by=\"id\">{{msg}}<div v-transition v-repeat=\"list\" track-by=\"id\">{{msg}}</div></div>', done)\n      })\n\n      function assertTrackBy(template, next) {\n        var vm = new Vue({\n          el: el,\n          data: {\n            list: [\n              { id: 1, msg: 'hi', list: [\n                { id: 1, msg: 'hi foo' }\n              ] },\n              { id: 2, msg: 'ha', list: [] },\n              { id: 3, msg: 'ho', list: [] }\n            ]\n          },\n          template: template\n        })\n        assertMarkup()\n\n        var oldVms = vm._children.slice()\n\n        vm.list = [\n          { id: 1, msg: 'wa', list: [\n            { id: 1, msg: 'hi foo' },\n            { id: 2, msg: 'hi bar' }\n          ] },\n          { id: 2, msg: 'wo', list: [] }\n        ]\n\n        _.nextTick(function () {\n          assertMarkup()\n          // should reuse old vms!\n          var i = 2\n          while (i--) {\n            expect(vm._children[i]).toBe(oldVms[i])\n          }\n          expect(vm._children[0]._children[0]).toBe(oldVms[0]._children[0])\n          next()\n        })\n\n        function assertMarkup () {\n          var markup = vm.list.map(function (item) {\n            var sublist = item.list.map(function (item) {\n              return '<div>' + item.msg + '</div>'\n            }).join('') + '<!--v-repeat-->'\n            return '<div>' + item.msg + sublist + '</div>'\n          }).join('') + '<!--v-repeat-->'\n          expect(el.innerHTML).toBe(markup)\n        }\n      }\n    })\n\n  })\n}\n\n/**\n * Simple helper for chained async asssertions\n *\n * @param {Function} fn - the data manipulation function\n * @param {Function} cb - the assertion fn to be called on nextTick\n */\n\nfunction go (fn, cb) {\n  return {\n    stack: [{fn:fn, cb:cb}],\n    then: function (fn, cb) {\n      this.stack.push({fn:fn, cb:cb})\n      return this\n    },\n    run: function (done) {\n      var self = this\n      var step = this.stack.shift()\n      if (!step) return done()\n      step.fn()\n      _.nextTick(function () {\n        step.cb()\n        self.run(done)\n      })\n    }\n  }\n}\n\n/**\n * Assert mutation and markup correctness for v-repeat on\n * an Array of Objects\n */\n\nfunction assertMutations (vm, el, done) {\n  assertMarkup()\n  var poppedItem\n  go(\n    function () {\n      vm.items.push({a:3})\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.shift()    \n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.reverse()\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      poppedItem = vm.items.pop()\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.unshift(poppedItem)\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.sort(function (a, b) {\n        return a.a > b.a ? 1 : -1\n      })\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.splice(1, 1, {a:5})\n    },\n    assertMarkup\n  )\n  // test swapping the array\n  .then(\n    function () {\n      vm.items = [{a:0}, {a:1}, {a:2}]\n    },\n    assertMarkup\n  )\n  .run(done)\n\n  function assertMarkup () {\n    var markup = vm.items.map(function (item, i) {\n      return '<div>' + i + ' ' + item.a + '</div>'\n    }).join('')\n    expect(el.innerHTML).toBe(markup + '<!--v-repeat-->')\n  }\n}\n\n/**\n * Assert mutation and markup correctness for v-repeat on\n * an Array of primitive values\n */\n\nfunction assertPrimitiveMutations (vm, el, done) {\n  assertMarkup()\n  go(\n    function () {\n      // check duplicate\n      vm.items.push(2, 2, 3)\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.shift()    \n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.reverse()\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.pop()\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.unshift(3)\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.sort(function (a, b) {\n        return a > b ? 1 : -1\n      })\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.splice(1, 1, 5)\n    },\n    assertMarkup\n  )\n  // test swapping the array\n  .then(\n    function () {\n      vm.items = [1, 2, 2]\n    },\n    assertMarkup\n  )\n  .run(done)\n\n  function assertMarkup () {\n    var markup = vm.items.map(function (item, i) {\n      return '<div>' + i + ' ' + item + '</div>'\n    }).join('')\n    expect(el.innerHTML).toBe(markup + '<!--v-repeat-->')\n  }\n}\n\n/**\n * Assert mutation and markup correctness for v-repeat on\n * an Object of Objects\n */\n\nfunction assertObjectMutations (vm, el, done) {\n  assertMarkup()\n  go(\n    function () {\n      vm.items.a = {a:3}\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items = {\n        c: {a:1},\n        d: {a:2}\n      }\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.$add('a', {a:3})\n    },\n    assertMarkup\n  )\n  .run(done)\n\n  function assertMarkup () {\n    var markup = Object.keys(vm.items).map(function (key, i) {\n      return '<div>' + i + ' ' + key + ' ' + vm.items[key].a + '</div>'\n    }).join('')\n    expect(el.innerHTML).toBe(markup + '<!--v-repeat-->')\n  }\n}\n\n/**\n * Assert mutation and markup correctness for v-repeat on\n * an Object of primitive values\n */\n\nfunction assertObjectPrimitiveMutations (vm, el, done) {\n  assertMarkup()\n  go(\n    function () {\n      vm.items.a = 3\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items = {\n        c: 1,\n        d: 2\n      }\n    },\n    assertMarkup\n  )\n  .then(\n    function () {\n      vm.items.$add('a', 3)\n    },\n    assertMarkup\n  )\n  .run(done)\n\n  function assertMarkup () {\n    var markup = Object.keys(vm.items).map(function (key, i) {\n      return '<div>' + i + ' ' + key + ' ' + vm.items[key] + '</div>'\n    }).join('')\n    expect(el.innerHTML).toBe(markup + '<!--v-repeat-->')\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/repeat_spec.js\n ** module id = 88\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar Vue = require('../../../../src/vue')\nvar transition = require('../../../../src/transition')\nvar def = require('../../../../src/directives/show')\n\nif (_.inBrowser) {\n  describe('v-show', function () {\n\n    var el\n    beforeEach(function () {\n      el = document.createElement('div')\n      spyOn(transition, 'apply').and.callThrough()\n    })\n\n    it('should work', function () {\n      var dir = {\n        el: el,\n        update: def,\n        vm: new Vue()\n      }\n      dir.update(false)\n      expect(el.style.display).toBe('none')\n      dir.update(true)\n      expect(el.style.display).toBe('')\n      expect(transition.apply).toHaveBeenCalled()\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/show_spec.js\n ** module id = 89\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar def = require('../../../../src/directives/style')\nvar Vue = require('../../../../src/vue')\n\nfunction checkPrefixedProp (prop) {\n  var el = document.createElement('div')\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1)\n  if (!(prop in el.style)) {\n    var prefixes = ['Webkit', 'Moz', 'ms']\n    var i = prefixes.length\n    while (i--) {\n      if ((prefixes[i] + upper) in el.style) {\n        prop = prefixes[i] + upper\n      }\n    }  \n  }\n  return prop\n}\n\nif (_.inBrowser) {\n  describe('v-style', function () {\n\n    var el, dir\n    beforeEach(function () {\n      el = document.createElement('div')\n      dir = { el: el }\n      _.extend(dir, def)      \n    })\n\n    it('normal with arg', function () {\n      dir.arg = 'color'\n      dir.update('red')\n      expect(el.style.color).toBe('red')\n    })\n\n    it('normal no arg', function () {\n      dir.update('color:red;')\n      expect(el.style.cssText.replace(/\\s/g, '')).toBe('color:red;')\n    })\n\n    it('!important', function () {\n      dir.arg = 'color'\n      dir.update('red !important;')\n      expect(el.style.getPropertyPriority('color')).toBe('important')\n    })\n\n    it('camel case', function () {\n      dir.arg = 'marginLeft'\n      dir.update('30px')\n      expect(el.style.marginLeft).toBe('30px')\n    })\n\n    it('remove on falsy value', function () {\n      el.style.color = 'red'\n      dir.arg = 'color'\n      dir.update(null)\n      expect(el.style.color).toBe('')\n    })\n\n    it('ignore unsupported property', function () {\n      dir.arg = 'unsupported'\n      dir.update('test')\n      expect(el.style.unsupported).not.toBe('test')\n    })\n\n    it('auto prefixing', function () {\n      var prop = checkPrefixedProp('transform')\n      dir.arg = 'transform'\n      var val = 'scale(0.5)'\n      dir.update(val)\n      expect(el.style[prop]).toBe(val)\n    })\n\n    it('update with object', function () {\n      dir.update({color: 'red', marginRight: '30px'})\n      expect(el.style.getPropertyValue('color')).toBe('red')\n      expect(el.style.getPropertyValue('margin-right')).toBe('30px')\n    })\n\n    it('update with object and auto prefix', function () {\n      var prop = checkPrefixedProp('transform')\n      var val = 'scale(0.5)';\n      dir.update({transform: val})\n      expect(el.style[prop]).toBe(val)\n    })\n\n    it('updates object deep', function (done) {\n      el.setAttribute('v-style', 'divStyling')\n      var vm = new Vue({\n        el: el,\n        data: {divStyling: { display: 'none'}}\n      })\n      expect(el.style.display).toBe('none')\n      vm.divStyling.display = 'block'\n      _.nextTick(function () {\n        expect(el.style.display).toBe('block')\n        done()\n      })\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/style_spec.js\n ** module id = 90\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar def = require('../../../../src/directives/text')\n\nif (_.inBrowser) {\n  describe('v-text', function () {\n\n    it('element', function () {\n      var dir = {\n        el: document.createElement('div')\n      }\n      _.extend(dir, def)\n      dir.bind()\n      dir.update('hi')\n      expect(dir.el.textContent).toBe('hi')\n      dir.update(123)\n      expect(dir.el.textContent).toBe('123')\n    })\n\n    it('text node', function () {\n      var dir = {\n        el: document.createTextNode(' ')\n      }\n      _.extend(dir, def)\n      dir.bind()\n      dir.update('hi')\n      expect(dir.el.nodeValue).toBe('hi')\n      dir.update(123)\n      expect(dir.el.nodeValue).toBe('123')\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/text_spec.js\n ** module id = 91\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar Vue = _.Vue\nvar def = require('../../../../src/directives/transition')\n\nif (_.inBrowser) {\n  describe('v-transition', function () {\n\n    it('should save the transition id and custom functions as data', function () {\n      var fns = {}\n      var dir = {\n        el: document.createElement('div'),\n        expression: 'test',\n        bind: def.bind,\n        update: def.update,\n        vm: {\n          $options: {\n            transitions: {\n              test: fns\n            }\n          }\n        }\n      }\n      dir.bind()\n      expect(dir.el.__v_trans.id).toBe('test')\n      expect(dir.el.__v_trans.fns).toBe(fns)\n    })\n\n    it('dynamic transitions', function (done) {\n      var el = document.createElement('div')\n      document.body.appendChild(el)\n      var calls = {\n        a: { enter: 0, leave: 0 },\n        b: { enter: 0, leave: 0 }\n      }\n      var vm = new Vue({\n        el: el,\n        template: '<div v-show=\"show\" v-transition=\"{{trans}}\"></div>',\n        data: {\n          show: true,\n          trans: 'a'\n        },\n        transitions: {\n          a: {\n            enter: function (el, done) {\n              calls.a.enter++\n              done()\n            },\n            leave: function (el, done) {\n              calls.a.leave++\n              done()\n            }\n          },\n          b: {\n            enter: function (el, done) {\n              calls.b.enter++\n              done()\n            },\n            leave: function (el, done) {\n              calls.b.leave++\n              done()\n            }\n          }\n        }\n      })\n\n      assertCalls(0, 0, 0, 0)\n      vm.show = false\n      _.nextTick(function () {\n        assertCalls(0, 1, 0, 0)\n        vm.trans = 'b'\n        vm.show = true\n        _.nextTick(function () {\n          assertCalls(0, 1, 1, 0)\n          vm.show = false\n          _.nextTick(function () {\n            assertCalls(0, 1, 1, 1)\n            vm.trans = 'a'\n            vm.show = true\n            _.nextTick(function () {\n              assertCalls(1, 1, 1, 1)\n              done()\n            })\n          })\n        })\n      })\n\n      function assertCalls (a, b, c, d) {\n        expect(el.firstChild.style.display).toBe(vm.show ? '' : 'none')\n        expect(calls.a.enter).toBe(a)\n        expect(calls.a.leave).toBe(b)\n        expect(calls.b.enter).toBe(c)\n        expect(calls.b.leave).toBe(d)\n      }\n\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/directives/transition_spec.js\n ** module id = 92\n ** module chunks = 0\n **/","var Vue = require('../../../../src/vue')\nvar filters = require('../../../../src/filters')\n\ndescribe('Filters', function () {\n\n  it('json read', function () {\n    var filter = filters.json.read\n    var obj = {a:{b:2}}\n    expect(filter(obj)).toBe(JSON.stringify(obj, null, 2))\n    expect(filter(obj, 4)).toBe(JSON.stringify(obj, null, 4))\n    // plain string\n    expect(filter('1234')).toBe('1234')\n  })\n\n  it('json write', function () {\n    var filter = filters.json.write\n    var obj = '{\"a\":{\"b\":2}}'\n    expect(JSON.stringify(filter(obj))).toBe(obj)\n    // error condition\n    var invalidJSON = '{\"a\":}'\n    expect(filter(invalidJSON)).toBe(invalidJSON)\n  })\n  \n  it('capitalize', function () {\n    var filter = filters.capitalize\n    var res = filter('fsefsfsef')\n    expect(res.charAt(0)).toBe('F')\n    expect(res.slice(1)).toBe('sefsfsef')\n    assertNumberAndFalsy(filter)\n  })\n\n  it('uppercase', function () {\n    var filter = filters.uppercase\n    expect(filter('fsefef')).toBe('FSEFEF')\n    assertNumberAndFalsy(filter)\n  })\n\n  it('lowercase', function () {\n    var filter = filters.lowercase\n    expect(filter('AWEsoME')).toBe('awesome')\n    assertNumberAndFalsy(filter)\n  })\n\n  it('pluralize', function () {\n    var filter = filters.pluralize\n    // single arg\n    var arg = 'item'\n    expect(filter(0, arg)).toBe('items')\n    expect(filter(1, arg)).toBe('item')\n    expect(filter(2, arg)).toBe('items')\n    // multi args\n    expect(filter(0, 'st', 'nd', 'rd', 'th')).toBe('th')\n    expect(filter(1, 'st', 'nd', 'rd', 'th')).toBe('st')\n    expect(filter(2, 'st', 'nd', 'rd', 'th')).toBe('nd')\n    expect(filter(3, 'st', 'nd', 'rd', 'th')).toBe('rd')\n    expect(filter(4, 'st', 'nd', 'rd', 'th')).toBe('th')\n  })\n\n  it('currency', function () {\n    var filter = filters.currency\n    // default\n    expect(filter(1234)).toBe('$1,234.00')\n    expect(filter(1234.45)).toBe('$1,234.45')\n    expect(filter(123443434.4343434)).toBe('$123,443,434.43')\n    expect(filter(0.99999)).toBe('$0.99')\n    // sign arg\n    expect(filter(2134, '@')).toBe('@2,134.00')\n    // falsy, infinity and 0\n    expect(filter(0)).toBe('$0.00')\n    expect(filter(false)).toBe('')\n    expect(filter(null)).toBe('')\n    expect(filter(undefined)).toBe('')\n    expect(filter(Infinity)).toBe('')\n    // negative numbers\n    expect(filter(-50)).toBe('-$50.00')\n    expect(filter(-150.43)).toBe('-$150.43')\n    expect(filter(-1500.4343434)).toBe('-$1,500.43')\n  })\n\n  it('key', function () {\n    var filter = filters.key\n    expect(filter(null)).toBeUndefined()\n    var spy = jasmine.createSpy('filter:key')\n    var handler = filter(spy, 'enter')\n    handler({ keyCode: 0 })\n    expect(spy).not.toHaveBeenCalled()\n    handler({ keyCode: 13 })\n    expect(spy).toHaveBeenCalled()\n    // direct keycode\n    spy = jasmine.createSpy('filter:key')\n    handler = filter(spy, 13)\n    handler({ keyCode: 0 })\n    expect(spy).not.toHaveBeenCalled()\n    handler({ keyCode: 13 })\n    expect(spy).toHaveBeenCalled()\n  })\n\n  it('filterBy', function () {\n    var filter = filters.filterBy\n    var arr = [\n      { a: 1, b: { c: 'hello' }},\n      { a: 2, b: 'hello'},\n      { a: 3, b: 2 }\n    ]\n    var vm = new Vue({\n      data: {\n        search: {\n          key: 'hello',\n          datakey: 'b.c',\n          n: 2\n        }\n      }\n    })\n    var res\n    // normal\n    res = filter.call(vm, arr, 'search.key')\n    expect(res.length).toBe(2)\n    expect(res[0]).toBe(arr[0])\n    expect(res[1]).toBe(arr[1])\n    // data key\n    res = filter.call(vm, arr, 'search.key', 'search.datakey')\n    expect(res.length).toBe(1)\n    expect(res[0]).toBe(arr[0])\n    // quotes\n    res = filter.call(vm, arr, \"'hello'\", \"'b.c'\")\n    expect(res.length).toBe(1)\n    expect(res[0]).toBe(arr[0])\n    // delimiter\n    res = filter.call(vm, arr, 'search.key', 'in', 'search.datakey')\n    expect(res.length).toBe(1)\n    expect(res[0]).toBe(arr[0])\n    // no search key\n    res = filter.call(vm, arr, 'abc')\n    expect(res).toBe(arr)\n    // number search key\n    res = filter.call(vm, arr, 'search.n')\n    expect(res[0]).toBe(arr[1])\n  })\n\n  it('orderBy', function () {\n    var filter = filters.orderBy\n    var arr = [\n      { a: { b: 0 }, c: 'b'},\n      { a: { b: 2 }, c: 'c'},\n      { a: { b: 1 }, c: 'a'}\n    ]\n    var res\n    // sort key\n    res = filter.call(new Vue({\n      data: {\n        sortby: 'a.b',\n      }\n    }), arr, 'sortby')\n    expect(res.length).toBe(3)\n    expect(res[0].a.b).toBe(0)\n    expect(res[1].a.b).toBe(1)\n    expect(res[2].a.b).toBe(2)\n    // reverse key\n    res = filter.call(new Vue({\n      data: { sortby: 'a.b', reverse: true }\n    }), arr, 'sortby', 'reverse')\n    expect(res.length).toBe(3)\n    expect(res[0].a.b).toBe(2)\n    expect(res[1].a.b).toBe(1)\n    expect(res[2].a.b).toBe(0)\n    // literal args\n    res = filter.call(new Vue(), arr, \"'c'\", '-1')\n    expect(res.length).toBe(3)\n    expect(res[0].c).toBe('c')\n    expect(res[1].c).toBe('b')\n    expect(res[2].c).toBe('a')\n    // negate reverse\n    res = filter.call(new Vue({\n      data: { reverse: true }\n    }), arr, \"'c'\", '!reverse')\n    expect(res.length).toBe(3)\n    expect(res[0].c).toBe('a')\n    expect(res[1].c).toBe('b')\n    expect(res[2].c).toBe('c')\n    // no sort key\n    res = filter.call(new Vue(), arr, 'abc')\n    expect(res).toBe(arr)\n  })\n})\n\nfunction assertNumberAndFalsy (filter) {\n  // should stringify numbers\n  expect(filter(12345)).toBe('12345')\n  expect(filter(0)).toBe('0')\n  expect(filter(undefined)).toBe('')\n  expect(filter(null)).toBe('')\n  expect(filter(false)).toBe('')\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/filters/filters_spec.js\n ** module id = 93\n ** module chunks = 0\n **/","var Vue = require('../../../../src/vue')\nvar _ = require('../../../../src/util')\n\ndescribe('Instance Events', function () {\n\n  var spy, spy2\n  beforeEach(function () {\n    spy = jasmine.createSpy()\n    spy2 = jasmine.createSpy()\n    spyOn(_, 'warn')\n  })\n\n  describe('option events', function () {\n\n    it('normal events', function () {\n      var vm = new Vue({\n        events: {\n          test: spy,\n          test2: [spy, spy]\n        }\n      })\n      vm.$emit('test', 123)\n      expect(spy).toHaveBeenCalledWith(123)\n      vm.$emit('test2')\n      expect(spy.calls.count()).toBe(3)\n    })\n\n    it('hook events', function () {\n      var vm = new Vue({\n        events: {\n          'hook:created': spy\n        }\n      })\n      expect(spy).toHaveBeenCalled()\n    })\n\n    it('method name strings', function () {\n      var vm = new Vue({\n        events: {\n          test: 'doSomething',\n          test2: 'doSomethingElse'\n        },\n        methods: {\n          doSomething: spy\n        }\n      })\n      vm.$emit('test', 123)\n      expect(spy).toHaveBeenCalledWith(123)\n      vm.$emit('test2')\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n  })\n\n  describe('option watchers', function () {\n\n    it('normal', function (done) {\n      var spyA = jasmine.createSpy()\n      var spyB = jasmine.createSpy()\n      var vm = new Vue({\n        watch: {\n          'a.b.c': spyA,\n          'b + c': spyB\n        },\n        data: {\n          a: {\n            b: { c: 1 }\n          },\n          b: 1,\n          c: 2\n        }\n      })\n      vm.a.b.c = 2\n      vm.b = 3\n      vm.c = 4\n      _.nextTick(function () {\n        expect(spyA).toHaveBeenCalledWith(2, 1)\n        expect(spyB).toHaveBeenCalledWith(7, 3)\n        done()\n      })\n    })\n\n    it('method name strings', function (done) {\n      var spy = jasmine.createSpy()\n      var vm = new Vue({\n        watch: {\n          'a': 'test'\n        },\n        data: {\n          a: 1\n        },\n        methods: {\n          test: spy\n        }\n      })\n      vm.a = 2\n      _.nextTick(function () {\n        expect(spy).toHaveBeenCalledWith(2, 1)\n        done()\n      })\n    })\n\n  })\n\n  describe('hooks', function () {\n    \n    it('created', function () {\n      var ctx\n      var vm = new Vue({\n        created: function () {\n          // can't assert this === vm here\n          // because the constructor hasn't returned yet\n          ctx = this\n          // should have observed data\n          expect(this._data.__ob__).toBeTruthy()\n          spy()\n        }\n      })\n      expect(ctx).toBe(vm)\n      expect(spy).toHaveBeenCalled()\n    })\n\n    it('beforeDestroy', function () {\n      var vm = new Vue({\n        beforeDestroy: function () {\n          expect(this).toBe(vm)\n          expect(this._isDestroyed).toBe(false)\n          spy()\n        }\n      })\n      vm.$destroy()\n      expect(spy).toHaveBeenCalled()\n    })\n\n    it('destroyed', function () {\n      var vm = new Vue({\n        destroyed: function () {\n          expect(this).toBe(vm)\n          expect(this._isDestroyed).toBe(true)\n          expect(this._data).toBeNull()\n          spy()\n        }\n      })\n      vm.$destroy()\n      expect(spy).toHaveBeenCalled()\n    })\n\n    if (Vue.util.inBrowser) {\n\n      it('beforeCompile', function () {\n        var vm = new Vue({\n          template: '{{a}}',\n          data: { a: 1 },\n          beforeCompile: function () {\n            expect(this).toBe(vm)\n            expect(this.$el).toBe(el)\n            expect(this.$el.textContent).toBe('{{a}}')\n            spy()\n          }\n        })\n        var el = document.createElement('div')\n        vm.$mount(el)\n        expect(spy).toHaveBeenCalled()\n      })\n\n      it('compiled', function () {\n        var vm = new Vue({\n          template: '{{a}}',\n          data: { a: 1 },\n          compiled: function () {\n            expect(this.$el).toBe(el)\n            expect(this.$el.textContent).toBe('1')\n            spy()\n          }\n        })\n        var el = document.createElement('div')\n        vm.$mount(el)\n        expect(spy).toHaveBeenCalled()\n      })\n\n      it('ready', function () {\n        var vm = new Vue({\n          ready: spy\n        })\n        expect(spy).not.toHaveBeenCalled()\n        var el = document.createElement('div')\n        vm.$mount(el)\n        expect(spy).not.toHaveBeenCalled()\n        vm.$appendTo(document.body)\n        expect(spy).toHaveBeenCalled()\n        vm.$remove()\n        // try mounting on something already in dom\n        el = document.createElement('div')\n        document.body.appendChild(el)\n        vm = new Vue({\n          el: el,\n          ready: spy2\n        })\n        expect(spy2).toHaveBeenCalled()\n        vm.$remove()\n      })\n\n      describe('attached/detached', function () {\n\n        it('in DOM', function () {\n          var el = document.createElement('div')\n          var childEl = document.createElement('div')\n          el.appendChild(childEl)\n          document.body.appendChild(el)\n          var parentVm = new Vue({\n            el: el,\n            attached: spy,\n            detached: spy2\n          })\n          var childVm = parentVm.$addChild({\n            el: childEl,\n            attached: spy,\n            detached: spy2\n          })\n          expect(spy.calls.count()).toBe(2)\n          parentVm.$remove()\n          expect(spy2.calls.count()).toBe(2)\n          // child should be already detached\n          // so the hook should not fire again\n          childVm.$remove()\n          expect(spy2.calls.count()).toBe(2)\n        })\n\n        it('create then attach', function () {\n          var el = document.createElement('div')\n          var childEl = document.createElement('div')\n          el.appendChild(childEl)\n          var parentVm = new Vue({\n            el: el,\n            attached: spy,\n            detached: spy2\n          })\n          var childVm = parentVm.$addChild({\n            el: childEl,\n            attached: spy,\n            detached: spy2\n          })\n          parentVm.$appendTo(document.body)\n          expect(spy.calls.count()).toBe(2)\n          // detach child first\n          childVm.$remove()\n          expect(spy2.calls.count()).toBe(1)\n          // should only fire parent detach\n          parentVm.$remove()\n          expect(spy2.calls.count()).toBe(2)\n        })\n\n        it('should not fire on detached child', function () {\n          var el = document.createElement('div')\n          var childEl = document.createElement('div')\n          var parentVm = new Vue({\n            el: el,\n            attached: spy\n          })\n          var childVm = parentVm.$addChild({\n            el: childEl,\n            attached: spy\n          })\n          parentVm.$appendTo(document.body)\n          expect(spy.calls.count()).toBe(1)\n          childVm.$appendTo(el)\n          expect(spy.calls.count()).toBe(2)\n        })\n\n      })\n\n    }\n\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/instance/events_spec.js\n ** module id = 94\n ** module chunks = 0\n **/","var init = require('../../../../src/instance/init')._init\n\ndescribe('Instance Init', function () {\n\n  var stub = {\n    constructor: {\n      options: { a: 1, b: 2 }\n    },\n    _initEvents: jasmine.createSpy(),\n    _callHook: jasmine.createSpy(),\n    _initScope: jasmine.createSpy(),\n    $mount: jasmine.createSpy()\n  }\n\n  var options = {\n    a: 2,\n    _anonymous: true,\n    el: {}\n  }\n\n  init.call(stub, options)\n\n  it('should setup properties', function () {\n    expect(stub.$el).toBe(null)\n    expect(stub.$root).toBe(stub)\n    expect(stub.$).toBeTruthy()\n    expect(stub._watcherList).toBeTruthy()\n    expect(stub._watchers).toBeTruthy()\n    expect(stub._userWatchers).toBeTruthy()\n    expect(stub._directives).toBeTruthy()\n    expect(stub._events).toBeTruthy()\n    expect(stub._eventsCount).toBeTruthy()\n  })\n\n  it('should merge options', function () {\n    expect(stub.$options.a).toBe(2)\n    expect(stub.$options.b).toBe(2)\n  })\n\n  it('should call other init methods', function () {\n    expect(stub._initEvents).toHaveBeenCalled()\n    expect(stub._initScope).toHaveBeenCalled()\n  })\n\n  it('should call created hook', function () {\n    expect(stub._callHook).toHaveBeenCalledWith('created')\n  })\n\n  it('should call $mount when options.el is present', function () {\n    expect(stub.$mount).toHaveBeenCalledWith(stub.$options.el)\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/instance/init_spec.js\n ** module id = 95\n ** module chunks = 0\n **/","var Vue = require('../../../../src/vue')\n\ndescribe('Instance Scope', function () {\n\n  describe('data proxy', function () {\n\n    var data = {\n      a: 0,\n      b: 0\n    }\n    var vm = new Vue({\n      data: data\n    })\n\n    it('initial', function () {\n      expect(vm.a).toBe(data.a)\n      expect(vm.b).toBe(data.b)\n    })\n\n    it('vm => data', function () {\n      vm.a = 1\n      expect(data.a).toBe(1)\n      expect(vm.a).toBe(data.a)\n    })\n\n    it('data => vm', function () {\n      data.b = 2\n      expect(vm.b).toBe(2)\n      expect(vm.b).toBe(data.b)\n    })\n\n  })\n\n  describe('computed', function () {\n    \n    var Test = Vue.extend({\n      computed: {\n        c: function () {\n          expect(this).toBe(vm)\n          return this.a + this.b\n        },\n        d: {\n          get: function () {\n            expect(this).toBe(vm)\n            return this.a + this.b\n          },\n          set: function (newVal) {\n            expect(this).toBe(vm)\n            var vals = newVal.split(' ')\n            this.a = vals[0]\n            this.b = vals[1]\n          }\n        }\n      }\n    })\n\n    var vm = new Test({\n      data: {\n        a: 'a',\n        b: 'b'\n      }\n    })\n\n    it('get', function () {\n      expect(vm.c).toBe('ab')\n      expect(vm.d).toBe('ab')\n    })\n\n    it('set', function () {\n      vm.c = 123 // should do nothing\n      vm.d = 'c d'\n      expect(vm.a).toBe('c')\n      expect(vm.b).toBe('d')\n      expect(vm.c).toBe('cd')\n      expect(vm.d).toBe('cd')\n    })\n\n    it('inherit', function () {\n      var child = vm.$addChild({\n        inherit: true\n      })\n      expect(child.c).toBe('cd')\n\n      child.d = 'e f'\n      expect(vm.a).toBe('e')\n      expect(vm.b).toBe('f')\n      expect(vm.c).toBe('ef')\n      expect(vm.d).toBe('ef')\n      expect(child.a).toBe('e')\n      expect(child.b).toBe('f')\n      expect(child.c).toBe('ef')\n      expect(child.d).toBe('ef')\n    })\n\n    it('same definition object bound to different instance', function () {\n      vm = new Test({\n        data: {\n          a: 'A',\n          b: 'B'\n        }\n      })\n      expect(vm.c).toBe('AB')\n      expect(vm.d).toBe('AB')\n      vm.d = 'C D'\n      expect(vm.a).toBe('C')\n      expect(vm.b).toBe('D')\n      expect(vm.c).toBe('CD')\n      expect(vm.d).toBe('CD')\n    })\n\n  })\n\n  describe('methods', function () {\n\n    it('should work and have correct context', function () {\n      var vm = new Vue({\n        data: {\n          a: 1\n        },\n        methods: {\n          test: function () {\n            expect(this instanceof Vue).toBe(true)\n            return this.a\n          }\n        }\n      })\n      expect(vm.test()).toBe(1)\n\n      var child = vm.$addChild({\n        inherit: true\n      })\n      expect(child.test()).toBe(1)\n    })\n\n  })\n\n  describe('meta', function () {\n\n    var vm = new Vue({\n      _meta: {\n        $index: 0,\n        $value: 'test'\n      }\n    })\n\n    it('should define metas only on vm', function () {\n      expect(vm.$index).toBe(0)\n      expect(vm.$value).toBe('test')\n      expect('$index' in vm.$data).toBe(false)\n      expect('$value' in vm.$data).toBe(false)\n    })\n\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/instance/scope_spec.js\n ** module id = 97\n ** module chunks = 0\n **/","// test cases for edge cases & bug fixes\nvar Vue = require('../../../src/vue')\n\ndescribe('Misc', function () {\n\n  it('should handle directive.bind() altering its childNode structure', function () {\n    var vm = new Vue({\n      el: document.createElement('div'),\n      template: '<div v-test>{{test}}</div>',\n      data: {\n        test: 'hi'\n      },\n      directives: {\n        test: {\n          bind: function () {\n            this.el.insertBefore(document.createTextNode('yo '),\n              this.el.firstChild)\n          }\n        }\n      }\n    })\n    expect(vm.$el.textContent).toBe('yo hi')\n  })\n\n  it('attached/detached hooks for transcluded components', function () {\n    var spy1 = jasmine.createSpy('attached')\n    var spy2 = jasmine.createSpy('detached')\n    var el = document.createElement('div')\n    el.innerHTML = '<div v-component=\"outter\" v-ref=\"outter\"><div v-component=\"inner\"></div></div>'\n    document.body.appendChild(el)\n\n    var vm = new Vue({\n      el: el,\n      components: {\n        outter: {\n          template: '<content></content>'\n        },\n        inner: {\n          template: 'hi',\n          attached: spy1,\n          detached: spy2\n        }\n      }\n    })\n    expect(spy1).toHaveBeenCalled()\n    vm.$.outter.$remove()\n    expect(spy2).toHaveBeenCalled()\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/misc_spec.js\n ** module id = 98\n ** module chunks = 0\n **/","var Dep = require('../../../../src/observer/dep')\n\ndescribe('Dep', function () {\n\n  var d\n  beforeEach(function () {\n    d = new Dep()\n  })\n\n  it('addSub', function () {\n    var sub = {}\n    d.addSub(sub)\n    expect(d.subs.length).toBe(1)\n    expect(d.subs.indexOf(sub)).toBe(0)\n  })\n\n  it('removeSub', function () {\n    var sub = {}\n    d.addSub(sub)\n    d.removeSub(sub)\n    expect(d.subs.length).toBe(0)\n    expect(d.subs.indexOf(sub)).toBe(-1)\n  })\n\n  it('notify', function () {\n    var sub = {\n      update: jasmine.createSpy('sub')\n    }\n    d.addSub(sub)\n    d.notify()\n    expect(sub.update).toHaveBeenCalled()\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/observer/dep_spec.js\n ** module id = 99\n ** module chunks = 0\n **/","var Observer = require('../../../../src/observer')\nvar config = require('../../../../src/config')\nvar Dep = require('../../../../src/observer/dep')\nvar _ = require('../../../../src/util')\n\ndescribe('Observer', function () {\n\n  var spy\n  beforeEach(function () {\n    spy = jasmine.createSpy('observer')\n  })\n\n  it('create on non-observables', function () {\n    // skip primitive value\n    var ob = Observer.create(1)\n    expect(ob).toBeUndefined()\n    // avoid vue instance\n    ob = Observer.create(new _.Vue())\n    expect(ob).toBeUndefined()\n  })\n\n  it('create on object', function () {\n    // on object\n    var obj = {\n      a: {},\n      b: {}\n    }\n    var ob = Observer.create(obj)\n    expect(ob instanceof Observer).toBe(true)\n    expect(ob.active).toBe(true)\n    expect(ob.value).toBe(obj)\n    expect(obj.__ob__).toBe(ob)\n    // should've walked children\n    expect(obj.a.__ob__ instanceof Observer).toBe(true)\n    expect(obj.b.__ob__ instanceof Observer).toBe(true)\n    // should return existing ob on already observed objects\n    var ob2 = Observer.create(obj)\n    expect(ob2).toBe(ob)\n  })\n\n  it('create on array', function () {\n    // on object\n    var arr = [{}, {}]\n    var ob = Observer.create(arr)\n    expect(ob instanceof Observer).toBe(true)\n    expect(ob.active).toBe(true)\n    expect(ob.value).toBe(arr)\n    expect(arr.__ob__).toBe(ob)\n    // should've walked children\n    expect(arr[0].__ob__ instanceof Observer).toBe(true)\n    expect(arr[1].__ob__ instanceof Observer).toBe(true)\n  })\n\n  it('observing object prop change', function () {\n    var obj = { a: { b: 2 } }\n    Observer.create(obj)\n    // mock a watcher!\n    var watcher = {\n      deps: [],\n      addDep: function (dep) {\n        this.deps.push(dep)\n        dep.addSub(this)\n      },\n      update: jasmine.createSpy()\n    }\n    var dump\n    // collect dep\n    Observer.target = watcher\n    dump = obj.a.b\n    Observer.target = null\n    expect(watcher.deps.length).toBe(2)\n    dump = obj.a.b = 3\n    expect(watcher.update.calls.count()).toBe(1)\n    // swap object\n    var oldA = obj.a\n    obj.a = { b: 4 }\n    expect(watcher.update.calls.count()).toBe(2)\n    expect(oldA.__ob__.deps.length).toBe(0)\n    expect(obj.a.__ob__.deps.length).toBe(1)\n    // recollect dep\n    var oldDeps = watcher.deps\n    watcher.deps = []\n    Observer.target = watcher\n    dump = obj.a.b\n    Observer.target = null\n    expect(watcher.deps.length).toBe(2)\n    // set on the swapped object\n    obj.a.b = 5\n    expect(watcher.update.calls.count()).toBe(3)\n  })\n\n  it('observing $add/$set/$delete', function () {\n    var obj = { a: 1 }\n    var ob = Observer.create(obj)\n    var dep = new Dep()\n    ob.deps.push(dep)\n    spyOn(dep, 'notify')\n    obj.$add('b', 2)\n    expect(obj.b).toBe(2)\n    expect(dep.notify.calls.count()).toBe(1)\n    obj.$delete('a')\n    expect(obj.hasOwnProperty('a')).toBe(false)\n    expect(dep.notify.calls.count()).toBe(2)\n    // should ignore adding an existing key\n    obj.$add('b', 3)\n    expect(obj.b).toBe(2)\n    expect(dep.notify.calls.count()).toBe(2)\n    // set existing key, should be a plain set and not\n    // trigger own ob's notify\n    obj.$set('b', 3)\n    expect(obj.b).toBe(3)\n    expect(dep.notify.calls.count()).toBe(2)\n    // set non-existing key\n    obj.$set('c', 1)\n    expect(obj.c).toBe(1)\n    expect(dep.notify.calls.count()).toBe(3)\n    // should ignore deleting non-existing key\n    obj.$delete('a')\n    expect(dep.notify.calls.count()).toBe(3)\n    // should work on non-observed objects\n    var obj2 = { a: 1 }\n    obj2.$delete('a')\n    expect(obj2.hasOwnProperty('a')).toBe(false)\n  })\n\n  it('observing array mutation', function () {\n    var arr = []\n    var ob = Observer.create(arr)\n    var dep = new Dep()\n    ob.deps.push(dep)\n    spyOn(dep, 'notify')\n    var objs = [{}, {}, {}]\n    arr.push(objs[0])\n    arr.pop()\n    arr.unshift(objs[1])\n    arr.shift()\n    arr.splice(0, 0, objs[2])\n    arr.sort()\n    arr.reverse()\n    expect(dep.notify.calls.count()).toBe(7)\n    // inserted elements should be observed\n    objs.forEach(function (obj) {\n      expect(obj.__ob__ instanceof Observer).toBe(true)\n    })\n  })\n\n  it('array $set', function () {\n    var arr = [1]\n    var ob = Observer.create(arr)\n    var dep = new Dep()\n    ob.deps.push(dep)\n    spyOn(dep, 'notify')\n    arr.$set(0, 2)\n    expect(arr[0]).toBe(2)\n    expect(dep.notify.calls.count()).toBe(1)\n    // setting out of bound index\n    arr.$set(2, 3)\n    expect(arr[2]).toBe(3)\n    expect(dep.notify.calls.count()).toBe(2)\n  })\n\n  it('array $remove', function () {\n    var arr = [{}, {}]\n    var obj1 = arr[0]\n    var obj2 = arr[1]\n    var ob = Observer.create(arr)\n    var dep = new Dep()\n    ob.deps.push(dep)\n    spyOn(dep, 'notify')\n    // remove by index\n    arr.$remove(0)\n    expect(arr.length).toBe(1)\n    expect(arr[0]).toBe(obj2)\n    expect(dep.notify.calls.count()).toBe(1)\n    // remove by identity, not in array\n    arr.$remove(obj1)\n    expect(arr.length).toBe(1)\n    expect(arr[0]).toBe(obj2)\n    expect(dep.notify.calls.count()).toBe(1)\n    // remove by identity, in array\n    arr.$remove(obj2)\n    expect(arr.length).toBe(0)\n    expect(dep.notify.calls.count()).toBe(2)\n  })\n\n  it('no proto', function () {\n    config.proto = false\n    // object\n    var obj = {a:1}\n    var ob = Observer.create(obj)\n    expect(obj.$add).toBeTruthy()\n    expect(obj.$delete).toBeTruthy()\n    var dep = new Dep()\n    ob.deps.push(dep)\n    spyOn(dep, 'notify')\n    obj.$add('b', 2)\n    expect(dep.notify).toHaveBeenCalled()\n    // array\n    var arr = [1, 2, 3]\n    var ob2 = Observer.create(arr)\n    expect(arr.$set).toBeTruthy()\n    expect(arr.$remove).toBeTruthy()\n    expect(arr.push).not.toBe([].push)\n    var dep2 = new Dep()\n    ob2.deps.push(dep2)\n    spyOn(dep2, 'notify')\n    arr.push(1)\n    expect(dep2.notify).toHaveBeenCalled()\n    config.proto = true\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/observer/observer_spec.js\n ** module id = 100\n ** module chunks = 0\n **/","var parse = require('../../../../src/parsers/directive').parse\n\ndescribe('Directive Parser', function () {\n\n  it('simple', function () {\n    var res = parse('exp')\n    expect(res.length).toBe(1)\n    expect(res[0].expression).toBe('exp')\n    expect(res[0].raw).toBe('exp')\n  })\n\n  it('with arg', function () {\n    var res = parse('arg:exp')\n    expect(res.length).toBe(1)\n    expect(res[0].expression).toBe('exp')\n    expect(res[0].arg).toBe('arg')\n    expect(res[0].raw).toBe('arg:exp')\n  })\n\n  it('with filters', function () {\n    var res = parse(' arg : exp | abc de | bcd')\n    expect(res.length).toBe(1)\n    expect(res[0].expression).toBe('exp')\n    expect(res[0].arg).toBe('arg')\n    expect(res[0].raw).toBe('arg : exp | abc de | bcd')\n    expect(res[0].filters.length).toBe(2)\n    expect(res[0].filters[0].name).toBe('abc')\n    expect(res[0].filters[0].args.length).toBe(1)\n    expect(res[0].filters[0].args[0]).toBe('de')\n    expect(res[0].filters[1].name).toBe('bcd')\n    expect(res[0].filters[1].args).toBeNull()\n  })\n\n  it('double pipe', function () {\n    var res = parse('a || b | c')\n    expect(res.length).toBe(1)\n    expect(res[0].expression).toBe('a || b')\n    expect(res[0].raw).toBe('a || b | c')\n    expect(res[0].filters.length).toBe(1)\n    expect(res[0].filters[0].name).toBe('c')\n    expect(res[0].filters[0].args).toBeNull()\n  })\n\n  it('single quote + boolean', function () {\n    var res = parse('a ? \\'b\\' : c')\n    expect(res.length).toBe(1)\n    expect(res[0].expression).toBe('a ? \\'b\\' : c')\n    expect(res[0].filters).toBeUndefined()\n  })\n\n  it('double quote + boolean', function () {\n    var res = parse('\"a:b:c||d|e|f\" || d ? a : b')\n    expect(res.length).toBe(1)\n    expect(res[0].expression).toBe('\"a:b:c||d|e|f\" || d ? a : b')\n    expect(res[0].filters).toBeUndefined()\n    expect(res[0].arg).toBeUndefined()\n  })\n\n  it('multiple simple clauses', function () {\n    var res = parse('a, b, c')\n    expect(res.length).toBe(3)\n    expect(res[0].expression).toBe('a')\n    expect(res[1].expression).toBe('b')\n    expect(res[2].expression).toBe('c')\n  })\n\n  it('multiple complex clauses', function () {\n    var res = parse('a:b | c | j, d:e | f | k l, g:h | i')\n    expect(res.length).toBe(3)\n\n    expect(res[0].arg).toBe('a')\n    expect(res[0].expression).toBe('b')\n    expect(res[0].filters.length).toBe(2)\n    expect(res[0].filters[0].name).toBe('c')\n    expect(res[0].filters[0].args).toBeNull()\n    expect(res[0].filters[1].name).toBe('j')\n    expect(res[0].filters[1].args).toBeNull()\n\n    expect(res[1].arg).toBe('d')\n    expect(res[1].expression).toBe('e')\n    expect(res[1].filters.length).toBe(2)\n    expect(res[1].filters[0].name).toBe('f')\n    expect(res[1].filters[0].args).toBeNull()\n    expect(res[1].filters[1].name).toBe('k')\n    expect(res[1].filters[1].args.length).toBe(1)\n    expect(res[1].filters[1].args[0]).toBe('l')\n\n    expect(res[2].arg).toBe('g')\n    expect(res[2].expression).toBe('h')\n    expect(res[2].filters.length).toBe(1)\n    expect(res[2].filters[0].name).toBe('i')\n    expect(res[2].filters[0].args).toBeNull()\n  })\n\n  it('nexted function calls + array/object literals', function () {\n    var res = parse('click:test(c.indexOf(d,f),\"e,f\"), input: d || [e,f], ok:{a:1,b:2}')\n    expect(res.length).toBe(3)\n    expect(res[0].arg).toBe('click')\n    expect(res[0].expression).toBe('test(c.indexOf(d,f),\"e,f\")')\n    expect(res[1].arg).toBe('input')\n    expect(res[1].expression).toBe('d || [e,f]')\n    expect(res[1].filters).toBeUndefined()\n    expect(res[2].arg).toBe('ok')\n    expect(res[2].expression).toBe('{a:1,b:2}')\n  })\n\n  it('arguments with non-indentifier chars', function () {\n    var res = parse('show.bs.collapse:test, a@b%c:test')\n    expect(res.length).toBe(2)\n    expect(res[0].arg).toBe('show.bs.collapse')\n    expect(res[0].expression).toBe('test')\n    expect(res[1].arg).toBe('a@b%c')\n    expect(res[1].expression).toBe('test')\n  })\n\n  it('quoted arguments', function () {\n    var res = parse('\"xlink:href\":a?\"fsef\":ff')\n    expect(res.length).toBe(1)\n    expect(res[0].arg).toBe('xlink:href')\n  })\n\n  it('cache', function () {\n    var res1 = parse('a || b | c')\n    var res2 = parse('a || b | c')\n    expect(res1).toBe(res2)\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/parsers/directive_spec.js\n ** module id = 101\n ** module chunks = 0\n **/","var expParser = require('../../../../src/parsers/expression')\nvar _ = require('../../../../src/util')\n\nvar testCases = [\n  {\n    // simple path\n    exp: 'a.b.d',\n    scope: {\n      a:{b:{d:123}}\n    },\n    expected: 123,\n    paths: ['a']\n  },\n  // complex path\n  {\n    exp: 'a[\"b\"].c',\n    scope: {\n      a:{b:{c:234}}\n    },\n    expected: 234,\n    paths: ['a']\n  },\n  {\n    // string concat\n    exp: 'a+b',\n    scope: {\n      a: 'hello',\n      b: 'world'\n    },\n    expected: 'helloworld',\n    paths: ['a', 'b']\n  },\n  {\n    // math\n    exp: 'a - b * 2 + 45',\n    scope: {\n      a: 100,\n      b: 23\n    },\n    expected: 100 - 23 * 2 + 45,\n    paths: ['a', 'b']\n  },\n  {\n    // boolean logic\n    exp: '(a && b) ? c : d || e',\n    scope: {\n      a: true,\n      b: false,\n      c: null,\n      d: false,\n      e: 'worked'\n    },\n    expected: 'worked',\n    paths: ['a', 'b', 'c', 'd', 'e']\n  },\n  {\n    // inline string with newline\n    exp: \"a + 'hel\\nlo'\",\n    scope: {\n      a: 'inline '\n    },\n    expected: 'inline hel\\nlo',\n    paths: ['a']\n  },\n  {\n    //multiline expressions\n    exp: \"{\\n a: '35',\\n b: c}\",\n    scope:{c:32},\n    expected: { a : '35', b : 32 }\n  },\n  {\n    // dollar signs and underscore\n    exp: \"_a + ' ' + $b\",\n    scope: {\n      _a: 'underscore',\n      $b: 'dollar'\n    },\n    expected: 'underscore dollar',\n    paths: ['_a', '$b']\n  },\n  {\n    // complex with nested values\n    exp: \"todo.title + ' : ' + (todo['done'] ? 'yep' : 'nope')\",\n    scope: {\n      todo: {\n        title: 'write tests',\n        done: false\n      }\n    },\n    expected: 'write tests : nope',\n    paths: ['todo']\n  },\n  {\n    // expression with no data variables\n    exp: \"'a' + 'b'\",\n    scope: {},\n    expected: 'ab',\n    paths: []\n  },\n  {\n    // values with same variable name inside strings\n    exp: \"'\\\"test\\\"' + test + \\\"'hi'\\\" + hi\",\n    scope: {\n      test: 1,\n      hi: 2\n    },\n    expected: '\"test\"1\\'hi\\'2',\n    paths: ['test', 'hi']\n  },\n  {\n    // expressions with inline object literals\n    exp: \"sortRows({ column: 'name', test: haha, durrr: 123 })\",\n    scope: {\n      sortRows: function (params) {\n        return params.column + params.test + params.durrr\n      },\n      haha: 'hoho'\n    },\n    expected: 'namehoho123',\n    paths: ['sortRows', 'haha']\n  },\n  {\n    // space between path segments\n    exp: '  a    .   b    .  c + d',\n    scope: {\n      a: { b: { c: 12 }},\n      d: 3\n    },\n    expected: 15,\n    paths: ['a', 'd']\n  },\n  {\n    // space in bracket identifiers\n    exp: ' a[ \" a.b.c \" ] + b  [ \\' e \\' ]',\n    scope: {\n      a: {' a.b.c ': 123},\n      b: {' e ': 234}\n    },\n    expected: 357,\n    paths: ['a', 'b']\n  },\n  {\n    // number literal\n    exp: 'a * 1e2 + 1.1',\n    scope: {\n      a: 3\n    },\n    expected: 301.1,\n    paths: ['a']\n  },\n  {\n    //keyowrd + keyword literal\n    exp: 'true && a.true',\n    scope: {\n      a: { 'true': false }\n    },\n    expected: false,\n    paths: ['a']\n  },\n  {\n    // super complex\n    exp: ' $a + b[ \"  a.b.c  \" ][\\'123\\'].$e&&c[ \" d \" ].e + Math.round(e) ',\n    scope: {\n      $a: 1,\n      b: {\n        '  a.b.c  ': {\n          '123': { $e: 2 }\n        }\n      },\n      c: { ' d ': {e: 3}},\n      e: 4.5\n    },\n    expected: 8,\n    paths: ['$a', 'b', 'c', 'e']\n  },\n  {\n    // Math global, simple path\n    exp: 'Math.PI',\n    scope: {},\n    expected: Math.PI,\n    paths: []\n  },\n  {\n    // Math global, exp\n    exp: 'Math.sin(a)',\n    scope: {\n      a: 1\n    },\n    expected: Math.sin(1),\n    paths: ['a']\n  },\n  {\n    // boolean literal\n    exp: 'true',\n    scope: {\n      true: false\n    },\n    expected: true,\n    paths: []\n  },\n  {\n    // Date global\n    exp: 'Date.now() > new Date(\"2000-01-01\")',\n    scope: {},\n    expected: true,\n    paths: []\n  },\n  // typeof operator\n  {\n    exp: 'typeof test === \"string\"',\n    scope: { test: \"123\" },\n    expected: true,\n    paths: ['test']\n  },\n  // isNaN\n  {\n    exp: 'isNaN(a)',\n    scope: { a: 2 },\n    expected: false,\n    paths: ['a']\n  },\n  // parseFloat & parseInt\n  {\n    exp: 'parseInt(a, 10) + parseFloat(b)',\n    scope: { a: 2.33, b: '3.45' },\n    expected: 5.45,\n    paths: ['a', 'b']\n  }\n]\n\ndescribe('Expression Parser', function () {\n\n  testCases.forEach(function (testCase) {\n    it('parse getter: ' + testCase.exp, function () {\n      var res = expParser.parse(testCase.exp, true)\n      expect(res.get(testCase.scope)).toEqual(testCase.expected)\n    })\n  })\n\n  it('dynamic setter', function () {\n    // make sure checkSetter works:\n    // should add setter if a cache hit doesn't have hit function.\n    expParser.parse('a[b]')\n    var res = expParser.parse('a[b]', true)\n    var scope = {\n      a: { c: 1 },\n      b: 'c'\n    }\n    res.set(scope, 2)\n    expect(scope.a.c).toBe(2)\n  })\n\n  it('simple path setter', function () {\n    var res = expParser.parse('a.b.c', true)\n    var scope = {}\n    expect(function () {\n      res.set(scope, 123)\n    }).not.toThrow()\n    scope.a = {b:{c:0}}\n    res.set(scope, 123)\n    expect(scope.a.b.c).toBe(123)\n  })\n\n  it('cache', function () {\n    var res1 = expParser.parse('a + b')\n    var res2 = expParser.parse('a + b')\n    expect(res1).toBe(res2)\n  })\n\n  describe('invalid expression', function () {\n    \n    beforeEach(function () {\n      spyOn(_, 'warn')\n    })\n\n    it('should warn on invalid expression', function () {\n      expect(_.warn).not.toHaveBeenCalled()\n      var res = expParser.parse('a--b\"ffff')\n      expect(_.warn).toHaveBeenCalled()\n    })\n\n    if (leftHandThrows()) {\n      it('should warn on invalid left hand expression for setter', function () {\n        expect(_.warn).not.toHaveBeenCalled()\n        var res = expParser.parse('a+b', true)\n        expect(_.warn).toHaveBeenCalled()\n      })\n    }\n\n    it('should warn if expression contains improper reserved keywords', function () {\n      expect(_.warn).not.toHaveBeenCalled()\n      var res = expParser.parse('break + 1')\n      expect(_.warn).toHaveBeenCalled()\n    })\n  })\n})\n\n/**\n * check if creating a new Function with invalid left-hand\n * assignment would throw\n */\n\nfunction leftHandThrows () {\n  try {\n    var fn = new Function('a + b = 1')\n  } catch (e) {\n    return true\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/parsers/expression_spec.js\n ** module id = 102\n ** module chunks = 0\n **/","var Path = require('../../../../src/parsers/path')\n\nfunction assertPath (str, expected) {\n  var path = Path.parse(str)\n  expect(pathMatch(path, expected)).toBe(true)\n}\n\nfunction assertInvalidPath (str) {\n  var path = Path.parse(str)\n  expect(path).toBeUndefined()\n}\n\nfunction pathMatch (a, b) {\n  if (a.length !== b.length) {\n    return false\n  }\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n  return true\n}\n\ndescribe('Path Parser', function () {\n  \n  it('parse', function () {\n    assertPath('', [])\n    assertPath(' ', [])\n    assertPath('a', ['a'])\n    assertPath('a.b', ['a', 'b'])\n    assertPath('a. b', ['a', 'b'])\n    assertPath('a .b', ['a', 'b'])\n    assertPath('a . b', ['a', 'b'])\n    assertPath(' a . b ', ['a', 'b'])\n    assertPath('a[0]', ['a', '0'])\n    assertPath('a [0]', ['a', '0'])\n    assertPath('a[0][1]', ['a', '0', '1'])\n    assertPath('a [ 0 ] [ 1 ] ', ['a', '0', '1'])\n    assertPath('[1234567890] ', ['1234567890'])\n    assertPath(' [1234567890] ', ['1234567890'])\n    assertPath('opt0', ['opt0'])\n    assertPath('$foo.$bar._baz', ['$foo', '$bar', '_baz'])\n    assertPath('foo[\"baz\"]', ['foo', 'baz'])\n    assertPath('foo[\"b\\\\\"az\"]', ['foo', 'b\"az'])\n    assertPath(\"foo['b\\\\'az']\", ['foo', \"b'az\"])\n  })\n\n  it('handle invalid paths', function () {\n    assertInvalidPath('.')\n    assertInvalidPath(' . ')\n    assertInvalidPath('..')\n    assertInvalidPath('a[4')\n    assertInvalidPath('a.b.')\n    assertInvalidPath('a,b')\n    assertInvalidPath('a[\"foo]')\n    assertInvalidPath('[0x04]')\n    assertInvalidPath('[0foo]')\n    assertInvalidPath('[foo-bar]')\n    assertInvalidPath('foo-bar')\n    assertInvalidPath('42')\n    assertInvalidPath('a[04]')\n    assertInvalidPath(' a [ 04 ]')\n    assertInvalidPath('  42   ')\n    assertInvalidPath('foo[\"bar]')\n    assertInvalidPath(\"foo['bar]\")\n  })\n\n  it('caching', function () {\n    var path1 = Path.parse('a.b.c')\n    var path2 = Path.parse('a.b.c')\n    expect(path1).toBe(path2)\n  })\n\n  it('get', function () {\n    var path = 'a[\\'b\"b\"c\\'][0]'\n    var obj = {\n      a: {\n        'b\"b\"c': [12345]\n      }\n    }\n    expect(Path.get(obj, path)).toBe(12345)\n    expect(Path.get(obj, 'a.c')).toBeUndefined()\n  })\n\n  it('set', function () {\n    var path = 'a.b.c'\n    var obj = {\n      a: {\n        b: {\n          c: null\n        }\n      }\n    }\n    var res = Path.set(obj, path, 12345)\n    expect(res).toBe(true)\n    expect(obj.a.b.c).toBe(12345)\n  })\n\n  it('set non-existent', function () {\n    var target = {}\n    var res = Path.set(target, 'a.b.c', 123)\n    expect(res).toBe(true)\n    expect(target.a.b.c).toBe(123)\n  })\n\n  it('set on prototype chain', function () {\n    var parent = { a: {} }\n    var target = Object.create(parent)\n    var res = Path.set(target, 'a.b.c', 123)\n    expect(res).toBe(true)\n    expect(target.hasOwnProperty('a')).toBe(false)\n    expect(parent.a.b.c).toBe(123)\n  })\n\n  it('set invalid', function () {\n    var res = Path.set({}, 'ab[c]d', 123)\n    expect(res).toBe(false)\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/parsers/path_spec.js\n ** module id = 103\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar templateParser = require('../../../../src/parsers/template')\nvar parse = templateParser.parse\nvar testString = '<div>hello</div><p class=\"test\">world</p>'\n\nif (_.inBrowser) {\n\n  describe('Template Parser', function () {\n    \n    it('should return same if argument is already a fragment', function () {\n      var frag = document.createDocumentFragment()\n      var res = parse(frag)\n      expect(res).toBe(frag)\n    })\n\n    it('should return content if argument is a valid template node', function () {\n      var templateNode = document.createElement('template')\n      if (!templateNode.content) {\n        // mock the content \n        templateNode.content = document.createDocumentFragment()\n      }\n      var res = parse(templateNode)\n      expect(res).toBe(templateNode.content)\n    })\n\n    it('should parse if argument is a template string', function () {\n      var res = parse(testString)\n      expect(res instanceof DocumentFragment).toBeTruthy()\n      expect(res.childNodes.length).toBe(2)\n      expect(res.querySelector('.test').textContent).toBe('world')\n    })\n\n    it('should work if the template string doesn\\'t contain tags', function () {\n      var res = parse('hello!')\n      expect(res instanceof DocumentFragment).toBeTruthy()\n      expect(res.childNodes.length).toBe(1)\n      expect(res.firstChild.nodeType).toBe(3) // Text node\n    })\n\n    it('should handle string that contains html entities', function () {\n      var res = parse('hi&lt;hi')\n      expect(res instanceof DocumentFragment).toBeTruthy()\n      expect(res.childNodes.length).toBe(1)\n      expect(res.firstChild.nodeValue).toBe('hi<hi')\n    })\n\n    it('should parse textContent if argument is a script node', function () {\n      var node = document.createElement('script')\n      node.textContent = testString\n      var res = parse(node)\n      expect(res instanceof DocumentFragment).toBeTruthy()\n      expect(res.childNodes.length).toBe(2)\n      expect(res.querySelector('.test').textContent).toBe('world')\n    })\n\n    it('should parse innerHTML if argument is a normal node', function () {\n      var node = document.createElement('div')\n      node.innerHTML = testString\n      var res = parse(node)\n      expect(res instanceof DocumentFragment).toBeTruthy()\n      expect(res.childNodes.length).toBe(2)\n      expect(res.querySelector('.test').textContent).toBe('world')\n    })\n\n    it('should retrieve and parse if argument is an id selector', function () {\n      var node = document.createElement('script')\n      node.setAttribute('id', 'template-test')\n      node.setAttribute('type', 'x/template')\n      node.textContent = testString\n      document.head.appendChild(node)\n      var res = parse('#template-test')\n      expect(res instanceof DocumentFragment).toBeTruthy()\n      expect(res.childNodes.length).toBe(2)\n      expect(res.querySelector('.test').textContent).toBe('world')\n      document.head.removeChild(node)\n    })\n\n    it('should work for table elements', function () {\n      var res = parse('<td>hello</td>')\n      expect(res instanceof DocumentFragment).toBeTruthy()\n      expect(res.childNodes.length).toBe(1)\n      expect(res.firstChild.tagName).toBe('TD')\n      expect(res.firstChild.textContent).toBe('hello')\n    })\n\n    it('should work for option elements', function () {\n      var res = parse('<option>hello</option>')\n      expect(res instanceof DocumentFragment).toBeTruthy()\n      expect(res.childNodes.length).toBe(1)\n      expect(res.firstChild.tagName).toBe('OPTION')\n      expect(res.firstChild.textContent).toBe('hello')\n    })\n\n    it('should work for svg elements', function () {\n      var res = parse('<circle></circle>')\n      expect(res instanceof DocumentFragment).toBeTruthy()\n      expect(res.childNodes.length).toBe(1)\n      // SVG tagNames should be lowercase because they are XML nodes not HTML\n      expect(res.firstChild.tagName).toBe('circle')\n      expect(res.firstChild.namespaceURI).toBe('http://www.w3.org/2000/svg')\n    })\n\n    it('should cache template strings', function () {\n      var res1 = parse(testString)\n      var res2 = parse(testString)\n      expect(res1).toBe(res2)\n    })\n\n    it('should clone', function () {\n      var res1 = parse(testString, true)\n      var res2 = parse(testString, true)\n      expect(res1).not.toBe(res2)\n    })\n\n    it('should cache id selectors', function () {\n      var node = document.createElement('script')\n      node.setAttribute('id', 'template-test')\n      node.setAttribute('type', 'x/template')\n      node.textContent = '<div>never seen before content</div>'\n      document.head.appendChild(node)\n      var res1 = parse('#template-test')\n      var res2 = parse('#template-test')\n      expect(res1).toBe(res2)\n      document.head.removeChild(node)\n    })\n\n    it('should be able to not use id selectors', function () {\n      var res = parse('#hi', false, true)\n      expect(res instanceof DocumentFragment).toBeTruthy()\n      expect(res.firstChild.nodeValue).toBe('#hi')\n    })\n\n    it('should deal with Safari template clone bug', function () {\n      var a = document.createElement('div')\n      a.innerHTML = '<template>1</template>'\n      var c = templateParser.clone(a)\n      expect(a.firstChild.innerHTML).toBe('1')\n    })\n\n    it('should deal with IE textarea clone bug', function () {\n      var t = document.createElement('textarea')\n      t.placeholder = 't'\n      var c = templateParser.clone(t)\n      expect(c.value).toBe('')\n    })\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/parsers/template_spec.js\n ** module id = 104\n ** module chunks = 0\n **/","var textParser = require('../../../../src/parsers/text')\nvar config = require('../../../../src/config')\nvar Vue = require('../../../../src/vue')\n\nvar testCases = [\n  {\n    // no tags\n    text: 'haha',\n    expected: null\n  },\n  {\n    // basic\n    text: 'a {{ a }} c',\n    expected: [\n      { value: 'a ' },\n      { tag: true, value: 'a', html: false, oneTime: false },\n      { value: ' c' }\n    ]\n  },\n  {\n    // html\n    text: '{{ text }} and {{{ html }}}',\n    expected: [\n      { tag: true, value: 'text', html: false, oneTime: false },\n      { value: ' and ' },\n      { tag: true, value: 'html', html: true, oneTime: false },\n    ]\n  },\n  {\n    // one time\n    text: '{{* text }} and {{{* html }}}',\n    expected: [\n      { tag: true, value: 'text', html: false, oneTime: true },\n      { value: ' and ' },\n      { tag: true, value: 'html', html: true, oneTime: true },\n    ]\n  },\n  {\n    // partial\n    text: '{{> hello }} and {{>hello}}',\n    expected: [\n      { tag: true, value: 'hello', html: false, oneTime: false, partial: true },\n      { value: ' and ' },\n      { tag: true, value: 'hello', html: false, oneTime: false, partial: true }\n    ]\n  },\n  {\n    text: '[{{abc}}]',\n    expected: [\n      { value: '[' },\n      { tag: true, value: 'abc', html: false, oneTime: false },\n      { value: ']' }\n    ]\n  }\n]\n\nfunction assertParse (test) {\n  var res = textParser.parse(test.text)\n  var exp = test.expected\n  if (!Array.isArray(exp)) {\n    expect(res).toBe(exp)\n  } else {\n    expect(res.length).toBe(exp.length)\n    res.forEach(function (r, i) {\n      var e = exp[i]\n      for (var key in e) {\n        expect(e[key]).toEqual(r[key])\n      }\n    })\n  }\n}\n\ndescribe('Text Parser', function () {\n\n  it('parse', function () {\n    testCases.forEach(assertParse)\n  })\n\n  it('cache', function () {\n    var res1 = textParser.parse('{{a}}')\n    var res2 = textParser.parse('{{a}}')\n    expect(res1).toBe(res2)\n  })\n\n  it('custom delimiters', function () {\n    config.delimiters = ['[%', '%]']\n    assertParse({\n      text: '[%* text %] and [[% html %]]',\n      expected: [\n        { tag: true, value: 'text', html: false, oneTime: true },\n        { value: ' and ' },\n        { tag: true, value: 'html', html: true, oneTime: false },\n      ]\n    })\n    config.delimiters = ['{{', '}}']\n  })\n\n  it('tokens to expression', function () {\n    var tokens = textParser.parse('view-{{test + 1}}-test-{{ok + \"|\"}}')\n    var exp = textParser.tokensToExp(tokens)\n    expect(exp).toBe('\"view-\"+(test + 1)+\"-test-\"+(ok + \"|\")')\n  })\n\n  it('tokens to expression with oneTime tags & vm', function () {\n    var vm = new Vue({\n      data: { test: 'a', ok: 'b' }\n    })\n    var tokens = textParser.parse('view-{{*test}}-test-{{ok}}')\n    var exp = textParser.tokensToExp(tokens, vm)\n    expect(exp).toBe('\"view-\"+\"a\"+\"-test-\"+(ok)')\n  })\n\n  it('tokens to expression with filters, single expression', function () {\n    var tokens = textParser.parse('{{test | abc}}')\n    var exp = textParser.tokensToExp(tokens)\n    expect(exp).toBe('test | abc')\n  })\n\n  it('tokens to expression with filters, multiple expressions', function () {\n    var tokens = textParser.parse('a {{b | c d}} e')\n    var exp = textParser.tokensToExp(tokens)\n    expect(exp).toBe('\"a \"+(this.$options.filters[\"c\"].read||this.$options.filters[\"c\"]).apply(this,[b,\"d\"])+\" e\"')\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/parsers/text_spec.js\n ** module id = 105\n ** module chunks = 0\n **/","var Vue = require('../../../../src/vue')\nvar _ = require('../../../../src/util')\nvar transition = require('../../../../src/transition')\n\nif (_.inBrowser && !_.isIE9) {\n  describe('Transition', function () {\n\n    describe('Wrapper methods', function () {\n      \n      var spy, el, target, parent, vm\n      beforeEach(function () {\n        el = document.createElement('div')\n        target = document.createElement('div')\n        parent = document.createElement('div')\n        parent.appendChild(target)\n        spy = jasmine.createSpy('transition skip')\n        vm = new Vue()\n        spyOn(transition, 'apply')\n      })\n\n      it('append', function () {\n        transition.append(el, parent, vm, spy)\n        expect(parent.lastChild).toBe(el)\n        expect(spy).toHaveBeenCalled()\n      })\n\n      it('before', function () {\n        transition.before(el, target, vm, spy)\n        expect(parent.firstChild).toBe(el)\n        expect(el.nextSibling).toBe(target)\n        expect(spy).toHaveBeenCalled()\n      })\n\n      it('remove', function () {\n        transition.remove(target, vm, spy)\n        expect(parent.childNodes.length).toBe(0)\n        expect(spy).toHaveBeenCalled()\n      })\n\n      it('removeThenAppend', function () {\n        transition.removeThenAppend(target, el, vm, spy)\n        expect(parent.childNodes.length).toBe(0)\n        expect(el.firstChild).toBe(target)\n        expect(spy).toHaveBeenCalled()\n      })\n\n    })\n\n    describe('Skipping', function () {\n\n      var el, vm, op, cb\n      beforeEach(function () {\n        el = document.createElement('div')\n        op = jasmine.createSpy('transition skip op')\n        cb = jasmine.createSpy('transition skip cb')\n        vm = new Vue()\n      })\n      \n      it('skip el with no transition data', function () {\n        transition.apply(el, 1, op, vm, cb)\n        expect(op).toHaveBeenCalled()\n        expect(cb).toHaveBeenCalled()\n      })\n\n      it('skip vm still being compiled', function () {\n        el.__v_trans = { id: 'test' }\n        transition.apply(el, 1, op, vm, cb)\n        expect(op).toHaveBeenCalled()\n        expect(cb).toHaveBeenCalled()\n      })\n\n      it('skip vm with parent still being compiled', function () {\n        el.__v_trans = { id: 'test' }\n        var child = vm.$addChild({\n          el: el\n        })\n        expect(child._isCompiled).toBe(true)\n        transition.apply(el, 1, op, child, cb)\n        expect(op).toHaveBeenCalled()\n        expect(cb).toHaveBeenCalled()\n      })\n\n      it('skip when no transition available', function () {\n        var e = _.transitionEndEvent\n        _.transitionEndEvent = null\n        el.__v_trans = { id: 'test' }\n        vm.$mount(el)\n        transition.apply(el, 1, op, vm, cb)\n        expect(op).toHaveBeenCalled()\n        expect(cb).toHaveBeenCalled()\n        _.transitionEndEvent = e\n      })\n\n    })\n\n    describe('CSS transitions', function () {\n\n      var duration = '50ms'\n\n      // insert a test css\n      function insertCSS (text) {\n        var cssEl = document.createElement('style')\n        cssEl.textContent = text\n        document.head.appendChild(cssEl)\n      }\n\n      insertCSS(\n        '.test {\\\n          transition: opacity ' + duration + ' ease;\\\n          -webkit-transition: opacity ' + duration + ' ease;}'\n      )\n      insertCSS('.test-enter, .test-leave { opacity: 0; }')\n      insertCSS(\n        '.test-anim-enter {\\\n          animation: test-enter ' + duration + ';\\\n          -webkit-animation: test-enter ' + duration + ';}\\\n        .test-anim-leave {\\\n          animation: test-leave ' + duration + ';\\\n          -webkit-animation: test-leave ' + duration + ';}\\\n        @keyframes test-enter {\\\n          from { opacity: 0 }\\\n          to { opacity: 1 }}\\\n        @-webkit-keyframes test-enter {\\\n          from { opacity: 0 }\\\n          to { opacity: 1 }}\\\n        @keyframes test-leave {\\\n          from { opacity: 1 }\\\n          to { opacity: 0 }}\\\n        @-webkit-keyframes test-leave {\\\n          from { opacity: 1 }\\\n          to { opacity: 0 }}'\n      )\n\n      var vm, el, op, cb\n      beforeEach(function (done) {\n        el = document.createElement('div')\n        el.__v_trans = {}\n        vm = new Vue({ el: el })\n        op = jasmine.createSpy('css op')\n        cb = jasmine.createSpy('css cb')\n        document.body.appendChild(el)\n        // !IMPORTANT!\n        // this ensures we force a layout for every test.\n        _.nextTick(done)\n        spyOn(window, 'getComputedStyle').and.callThrough()\n      })\n\n      afterEach(function () {\n        document.body.removeChild(el)\n      })\n\n      it('skip on 0s duration (execute right at next frame)', function (done) {\n        el.__v_trans.id = 'test'\n        el.style.transition =\n        el.style.WebkitTransition = 'opacity 0s ease'\n        transition.apply(el, 1, op, vm, cb)\n        _.nextTick(function () {\n          expect(op).toHaveBeenCalled()\n          expect(cb).toHaveBeenCalled()\n          expect(el.classList.contains('test-enter')).toBe(false)\n          transition.apply(el, -1, op, vm, cb)\n          _.nextTick(function () {\n            expect(op.calls.count()).toBe(2)\n            expect(cb.calls.count()).toBe(2)\n            expect(el.classList.contains('test-leave')).toBe(false)\n            done()\n          })\n        })\n      })\n\n      it('skip when no transition available', function (done) {\n        el.__v_trans.id = 'test-no-trans'\n        transition.apply(el, 1, op, vm, cb)\n        _.nextTick(function () {\n          expect(op).toHaveBeenCalled()\n          expect(cb).toHaveBeenCalled()\n          expect(el.classList.contains('test-no-trans-enter')).toBe(false)\n          transition.apply(el, -1, op, vm, cb)\n          _.nextTick(function () {\n            expect(op.calls.count()).toBe(2)\n            expect(cb.calls.count()).toBe(2)\n            expect(el.classList.contains('test-no-trans-leave')).toBe(false)\n            done()\n          })\n        })\n      })\n\n      it('transition enter', function (done) {\n        document.body.removeChild(el)\n        el.__v_trans.id = 'test'\n        // inline style\n        el.style.transition =\n        el.style.WebkitTransition = 'opacity ' + duration + ' ease'\n        transition.apply(el, 1, function () {\n          document.body.appendChild(el)\n          op()\n        }, vm, cb)\n        expect(op).toHaveBeenCalled()\n        expect(cb).not.toHaveBeenCalled()\n        _.nextTick(function () {\n          expect(el.classList.contains('test-enter')).toBe(false)\n          _.on(el, _.transitionEndEvent, function () {\n            expect(cb).toHaveBeenCalled()\n            done()\n          })\n        })\n      })\n\n      it('transition leave', function (done) {\n        el.__v_trans.id = 'test'\n        // cascaded class style\n        el.classList.add('test')\n        // force a layout here so the transition can be triggered\n        var f = el.offsetHeight\n        transition.apply(el, -1, op, vm, cb)\n        _.nextTick(function () {\n          expect(op).not.toHaveBeenCalled()\n          expect(cb).not.toHaveBeenCalled()\n          expect(el.classList.contains('test-leave')).toBe(true)\n          _.on(el, _.transitionEndEvent, function () {\n            expect(op).toHaveBeenCalled()\n            expect(cb).toHaveBeenCalled()\n            expect(el.classList.contains('test-leave')).toBe(false)\n            done()\n          })\n        })\n      })\n\n      it('animation enter', function (done) {\n        document.body.removeChild(el)\n        el.__v_trans.id = 'test-anim'\n        transition.apply(el, 1, function () {\n          document.body.appendChild(el)\n          op()\n        }, vm, cb)\n        _.nextTick(function () {\n          expect(op).toHaveBeenCalled()\n          expect(cb).not.toHaveBeenCalled()\n          expect(el.classList.contains('test-anim-enter')).toBe(true)\n          _.on(el, _.animationEndEvent, function () {\n            expect(el.classList.contains('test-anim-enter')).toBe(false)\n            expect(cb).toHaveBeenCalled()\n            done()\n          })\n        })\n      })\n\n      it('animation leave', function (done) {\n        el.__v_trans.id = 'test-anim'\n        transition.apply(el, -1, op, vm, cb)\n        _.nextTick(function () {\n          expect(op).not.toHaveBeenCalled()\n          expect(cb).not.toHaveBeenCalled()\n          expect(el.classList.contains('test-anim-leave')).toBe(true)\n          _.on(el, _.animationEndEvent, function () {\n            expect(op).toHaveBeenCalled()\n            expect(cb).toHaveBeenCalled()\n            expect(el.classList.contains('test-anim-leave')).toBe(false)\n            done()\n          })\n        })\n      })\n\n      it('clean up unfinished callback', function (done) {\n        el.__v_trans.id = 'test'\n        el.classList.add('test')\n        transition.apply(el, -1, function () {\n          document.body.removeChild(el)\n        }, vm, cb)\n        // cancel early\n        _.nextTick(function () {\n          expect(el.__v_trans.callback).toBeTruthy()\n          expect(el.classList.contains('test-leave')).toBe(true)\n          transition.apply(el, 1, function () {\n            document.body.appendChild(el)\n          }, vm)\n          expect(cb).not.toHaveBeenCalled()\n          expect(el.classList.contains('test-leave')).toBe(false)\n          expect(el.__v_trans.callback).toBeNull()\n          // IMPORTANT\n          // Let the queue flush finish before enter the next\n          // test. Don't remove the nextTick.\n          _.nextTick(done)\n        })\n      })\n\n      it('cache transition sniff results', function (done) {\n        el.__v_trans.id = 'test'\n        el.classList.add('test')\n        transition.apply(el, 1, op, vm)\n        _.nextTick(function () {\n          expect(window.getComputedStyle.calls.count()).toBe(1)\n          transition.apply(el, 1, op, vm)\n          _.nextTick(function () {\n            expect(window.getComputedStyle.calls.count()).toBe(1)\n            done()\n          })\n        })\n      })\n\n    })\n\n    describe('JavaScript transitions', function () {\n\n      var el, vm, op, cb, def, emitter\n      beforeEach(function () {\n        emitter = {}\n        def = {}\n        el = document.createElement('div')\n        el.__v_trans = { id: 'test', fns: def }\n        document.body.appendChild(el)\n        op = jasmine.createSpy('js transition op')\n        cb = jasmine.createSpy('js transition cb')\n        vm = new Vue({ el: el })\n      })\n\n      afterEach(function () {\n        document.body.removeChild(el)\n      })\n\n      it('beforeEnter', function () {\n        var spy = jasmine.createSpy('js transition beforeEnter')\n        def.beforeEnter = function (el) {\n          spy(this, el)\n        }\n        transition.apply(el, 1, op, vm, cb)\n        expect(spy).toHaveBeenCalledWith(vm, el)\n      })\n\n      it('enter', function () {\n        var spy = jasmine.createSpy('js enter')\n        def.enter = function (e, done) {\n          expect(e).toBe(el)\n          expect(op).toHaveBeenCalled()\n          done()\n          expect(cb).toHaveBeenCalled()\n          spy(this)\n        }\n        transition.apply(el, 1, op, vm, cb)\n        expect(spy).toHaveBeenCalledWith(vm)\n      })\n\n      it('this context set to el instance', function () {\n        var spy = jasmine.createSpy('js enter this')\n        var vm2 = el.__vue__ = {}\n        def.enter = function (e, done) {\n          expect(e).toBe(el)\n          expect(op).toHaveBeenCalled()\n          done()\n          expect(cb).toHaveBeenCalled()\n          spy(this)\n        }\n        transition.apply(el, 1, op, vm, cb)\n        expect(spy).toHaveBeenCalledWith(vm2)\n      })\n\n      it('leave', function () {\n        var spy = jasmine.createSpy('js leave')\n        def.leave = function (e, done) {\n          expect(e).toBe(el)\n          done()\n          expect(op).toHaveBeenCalled()\n          expect(cb).toHaveBeenCalled()\n          spy(this)\n        }\n        transition.apply(el, -1, op, vm, cb)\n        expect(spy).toHaveBeenCalledWith(vm)\n      })\n\n      it('no def', function () {\n        transition.apply(el, 1, op, vm, cb)\n        expect(op).toHaveBeenCalled()\n        expect(cb).toHaveBeenCalled()\n        transition.apply(el, -1, op, vm, cb)\n        expect(op.calls.count()).toBe(2)\n        expect(cb.calls.count()).toBe(2)\n      })\n\n      it('optional cleanup callback', function (done) {\n        var cleanupSpy = jasmine.createSpy('js cleanup')\n        var leaveSpy = jasmine.createSpy('js leave')\n        def.enter = function (el, done) {\n          var to = setTimeout(done, 30)\n          return function () {\n            clearTimeout(to)\n            cleanupSpy()\n          }\n        }\n        def.leave = function (el, done) {\n          expect(cleanupSpy).toHaveBeenCalled()\n          leaveSpy()\n          done()\n        }\n        transition.apply(el, 1, op, vm, cb)\n        setTimeout(function () {\n          transition.apply(el, -1, op, vm)\n          expect(leaveSpy).toHaveBeenCalled()\n          setTimeout(function () {\n            expect(cb).not.toHaveBeenCalled()\n            done()\n          }, 30)\n        }, 15)\n      })\n\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/transition/transition_spec.js\n ** module id = 106\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\nvar config = require('../../../../src/config')\nvar infoPrefix = '[Vue info]: '\nvar warnPrefix = '[Vue warn]: '\nconfig.silent = true\n\nif (typeof console !== 'undefined') {\n\n  describe('Util - Debug', function () {\n\n    beforeEach(function () {\n      spyOn(console, 'log')\n      spyOn(console, 'warn')\n      if (console.trace) {\n        spyOn(console, 'trace')\n      }\n    })\n    \n    it('log when debug is true', function () {\n      config.debug = true\n      _.log('hello')\n      expect(console.log).toHaveBeenCalledWith(infoPrefix + 'hello')\n    })\n\n    it('not log when debug is false', function () {\n      config.debug = false\n      _.log('bye')\n      expect(console.log).not.toHaveBeenCalled()\n    })\n\n    it('warn when silent is false', function () {\n      config.silent = false\n      _.warn('oops')\n      expect(console.warn).toHaveBeenCalledWith(warnPrefix + 'oops')\n    })\n\n    it('not warn when silent is ture', function () {\n      config.silent = true\n      _.warn('oops')\n      expect(console.warn).not.toHaveBeenCalled()\n    })\n\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/util/debug_spec.js\n ** module id = 107\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\n\nif (_.inBrowser) {\n\n  describe('Util - DOM', function () {\n\n    var parent, child, target\n\n    function div () {\n      return document.createElement('div')\n    }\n\n    beforeEach(function () {\n      parent = div()\n      child = div()\n      target = div()\n      parent.appendChild(child) \n    })\n\n    it('inDoc', function () {\n      expect(_.inDoc(target)).toBe(false)\n      document.body.appendChild(target)\n      expect(_.inDoc(target)).toBe(true)\n      document.body.removeChild(target)\n      expect(_.inDoc(target)).toBe(false)\n    })\n\n    it('attr', function () {\n      target.setAttribute('v-test', 'ok')\n      var val = _.attr(target, 'test')\n      expect(val).toBe('ok')\n      expect(target.hasAttribute('v-test')).toBe(false)\n    })\n    \n    it('before', function () {\n      _.before(target, child)\n      expect(target.parentNode).toBe(parent)\n      expect(target.nextSibling).toBe(child)\n    })\n\n    it('after', function () {\n      _.after(target, child)\n      expect(target.parentNode).toBe(parent)\n      expect(child.nextSibling).toBe(target)\n    })\n\n    it('after with sibling', function () {\n      var sibling = div()\n      parent.appendChild(sibling)\n      _.after(target, child)\n      expect(target.parentNode).toBe(parent)\n      expect(child.nextSibling).toBe(target)\n    })\n\n    it('remove', function () {\n      _.remove(child)\n      expect(child.parentNode).toBeNull()\n      expect(parent.childNodes.length).toBe(0)\n    })\n\n    it('prepend', function () {\n      _.prepend(target, parent)\n      expect(target.parentNode).toBe(parent)\n      expect(parent.firstChild).toBe(target)\n    })\n\n    it('prepend to empty node', function () {\n      parent.removeChild(child)\n      _.prepend(target, parent)\n      expect(target.parentNode).toBe(parent)\n      expect(parent.firstChild).toBe(target)\n    })\n\n    it('replace', function () {\n      _.replace(child, target)\n      expect(parent.childNodes.length).toBe(1)\n      expect(parent.firstChild).toBe(target)\n    })\n\n    it('copyAttributes', function () {\n      parent.setAttribute('test1', 1)\n      parent.setAttribute('test2', 2)\n      _.copyAttributes(parent, target)\n      expect(target.attributes.length).toBe(2)\n      expect(target.getAttribute('test1')).toBe('1')\n      expect(target.getAttribute('test2')).toBe('2')\n    })\n\n    it('on/off', function () {\n      // IE requires element to be in document to fire events\n      document.body.appendChild(target)\n      var spy = jasmine.createSpy()\n      _.on(target, 'click', spy)\n      var e = document.createEvent('HTMLEvents')\n      e.initEvent('click', true, true)\n      target.dispatchEvent(e)\n      expect(spy.calls.count()).toBe(1)\n      expect(spy).toHaveBeenCalledWith(e)\n      _.off(target, 'click', spy)\n      target.dispatchEvent(e)\n      expect(spy.calls.count()).toBe(1)\n      document.body.removeChild(target)\n    })\n\n    it('addClass/removeClass', function () {\n      var el = document.createElement('div')\n      el.className = 'aa bb cc'\n      _.removeClass(el, 'bb')\n      expect(el.className).toBe('aa cc')\n      _.removeClass(el, 'aa')\n      expect(el.className).toBe('cc')\n      _.addClass(el, 'bb')\n      expect(el.className).toBe('cc bb')\n      _.addClass(el, 'bb')\n      expect(el.className).toBe('cc bb')\n    })\n\n    it('addClass/removeClass for SVG/IE9', function () {\n      var el = document.createElementNS('http://www.w3.org/2000/svg', 'circle')\n      el.setAttribute('class', 'aa bb cc')\n      _.removeClass(el, 'bb')\n      expect(el.getAttribute('class')).toBe('aa cc')\n      _.removeClass(el, 'aa')\n      expect(el.getAttribute('class')).toBe('cc')\n      _.addClass(el, 'bb')\n      expect(el.getAttribute('class')).toBe('cc bb')\n      _.addClass(el, 'bb')\n      expect(el.getAttribute('class')).toBe('cc bb')\n    })\n  })\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/util/dom_spec.js\n ** module id = 108\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\n\ndescribe('Util - Environment', function () {\n\n  describe('nextTick', function () {\n\n    it('should accept context', function (done) {\n      var ctx = {}\n      _.nextTick(function () {\n        this.id = 1\n      }, ctx)\n      _.nextTick(function () {\n        expect(ctx.id).toBe(1)\n        done()\n      })\n    })\n\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/util/env_spec.js\n ** module id = 109\n ** module chunks = 0\n **/","var _ = require('../../../../src/util')\n\ndescribe('Util - Language Enhancement', function () {\n\n  it('toString', function () {\n    expect(_.toString('hi')).toBe('hi')\n    expect(_.toString(1.234)).toBe('1.234')\n    expect(_.toString(null)).toBe('')\n    expect(_.toString(undefined)).toBe('')\n  })\n\n  it('toNumber', function () {\n    expect(_.toNumber('12')).toBe(12)\n    expect(_.toNumber('1e5')).toBe(1e5)\n    expect(_.toNumber('0x2F')).toBe(0x2F)\n    expect(_.toNumber(null)).toBe(null)\n    expect(_.toNumber(true)).toBe(true)\n    expect(_.toNumber('hello')).toBe('hello')\n  })\n\n  it('strip quotes', function () {\n    expect(_.stripQuotes('\"123\"')).toBe('123')\n    expect(_.stripQuotes(\"'fff'\")).toBe('fff')\n    expect(_.stripQuotes(\"'fff\")).toBe(false)\n  })\n\n  it('camelize', function () {\n    expect(_.camelize('abc')).toBe('abc')\n    expect(_.camelize('some-long-name')).toBe('someLongName')\n  })\n\n  it('classify', function () {\n    expect(_.classify('abc')).toBe('Abc')\n    expect(_.classify('some-long-name')).toBe('SomeLongName')\n    expect(_.classify('what_about_this')).toBe('WhatAboutThis')\n    expect(_.classify('how/about/that')).toBe('HowAboutThat')\n  })\n\n  it('bind', function () {\n    var original = function (a) {\n      return this.a + a\n    }\n    var ctx = { a: 'ctx a ' }\n    var bound = _.bind(original, ctx)\n    var res = bound('arg a')\n    expect(res).toBe('ctx a arg a')\n  })\n  \n  it('toArray', function () {\n    // should make a copy of original array\n    var arr = [1,2,3]\n    var res = _.toArray(arr)\n    expect(Array.isArray(res)).toBe(true)\n    expect(res.toString()).toEqual('1,2,3')\n    expect(res).not.toBe(arr)\n\n    // should work on arguments\n    ;(function () {\n      var res = _.toArray(arguments)\n      expect(Array.isArray(res)).toBe(true)\n      expect(res.toString()).toEqual('1,2,3')\n    })(1,2,3)\n  })\n\n  it('extend', function () {\n    var from = {a:1,b:2}\n    var to = {}\n    var res = _.extend(to, from)\n    expect(to.a).toBe(from.a)\n    expect(to.b).toBe(from.b)\n    expect(res).toBe(to)\n  })\n\n  it('isObject', function () {\n    expect(_.isObject({})).toBe(true)\n    expect(_.isObject([])).toBe(true)\n    expect(_.isObject(null)).toBeFalsy()\n    expect(_.isObject(123)).toBeFalsy()\n    expect(_.isObject(true)).toBeFalsy()\n    expect(_.isObject('hi')).toBeFalsy()\n    expect(_.isObject(undefined)).toBeFalsy()\n    expect(_.isObject(function(){})).toBeFalsy()\n  })\n\n  it('isPlainObject', function () {\n    expect(_.isPlainObject({})).toBe(true)\n    expect(_.isPlainObject([])).toBe(false)\n    expect(_.isPlainObject(null)).toBe(false)\n    expect(_.isPlainObject(null)).toBeFalsy()\n    expect(_.isPlainObject(123)).toBeFalsy()\n    expect(_.isPlainObject(true)).toBeFalsy()\n    expect(_.isPlainObject('hi')).toBeFalsy()\n    expect(_.isPlainObject(undefined)).toBeFalsy()\n    expect(_.isPlainObject(function(){})).toBe(false)\n    if (_.inBrowser) {\n      expect(_.isPlainObject(window)).toBe(false)\n    }\n  })\n\n  it('isArray', function () {\n    expect(_.isArray([])).toBe(true)\n    expect(_.isArray({})).toBe(false)\n    expect(_.isArray(arguments)).toBe(false)\n  })\n\n  it('define', function () {\n    var obj = {}\n    _.define(obj, 'test', 123)\n    expect(obj.test).toBe(123)\n    var desc = Object.getOwnPropertyDescriptor(obj, 'test')\n    expect(desc.enumerable).toBe(false)\n\n    _.define(obj, 'test2', 123, true)\n    expect(obj.test2).toBe(123)\n    desc = Object.getOwnPropertyDescriptor(obj, 'test2')\n    expect(desc.enumerable).toBe(true)\n  })\n\n  it('debounce', function (done) {\n    var count = 0\n    var fn = _.debounce(function () {\n      count++\n    }, 100)\n    fn()\n    setTimeout(fn, 10)\n    setTimeout(fn, 20)\n    setTimeout(function () {\n      expect(count).toBe(0)\n    }, 30)\n    setTimeout(function () {\n      expect(count).toBe(1)\n      done()\n    }, 200)\n  })\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/util/lang_spec.js\n ** module id = 110\n ** module chunks = 0\n **/","var Vue = require('../../../src/vue')\nvar nextTick = Vue.nextTick\nvar Watcher = require('../../../src/watcher')\nvar _ = Vue.util\nvar config = Vue.config\n\ndescribe('Watcher', function () {\n\n  var vm, spy\n\n  beforeEach(function () {\n    vm = new Vue({\n      filters: {},\n      data: {\n        a: 1,\n        b: {\n          c: 2,\n          d: 4\n        },\n        c: 'c'\n      }\n    })\n    spy = jasmine.createSpy('watcher')\n    spyOn(_, 'warn')\n  })\n  \n  it('simple path', function (done) {\n    var watcher = new Watcher(vm, 'b.c', spy)\n    expect(watcher.value).toBe(2)\n    vm.b.c = 3\n    nextTick(function () {\n      expect(watcher.value).toBe(3)\n      expect(spy).toHaveBeenCalledWith(3, 2)\n      vm.b = { c: 4 } // swapping the object\n      nextTick(function () {\n        expect(watcher.value).toBe(4)\n        expect(spy).toHaveBeenCalledWith(4, 3)\n        done()\n      })\n    })\n  })\n\n  it('bracket access path', function (done) {\n    var watcher = new Watcher(vm, 'b[\"c\"]', spy)\n    expect(watcher.value).toBe(2)\n    vm.b.c = 3\n    nextTick(function () {\n      expect(watcher.value).toBe(3)\n      expect(spy).toHaveBeenCalledWith(3, 2)\n      vm.b = { c: 4 } // swapping the object\n      nextTick(function () {\n        expect(watcher.value).toBe(4)\n        expect(spy).toHaveBeenCalledWith(4, 3)\n        done()\n      })\n    })\n  })\n\n  it('dynamic path', function (done) {\n    var watcher = new Watcher(vm, 'b[c]', spy)\n    expect(watcher.value).toBe(2)\n    vm.b.c = 3\n    nextTick(function () {\n      expect(watcher.value).toBe(3)\n      expect(spy).toHaveBeenCalledWith(3, 2)\n      vm.c = 'd' // changing the dynamic segment in path\n      nextTick(function () {\n        expect(watcher.value).toBe(4)\n        expect(spy).toHaveBeenCalledWith(4, 3)\n        done()\n      })\n    })\n  })\n\n  it('simple expression', function (done) {\n    var watcher = new Watcher(vm, 'a + b.c', spy)\n    expect(watcher.value).toBe(3)\n    vm.b.c = 3\n    nextTick(function () {\n      expect(watcher.value).toBe(4)\n      expect(spy.calls.count()).toBe(1)\n      expect(spy).toHaveBeenCalledWith(4, 3)\n      // change two dependencies at once\n      vm.a = 2\n      vm.b.c = 4\n      nextTick(function () {\n        expect(watcher.value).toBe(6)\n        // should trigger only once callback,\n        // because it was in the same event loop.\n        expect(spy.calls.count()).toBe(2)\n        expect(spy).toHaveBeenCalledWith(6, 4)\n        done()\n      })\n    })\n  })\n\n  it('ternary expression', function (done) {\n    // we're actually testing for the dependency re-calculation here\n    var watcher = new Watcher(vm, 'a > 1 ? b.c : b.d', spy)\n    expect(watcher.value).toBe(4)\n    vm.a = 2\n    nextTick(function () {\n      expect(watcher.value).toBe(2)\n      expect(spy).toHaveBeenCalledWith(2, 4)\n      vm.b.c = 3\n      nextTick(function () {\n        expect(watcher.value).toBe(3)\n        expect(spy).toHaveBeenCalledWith(3, 2)\n        done()\n      })\n    })\n  })\n\n  it('meta properties', function (done) {\n    vm._defineMeta('$index', 1)\n    var watcher = new Watcher(vm, '$index + 1', spy)\n    expect(watcher.value).toBe(2)\n    vm.$index = 2\n    nextTick(function () {\n      expect(watcher.value).toBe(3)\n      done()\n    })\n  })\n\n  it('non-existent path, $add later', function (done) {\n    var watcher = new Watcher(vm, 'd.e', spy)\n    var watcher2 = new Watcher(vm, 'b.e', spy)\n    expect(watcher.value).toBeUndefined()\n    expect(watcher2.value).toBeUndefined()\n    // check $add affecting children\n    var child = vm.$addChild({\n      inherit: true\n    })\n    var watcher3 = new Watcher(child, 'd.e', spy)\n    var watcher4 = new Watcher(child, 'b.e', spy)\n    // check $add should not affect isolated children\n    var child2 = vm.$addChild()\n    var watcher5 = new Watcher(child2, 'd.e', spy)\n    expect(watcher5.value).toBeUndefined()\n    vm.$add('d', { e: 123 })\n    vm.b.$add('e', 234)\n    nextTick(function () {\n      expect(watcher.value).toBe(123)\n      expect(watcher2.value).toBe(234)\n      expect(watcher3.value).toBe(123)\n      expect(watcher4.value).toBe(234)\n      expect(watcher5.value).toBeUndefined()\n      expect(spy.calls.count()).toBe(4)\n      expect(spy).toHaveBeenCalledWith(123, undefined)\n      expect(spy).toHaveBeenCalledWith(234, undefined)\n      done()\n    })\n  })\n\n  it('$delete', function (done) {\n    var watcher = new Watcher(vm, 'b.c', spy)\n    expect(watcher.value).toBe(2)\n    vm.$delete('b')\n    nextTick(function () {\n      expect(watcher.value).toBeUndefined()\n      expect(spy).toHaveBeenCalledWith(undefined, 2)\n      done()\n    })\n  })\n\n  it('swapping $data', function (done) {\n    // existing path\n    var watcher = new Watcher(vm, 'b.c', spy)\n    var spy2 = jasmine.createSpy()\n    // non-existing path\n    var watcher2 = new Watcher(vm, 'e', spy2)\n    expect(watcher.value).toBe(2)\n    expect(watcher2.value).toBeUndefined()\n    vm.$data = { b: { c: 3}, e: 4 }\n    nextTick(function () {\n      expect(watcher.value).toBe(3)\n      expect(watcher2.value).toBe(4)\n      expect(spy).toHaveBeenCalledWith(3, 2)\n      expect(spy2).toHaveBeenCalledWith(4, undefined)\n      done()\n    })\n  })\n\n  it('path containing $data', function (done) {\n    var watcher = new Watcher(vm, '$data.b.c', spy)\n    expect(watcher.value).toBe(2)\n    vm.b = { c: 3 }\n    nextTick(function () {\n      expect(watcher.value).toBe(3)\n      expect(spy).toHaveBeenCalledWith(3, 2)\n      vm.$data = { b: {c: 4}}\n      nextTick(function () {\n        expect(watcher.value).toBe(4)\n        expect(spy).toHaveBeenCalledWith(4, 3)\n        done()\n      })\n    })\n  })\n\n  it('watching $data', function (done) {\n    var oldData = vm.$data\n    var watcher = new Watcher(vm, '$data', spy)\n    expect(watcher.value).toBe(oldData)\n    var newData = {}\n    vm.$data = newData\n    nextTick(function() {\n      expect(spy).toHaveBeenCalledWith(newData, oldData)\n      expect(watcher.value).toBe(newData)\n      done()\n    })\n  })\n\n  it('watching parent scope properties', function (done) {\n    var child = vm.$addChild({\n      inherit: true\n    })\n    var spy2 = jasmine.createSpy('watch')\n    var watcher1 = new Watcher(child, '$data', spy)\n    var watcher2 = new Watcher(child, 'a', spy2)\n    vm.a = 123\n    nextTick(function () {\n      // $data should only be called on self data change\n      expect(watcher1.value).toBe(child.$data)\n      expect(spy).not.toHaveBeenCalled()\n      expect(watcher2.value).toBe(123)\n      expect(spy2).toHaveBeenCalledWith(123, 1)\n      done()\n    })\n  })\n\n  it('filters', function (done) {\n    vm.$options.filters.test = function (val, multi) {\n      return val * multi\n    }\n    vm.$options.filters.test2 = function (val, str) {\n      return val + str\n    }\n    var filters = _.resolveFilters(vm, [\n      { name: 'test', args: [3] },\n      { name: 'test2', args: ['yo']}\n    ])\n    var watcher = new Watcher(vm, 'b.c', spy, {\n      filters: filters\n    })\n    expect(watcher.value).toBe('6yo')\n    vm.b.c = 3\n    nextTick(function () {\n      expect(watcher.value).toBe('9yo')\n      expect(spy).toHaveBeenCalledWith('9yo', '6yo')\n      done()\n    })\n  })\n\n  it('setter', function (done) {\n    vm.$options.filters.test = {\n      write: function (val, oldVal, arg) {\n        return val > arg ? val : oldVal\n      }\n    }\n    var filters = _.resolveFilters(vm, [\n      { name: 'test', args: [5] }\n    ])\n    var watcher = new Watcher(vm, 'b[\"c\"]', spy, {\n      filters: filters,\n      twoWay: true\n    })\n    expect(watcher.value).toBe(2)\n    watcher.set(4) // shoud not change the value\n    nextTick(function () {\n      expect(vm.b.c).toBe(2)\n      expect(watcher.value).toBe(2)\n      expect(spy).not.toHaveBeenCalled()\n      watcher.set(6)\n      nextTick(function () {\n        expect(vm.b.c).toBe(6)\n        expect(watcher.value).toBe(6)\n        expect(spy).toHaveBeenCalledWith(6, 2)\n        done()\n      })\n    })\n  })\n\n  it('set non-existent values', function (done) {\n    var watcher = new Watcher(vm, 'd.e.f', spy)\n    expect(watcher.value).toBeUndefined()\n    watcher.set(123)\n    nextTick(function () {\n      expect(vm.d.e.f).toBe(123)\n      expect(watcher.value).toBe(123)\n      expect(spy).toHaveBeenCalledWith(123, undefined)\n      done()\n    })\n  })\n\n  it('deep watch', function (done) {\n    var watcher = new Watcher(vm, 'b', spy, {\n      deep: true\n    })\n    vm.b.c = { d: 4 }\n    nextTick(function () {\n      expect(spy).toHaveBeenCalledWith(vm.b, vm.b)\n      var oldB = vm.b\n      vm.b = { c: [{a:1}] }\n      nextTick(function () {\n        expect(spy).toHaveBeenCalledWith(vm.b, oldB)\n        expect(spy.calls.count()).toBe(2)\n        vm.b.c[0].a = 2\n        nextTick(function () {\n          expect(spy).toHaveBeenCalledWith(vm.b, vm.b)\n          expect(spy.calls.count()).toBe(3)\n          done()\n        })\n      })\n    })\n  })\n\n  it('add callback', function (done) {\n    var watcher = new Watcher(vm, 'a', spy)\n    var spy2 = jasmine.createSpy()\n    watcher.addCb(spy2)\n    vm.a = 99\n    nextTick(function () {\n      expect(spy).toHaveBeenCalledWith(99, 1)\n      expect(spy2).toHaveBeenCalledWith(99, 1)\n      done()\n    })\n  })\n\n  it('remove callback', function (done) {\n    // single, should equal teardown\n    var fn = function () {}\n    var watcher = new Watcher(vm, 'a', fn)\n    watcher.removeCb(fn)\n    expect(watcher.active).toBe(false)\n    expect(watcher.vm).toBe(null)\n    expect(watcher.cbs).toBe(null)\n    // multiple\n    watcher = new Watcher(vm, 'a', spy)\n    var spy2 = jasmine.createSpy()\n    watcher.addCb(spy2)\n    watcher.removeCb(spy)\n    vm.a = 234\n    nextTick(function () {\n      expect(spy).not.toHaveBeenCalled()\n      expect(spy2).toHaveBeenCalledWith(234, 1)\n      done()\n    })\n  })\n\n  it('teardown', function (done) {\n    var watcher = new Watcher(vm, 'b.c', spy)\n    watcher.teardown()\n    vm.b.c = 3\n    nextTick(function () {\n      expect(watcher.active).toBe(false)\n      expect(watcher.vm).toBe(null)\n      expect(watcher.cbs).toBe(null)\n      expect(spy).not.toHaveBeenCalled()\n      done()\n    })\n  })\n\n  it('synchronous updates', function () {\n    config.async = false\n    var watcher = new Watcher(vm, 'a', spy)\n    vm.a = 2\n    vm.a = 3\n    expect(spy.calls.count()).toBe(2)\n    expect(spy).toHaveBeenCalledWith(2, 1)\n    expect(spy).toHaveBeenCalledWith(3, 2)\n    config.async = true\n  })\n\n  it('handle a cb that triggers removeCb', function () {\n    var watcher = new Watcher(vm, 'a', spy)\n    watcher.addCb(function () {\n      watcher.removeCb(spy)\n    })\n    watcher.addCb(function () {})\n    config.async = false\n    expect(function () {\n      vm.a = 2\n    }).not.toThrow()\n    config.async = true\n    expect(spy).toHaveBeenCalled()\n    expect(watcher.cbs.length).toBe(2)\n  })\n\n  it('warn getter errors', function () {\n    var watcher = new Watcher(vm, 'd.e + c', spy)\n    expect(_.warn).toHaveBeenCalled()\n  })\n\n  it('warn setter errors', function () {\n    var watcher = new Watcher(vm, 'a + b', spy)\n    watcher.set(123)\n    expect(_.warn).toHaveBeenCalled()\n  })\n\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./test/unit/specs/watcher_spec.js\n ** module id = 113\n ** module chunks = 0\n **/","var _ = require('./index')\nvar extend = _.extend\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n *\n * All strategy functions follow the same signature:\n *\n * @param {*} parentVal\n * @param {*} childVal\n * @param {Vue} [vm]\n */\n\nvar strats = Object.create(null)\n\n/**\n * Helper that recursively merges two data objects together.\n */\n\nfunction mergeData (to, from) {\n  var key, toVal, fromVal\n  for (key in from) {\n    toVal = to[key]\n    fromVal = from[key]\n    if (!to.hasOwnProperty(key)) {\n      to.$add(key, fromVal)\n    } else if (_.isObject(toVal) && _.isObject(fromVal)) {\n      mergeData(toVal, fromVal)\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\n\nstrats.data = function (parentVal, childVal, vm) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      _.warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.'\n      )\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else {\n    // instance merge, return raw object\n    var instanceData = typeof childVal === 'function'\n      ? childVal.call(vm)\n      : childVal\n    var defaultData = typeof parentVal === 'function'\n      ? parentVal.call(vm)\n      : undefined\n    if (instanceData) {\n      return mergeData(instanceData, defaultData)\n    } else {\n      return defaultData\n    }\n  }\n}\n\n/**\n * El\n */\n\nstrats.el = function (parentVal, childVal, vm) {\n  if (!vm && childVal && typeof childVal !== 'function') {\n    _.warn(\n      'The \"el\" option should be a function ' +\n      'that returns a per-instance value in component ' +\n      'definitions.'\n    )\n    return\n  }\n  var ret = childVal || parentVal\n  // invoke the element factory if this is instance merge\n  return vm && typeof ret === 'function'\n    ? ret.call(vm)\n    : ret\n}\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\n\nstrats.created =\nstrats.ready =\nstrats.attached =\nstrats.detached =\nstrats.beforeCompile =\nstrats.compiled =\nstrats.beforeDestroy =\nstrats.destroyed =\nstrats.paramAttributes = function (parentVal, childVal) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : _.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\n\nstrats.directives =\nstrats.filters =\nstrats.partials =\nstrats.transitions =\nstrats.components = function (parentVal, childVal, vm, key) {\n  var ret = Object.create(\n    vm && vm.$parent\n      ? vm.$parent.$options[key]\n      : _.Vue.options[key]\n  )\n  if (parentVal) {\n    var keys = Object.keys(parentVal)\n    var i = keys.length\n    var field\n    while (i--) {\n      field = keys[i]\n      ret[field] = parentVal[field]\n    }\n  }\n  if (childVal) extend(ret, childVal)\n  return ret\n}\n\n/**\n * Events & Watchers.\n *\n * Events & watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\n\nstrats.watch =\nstrats.events = function (parentVal, childVal) {\n  if (!childVal) return parentVal\n  if (!parentVal) return childVal\n  var ret = {}\n  extend(ret, parentVal)\n  for (var key in childVal) {\n    var parent = ret[key]\n    var child = childVal[key]\n    if (parent && !_.isArray(parent)) {\n      parent = [parent]\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child]\n  }\n  return ret\n}\n\n/**\n * Other object hashes.\n */\n\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) return parentVal\n  if (!parentVal) return childVal\n  var ret = Object.create(parentVal)\n  extend(ret, childVal)\n  return ret\n}\n\n/**\n * Default strategy.\n */\n\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n}\n\n/**\n * Make sure component options get converted to actual\n * constructors.\n *\n * @param {Object} components\n */\n\nfunction guardComponents (components) {\n  if (components) {\n    var def\n    for (var key in components) {\n      def = components[key]\n      if (_.isPlainObject(def)) {\n        def.name = key\n        components[key] = _.Vue.extend(def)\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n *\n * @param {Object} parent\n * @param {Object} child\n * @param {Vue} [vm] - if vm is present, indicates this is\n *                     an instantiation merge.\n */\n\nmodule.exports = function mergeOptions (parent, child, vm) {\n  guardComponents(child.components)\n  var options = {}\n  var key\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm)\n    }\n  }\n  for (key in parent) {\n    merge(key)\n  }\n  for (key in child) {\n    if (!(parent.hasOwnProperty(key))) {\n      merge(key)\n    }\n  }\n  function merge (key) {\n    var strat = strats[key] || defaultStrat\n    options[key] = strat(parent[key], child[key], vm, key)\n  }\n  return options\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util/merge-option.js\n ** module id = 114\n ** module chunks = 0\n **/","var _ = require('../util')\nvar templateParser = require('../parsers/template')\nvar vIf = require('./if')\n\nmodule.exports = {\n\n  isLiteral: true,\n\n  // same logic reuse from v-if\n  compile: vIf.compile,\n  teardown: vIf.teardown,\n  getContainedComponents: vIf.getContainedComponents,\n  unbind: vIf.unbind,\n\n  bind: function () {\n    var el = this.el\n    this.start = document.createComment('v-partial-start')\n    this.end = document.createComment('v-partial-end')\n    if (el.nodeType !== 8) {\n      el.innerHTML = ''\n    }\n    if (el.tagName === 'TEMPLATE' || el.nodeType === 8) {\n      _.replace(el, this.end)\n    } else {\n      el.appendChild(this.end)\n    }\n    _.before(this.start, this.end)\n    if (!this._isDynamicLiteral) {\n      this.insert(this.expression)\n    }\n  },\n\n  update: function (id) {\n    this.teardown()\n    this.insert(id)\n  },\n\n  insert: function (id) {\n    var partial = this.vm.$options.partials[id]\n    _.assertAsset(partial, 'partial', id)\n    if (partial) {\n      var filters = this.filters && this.filters.read\n      if (filters) {\n        partial = _.applyFilters(partial, filters, this.vm)\n      }\n      this.compile(templateParser.parse(partial, true))\n    }\n  }\n\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/partial.js\n ** module id = 115\n ** module chunks = 0\n **/","var _ = require('../../util')\n\nmodule.exports = {\n\n  bind: function () {\n    var self = this\n    var el = this.el\n\n    // check params\n    // - lazy: update model on \"change\" instead of \"input\"\n    var lazy = this._checkParam('lazy') != null\n    // - number: cast value into number when updating model.\n    var number = this._checkParam('number') != null\n    // - debounce: debounce the input listener\n    var debounce = parseInt(this._checkParam('debounce'), 10)\n\n    // handle composition events.\n    // http://blog.evanyou.me/2014/01/03/composition-event/\n    var cpLocked = false\n    this.cpLock = function () {\n      cpLocked = true\n    }\n    this.cpUnlock = function () {\n      cpLocked = false\n      // in IE11 the \"compositionend\" event fires AFTER\n      // the \"input\" event, so the input handler is blocked\n      // at the end... have to call it here.\n      set()\n    }\n    _.on(el,'compositionstart', this.cpLock)\n    _.on(el,'compositionend', this.cpUnlock)\n\n    // shared setter\n    function set () {\n      self.set(\n        number ? _.toNumber(el.value) : el.value,\n        true\n      )\n    }\n\n    // if the directive has filters, we need to\n    // record cursor position and restore it after updating\n    // the input with the filtered value.\n    // also force update for type=\"range\" inputs to enable\n    // \"lock in range\" (see #506)\n    var hasReadFilter = this.filters && this.filters.read\n    this.listener = hasReadFilter || el.type === 'range'\n      ? function textInputListener () {\n          if (cpLocked) return\n          var charsOffset\n          // some HTML5 input types throw error here\n          try {\n            // record how many chars from the end of input\n            // the cursor was at\n            charsOffset = el.value.length - el.selectionStart\n          } catch (e) {}\n          // Fix IE10/11 infinite update cycle\n          // https://github.com/yyx990803/vue/issues/592\n          /* istanbul ignore if */\n          if (charsOffset < 0) {\n            return\n          }\n          set()\n          _.nextTick(function () {\n            // force a value update, because in\n            // certain cases the write filters output the\n            // same result for different input values, and\n            // the Observer set events won't be triggered.\n            var newVal = self._watcher.value\n            self.update(newVal)\n            if (charsOffset != null) {\n              var cursorPos =\n                _.toString(newVal).length - charsOffset\n              el.setSelectionRange(cursorPos, cursorPos)\n            }\n          })\n        }\n      : function textInputListener () {\n          if (cpLocked) return\n          set()\n        }\n\n    if (debounce) {\n      this.listener = _.debounce(this.listener, debounce)\n    }\n    this.event = lazy ? 'change' : 'input'\n    // Support jQuery events, since jQuery.trigger() doesn't\n    // trigger native events in some cases and some plugins\n    // rely on $.trigger()\n    // \n    // We want to make sure if a listener is attached using\n    // jQuery, it is also removed with jQuery, that's why\n    // we do the check for each directive instance and\n    // store that check result on itself. This also allows\n    // easier test coverage control by unsetting the global\n    // jQuery variable in tests.\n    this.hasjQuery = typeof jQuery === 'function'\n    if (this.hasjQuery) {\n      jQuery(el).on(this.event, this.listener)\n    } else {\n      _.on(el, this.event, this.listener)\n    }\n\n    // IE9 doesn't fire input event on backspace/del/cut\n    if (!lazy && _.isIE9) {\n      this.onCut = function () {\n        _.nextTick(self.listener)\n      }\n      this.onDel = function (e) {\n        if (e.keyCode === 46 || e.keyCode === 8) {\n          self.listener()\n        }\n      }\n      _.on(el, 'cut', this.onCut)\n      _.on(el, 'keyup', this.onDel)\n    }\n\n    // set initial value if present\n    if (\n      el.hasAttribute('value') ||\n      (el.tagName === 'TEXTAREA' && el.value.trim())\n    ) {\n      this._initValue = number\n        ? _.toNumber(el.value)\n        : el.value\n    }\n  },\n\n  update: function (value) {\n    this.el.value = _.toString(value)\n  },\n\n  unbind: function () {\n    var el = this.el\n    if (this.hasjQuery) {\n      jQuery(el).off(this.event, this.listener)\n    } else {\n      _.off(el, this.event, this.listener)\n    }\n    _.off(el,'compositionstart', this.cpLock)\n    _.off(el,'compositionend', this.cpUnlock)\n    if (this.onCut) {\n      _.off(el,'cut', this.onCut)\n      _.off(el,'keyup', this.onDel)\n    }\n  }\n\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/model/default.js\n ** module id = 116\n ** module chunks = 0\n **/","var _ = require('../util')\nvar Watcher = require('../watcher')\nvar expParser = require('../parsers/expression')\nvar literalRE = /^(true|false|\\s?('[^']*'|\"[^\"]\")\\s?)$/\n\nmodule.exports = {\n\n  priority: 900,\n\n  bind: function () {\n\n    var child = this.vm\n    var parent = child.$parent\n    var childKey = this.arg || '$data'\n    var parentKey = this.expression\n\n    if (this.el && this.el !== child.$el) {\n      _.warn(\n        'v-with can only be used on instance root elements.'\n      )\n    } else if (!parent) {\n      _.warn(\n        'v-with must be used on an instance with a parent.'\n      )\n    } else if (literalRE.test(parentKey)) {\n      // no need to setup watchers for literal bindings\n      if (!this.arg) {\n        _.warn(\n          'v-with cannot bind literal value as $data: ' +\n          parentKey\n        )\n      } else {\n        var value = expParser.parse(parentKey).get()\n        child.$set(childKey, value)\n      }\n    } else {\n\n      // simple lock to avoid circular updates.\n      // without this it would stabilize too, but this makes\n      // sure it doesn't cause other watchers to re-evaluate.\n      var locked = false\n      var lock = function () {\n        locked = true\n        _.nextTick(unlock)\n      }\n      var unlock = function () {\n        locked = false\n      }\n\n      this.parentWatcher = new Watcher(\n        parent,\n        parentKey,\n        function (val) {\n          if (!locked) {\n            lock()\n            child.$set(childKey, val)\n          }\n        }\n      )\n      \n      // set the child initial value first, before setting\n      // up the child watcher to avoid triggering it\n      // immediately.\n      child.$set(childKey, this.parentWatcher.value)\n\n      this.childWatcher = new Watcher(\n        child,\n        childKey,\n        function (val) {\n          if (!locked) {\n            lock()\n            parent.$set(parentKey, val)\n          }\n        }\n      )\n    }\n  },\n\n  unbind: function () {\n    if (this.parentWatcher) {\n      this.parentWatcher.teardown()\n      this.childWatcher.teardown()\n    }\n  }\n\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/directives/with.js\n ** module id = 117\n ** module chunks = 0\n **/"],"sourceRoot":""}